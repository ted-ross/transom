<!--
 
 Licensed to the Apache Software Foundation (ASF) under one
 or more contributor license agreements.  See the NOTICE file
 distributed with this work for additional information
 regarding copyright ownership.  The ASF licenses this file
 to you under the Apache License, Version 2.0 (the
 "License"); you may not use this file except in compliance
 with the License.  You may obtain a copy of the License at
 
   http://www.apache.org/licenses/LICENSE-2.0
 
 Unless required by applicable law or agreed to in writing,
 software distributed under the License is distributed on an
 "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 KIND, either express or implied.  See the License for the
 specific language governing permissions and limitations
 under the License.
 
-->

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <title>qpid::client::no_keyword::AsyncSession_0_10 Class Reference</title>
    <link href="doxygen.css" rel="stylesheet" type="text/css">
    <link href="tabs.css" rel="stylesheet" type="text/css">
  </head>
  <body bgcolor="#FFFFFF">
  <table border="0" width="90%" align="center">
    <tr>
      <td align="left">
	<a title="Apache Qpid Project Page" href="http://qpid.apache.org">Apache Qpid - AMQP Messaging for Java JMS, C++, Python, Ruby, and .NET</a>
      </td>

      <td align="right">	
	<a title="Apache Qpid Documentation" href="http://qpid.apache.org/documentation.html">Apache Qpid Documentation</a>
      </td>
    </tr>
  </table>

<!-- Generated by Doxygen 1.7.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="a00574.html">qpid</a>      </li>
      <li class="navelem"><a class="el" href="a00576.html">client</a>      </li>
      <li class="navelem"><a class="el" href="a00578.html">no_keyword</a>      </li>
      <li class="navelem"><a class="el" href="a00019.html">AsyncSession_0_10</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">qpid::client::no_keyword::AsyncSession_0_10 Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="qpid::client::no_keyword::AsyncSession_0_10" --><!-- doxytag: inherits="qpid::client::SessionBase_0_10" -->
<p>AMQP 0-10 asynchronous session API.  
 <a href="a00019.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00459_source.html">qpid/client/no_keyword/AsyncSession_0_10.h</a>&gt;</code></p>

<p><a href="a00703.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a743b9e85a4c0f0801030eb2f9d7dd396">AsyncSession_0_10</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QPID_CLIENT_INLINE_EXTERN&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a91021d33886f0b3c3efb21a7bc4a23b9">AsyncSession_0_10</a> (const <a class="el" href="a00328.html">SessionBase_0_10</a> &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QPID_CLIENT_INLINE_EXTERN <br class="typebreak"/>
<a class="el" href="a00019.html">AsyncSession_0_10</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a5ae453e369fa2f4e8904e7088fad6931">operator=</a> (const <a class="el" href="a00328.html">SessionBase_0_10</a> &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00054.html">Completion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a0fe280bdbf655e1c4dd4cb350415fa69">executionSync</a> (bool sync=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This command is complete when all prior commands are completed.  <a href="#a0fe280bdbf655e1c4dd4cb350415fa69"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00054.html">Completion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a050559a19abe029d0e97ab42d54cde90">executionResult</a> (const SequenceNumber &amp;commandId=SequenceNumber(), const <a class="el" href="a00345.html">std::string</a> &amp;value=<a class="el" href="a00345.html">std::string</a>(), bool sync=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This command carries data resulting from the execution of a command.  <a href="#a050559a19abe029d0e97ab42d54cde90"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00054.html">Completion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#aa20922961c2e4dc247e96aea9eb3d3ce">executionException</a> (<a class="el" href="a00556.html#a273cf69d639a59973b6019625df33e30">uint16_t</a> errorCode=0, const SequenceNumber &amp;commandId=SequenceNumber(), <a class="el" href="a00556.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> classCode=0, <a class="el" href="a00556.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> commandCode=0, <a class="el" href="a00556.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> fieldIndex=0, const <a class="el" href="a00345.html">std::string</a> &amp;description=<a class="el" href="a00345.html">std::string</a>(), const FieldTable &amp;errorInfo=FieldTable(), bool sync=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This command informs a peer of an execution exception.  <a href="#aa20922961c2e4dc247e96aea9eb3d3ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00054.html">Completion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a745689ddd87824f8e4e60b94402ac08d">messageTransfer</a> (const <a class="el" href="a00345.html">std::string</a> &amp;destination=<a class="el" href="a00345.html">std::string</a>(), <a class="el" href="a00556.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> acceptMode=1, <a class="el" href="a00556.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> acquireMode=0, const <a class="el" href="a00206.html">Message</a> &amp;content=<a class="el" href="a00206.html">Message</a>(<a class="el" href="a00345.html">std::string</a>()), bool sync=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This command transfers a message between two peers.  <a href="#a745689ddd87824f8e4e60b94402ac08d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00054.html">Completion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#ad821639cdce49f66cd30112ec5791742">messageAccept</a> (const SequenceSet &amp;transfers=SequenceSet(), bool sync=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accepts the message.  <a href="#ad821639cdce49f66cd30112ec5791742"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00054.html">Completion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a60b5beb353f7e64a82acd269493a8b56">messageReject</a> (const SequenceSet &amp;transfers=SequenceSet(), <a class="el" href="a00556.html#a273cf69d639a59973b6019625df33e30">uint16_t</a> code=0, const <a class="el" href="a00345.html">std::string</a> &amp;text=<a class="el" href="a00345.html">std::string</a>(), bool sync=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates that the message transfers are unprocessable in some way.  <a href="#a60b5beb353f7e64a82acd269493a8b56"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00054.html">Completion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a44104ba860b5bb0ac211f9d977c86a68">messageRelease</a> (const SequenceSet &amp;transfers=SequenceSet(), bool setRedelivered=false, bool sync=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Release previously transferred messages.  <a href="#a44104ba860b5bb0ac211f9d977c86a68"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00362.html">TypedResult</a><br class="typebreak"/>
&lt; <a class="el" href="a00208.html">qpid::framing::MessageAcquireResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a6ab77ab430ef121a86aa0c6bf3d3d482">messageAcquire</a> (const SequenceSet &amp;transfers=SequenceSet(), bool sync=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires previously transferred messages for consumption.  <a href="#a6ab77ab430ef121a86aa0c6bf3d3d482"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00362.html">TypedResult</a><br class="typebreak"/>
&lt; <a class="el" href="a00212.html">qpid::framing::MessageResumeResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a123c5719b317341ecdb3de6d60207303">messageResume</a> (const <a class="el" href="a00345.html">std::string</a> &amp;destination=<a class="el" href="a00345.html">std::string</a>(), const <a class="el" href="a00345.html">std::string</a> &amp;resumeId=<a class="el" href="a00345.html">std::string</a>(), bool sync=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This command resumes an interrupted transfer.  <a href="#a123c5719b317341ecdb3de6d60207303"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00054.html">Completion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a0c5e77d5360857699d93284478b1782d">messageSubscribe</a> (const <a class="el" href="a00345.html">std::string</a> &amp;queue=<a class="el" href="a00345.html">std::string</a>(), const <a class="el" href="a00345.html">std::string</a> &amp;destination=<a class="el" href="a00345.html">std::string</a>(), <a class="el" href="a00556.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> acceptMode=0, <a class="el" href="a00556.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> acquireMode=0, bool exclusive=false, const <a class="el" href="a00345.html">std::string</a> &amp;resumeId=<a class="el" href="a00345.html">std::string</a>(), uint64_t resumeTtl=0, const FieldTable &amp;arguments=FieldTable(), bool sync=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This command asks the server to start a "subscription", which is a request for messages from a specific queue.  <a href="#a0c5e77d5360857699d93284478b1782d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00054.html">Completion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a6515de4bd5583caf79678fece1ac4324">messageCancel</a> (const <a class="el" href="a00345.html">std::string</a> &amp;destination=<a class="el" href="a00345.html">std::string</a>(), bool sync=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This command cancels a subscription.  <a href="#a6515de4bd5583caf79678fece1ac4324"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00054.html">Completion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#ac30416dd3467e79a2e0e9966139da3c8">messageSetFlowMode</a> (const <a class="el" href="a00345.html">std::string</a> &amp;destination=<a class="el" href="a00345.html">std::string</a>(), <a class="el" href="a00556.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> flowMode=0, bool sync=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the mode of flow control used for a given destination to either window or credit based flow control.  <a href="#ac30416dd3467e79a2e0e9966139da3c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00054.html">Completion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#ad1c3d9b0cdcd251924e7b9250014514b">messageFlow</a> (const <a class="el" href="a00345.html">std::string</a> &amp;destination=<a class="el" href="a00345.html">std::string</a>(), <a class="el" href="a00556.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> unit=0, <a class="el" href="a00556.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> value=0, bool sync=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This command controls the flow of message data to a given destination.  <a href="#ad1c3d9b0cdcd251924e7b9250014514b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00054.html">Completion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a71fc25ddb2ea172db942dcd04745f9c5">messageFlush</a> (const <a class="el" href="a00345.html">std::string</a> &amp;destination=<a class="el" href="a00345.html">std::string</a>(), bool sync=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the sender to exhaust his credit supply.  <a href="#a71fc25ddb2ea172db942dcd04745f9c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00054.html">Completion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#af1946069aa7c0d8a01cb5ddedfa116d2">messageStop</a> (const <a class="el" href="a00345.html">std::string</a> &amp;destination=<a class="el" href="a00345.html">std::string</a>(), bool sync=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">On receipt of this command, a producer of messages MUST set his credit to zero for the given destination.  <a href="#af1946069aa7c0d8a01cb5ddedfa116d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00054.html">Completion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a5dbd9d674e51bf67d4bd97a033fad1f7">txSelect</a> (bool sync=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This command sets the session to use standard transactions.  <a href="#a5dbd9d674e51bf67d4bd97a033fad1f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00054.html">Completion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a62be3d27b93a47294dc8772b79aed768">txCommit</a> (bool sync=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This command commits all messages published and accepted in the current transaction.  <a href="#a62be3d27b93a47294dc8772b79aed768"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00054.html">Completion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a6fc047d1410d33cd1ba45cdc269dc62c">txRollback</a> (bool sync=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This command abandons the current transaction.  <a href="#a6fc047d1410d33cd1ba45cdc269dc62c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00054.html">Completion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#af3e6e8138defac20d7a18d7253356dcb">dtxSelect</a> (bool sync=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This command sets the session to use distributed transactions.  <a href="#af3e6e8138defac20d7a18d7253356dcb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00362.html">TypedResult</a><br class="typebreak"/>
&lt; <a class="el" href="a00400.html">qpid::framing::XaResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a3e1156081acce701155add4f7a19423b">dtxStart</a> (const Xid &amp;xid=Xid(), bool join=false, bool resume=false, bool sync=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This command is called when messages should be produced and consumed on behalf a transaction branch identified by xid.  <a href="#a3e1156081acce701155add4f7a19423b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00362.html">TypedResult</a><br class="typebreak"/>
&lt; <a class="el" href="a00400.html">qpid::framing::XaResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a1785642b58f23fbe693cf1f8aa3801cc">dtxEnd</a> (const Xid &amp;xid=Xid(), bool fail=false, bool suspend=false, bool sync=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This command is called when the work done on behalf a transaction branch finishes or needs to be suspended.  <a href="#a1785642b58f23fbe693cf1f8aa3801cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00362.html">TypedResult</a><br class="typebreak"/>
&lt; <a class="el" href="a00400.html">qpid::framing::XaResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#ac0dd0cbb49562d21cb5fcee1d2e14a50">dtxCommit</a> (const Xid &amp;xid=Xid(), bool onePhase=false, bool sync=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Commit the work done on behalf a transaction branch.  <a href="#ac0dd0cbb49562d21cb5fcee1d2e14a50"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00054.html">Completion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a23f18b5323726697a8be9ebaa03be6d6">dtxForget</a> (const Xid &amp;xid=Xid(), bool sync=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This command is called to forget about a heuristically completed transaction branch.  <a href="#a23f18b5323726697a8be9ebaa03be6d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00362.html">TypedResult</a><br class="typebreak"/>
&lt; <a class="el" href="a00101.html">qpid::framing::DtxGetTimeoutResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a711fff1c2c2a8d5a00e869af4c969445">dtxGetTimeout</a> (const Xid &amp;xid=Xid(), bool sync=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This command obtains the current transaction timeout value in seconds.  <a href="#a711fff1c2c2a8d5a00e869af4c969445"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00362.html">TypedResult</a><br class="typebreak"/>
&lt; <a class="el" href="a00400.html">qpid::framing::XaResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#affddc2820d58ad0715b578001610ed00">dtxPrepare</a> (const Xid &amp;xid=Xid(), bool sync=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This command prepares for commitment any message produced or consumed on behalf of xid.  <a href="#affddc2820d58ad0715b578001610ed00"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00362.html">TypedResult</a><br class="typebreak"/>
&lt; <a class="el" href="a00102.html">qpid::framing::DtxRecoverResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a3dd1a15490e342a38eb226991f6097ee">dtxRecover</a> (bool sync=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This command is called to obtain a list of transaction branches that are in a prepared or heuristically completed state.  <a href="#a3dd1a15490e342a38eb226991f6097ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00362.html">TypedResult</a><br class="typebreak"/>
&lt; <a class="el" href="a00400.html">qpid::framing::XaResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a9eebff183e48d225673f677df5b07606">dtxRollback</a> (const Xid &amp;xid=Xid(), bool sync=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This command rolls back the work associated with xid.  <a href="#a9eebff183e48d225673f677df5b07606"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00054.html">Completion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a1f7c049e0de88d83052555ba9c5d95e9">dtxSetTimeout</a> (const Xid &amp;xid=Xid(), <a class="el" href="a00556.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> timeout=0, bool sync=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the specified transaction branch timeout value in seconds.  <a href="#a1f7c049e0de88d83052555ba9c5d95e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00054.html">Completion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a23cc4d14b9bfa7883c6f48070071b9e9">exchangeDeclare</a> (const <a class="el" href="a00345.html">std::string</a> &amp;exchange=<a class="el" href="a00345.html">std::string</a>(), const <a class="el" href="a00345.html">std::string</a> &amp;type=<a class="el" href="a00345.html">std::string</a>(), const <a class="el" href="a00345.html">std::string</a> &amp;alternateExchange=<a class="el" href="a00345.html">std::string</a>(), bool passive=false, bool durable=false, bool autoDelete=false, const FieldTable &amp;arguments=FieldTable(), bool sync=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This command creates an exchange if it does not already exist, and if the exchange exists, verifies that it is of the correct and expected class.  <a href="#a23cc4d14b9bfa7883c6f48070071b9e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00054.html">Completion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a5609565b171ce9346d51349c786a54de">exchangeDelete</a> (const <a class="el" href="a00345.html">std::string</a> &amp;exchange=<a class="el" href="a00345.html">std::string</a>(), bool ifUnused=false, bool sync=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This command deletes an exchange.  <a href="#a5609565b171ce9346d51349c786a54de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00362.html">TypedResult</a><br class="typebreak"/>
&lt; <a class="el" href="a00117.html">qpid::framing::ExchangeQueryResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a993fadf3963c9ac0914b9f3cc66d8526">exchangeQuery</a> (const <a class="el" href="a00345.html">std::string</a> &amp;name=<a class="el" href="a00345.html">std::string</a>(), bool sync=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This command is used to request information on a particular exchange.  <a href="#a993fadf3963c9ac0914b9f3cc66d8526"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00054.html">Completion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a040a07cf41f24d45bf4edfcd66152111">exchangeBind</a> (const <a class="el" href="a00345.html">std::string</a> &amp;queue=<a class="el" href="a00345.html">std::string</a>(), const <a class="el" href="a00345.html">std::string</a> &amp;exchange=<a class="el" href="a00345.html">std::string</a>(), const <a class="el" href="a00345.html">std::string</a> &amp;bindingKey=<a class="el" href="a00345.html">std::string</a>(), const FieldTable &amp;arguments=FieldTable(), bool sync=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This command binds a queue to an exchange.  <a href="#a040a07cf41f24d45bf4edfcd66152111"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00054.html">Completion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#affaadc91247cfd5724842dcf22979cd6">exchangeUnbind</a> (const <a class="el" href="a00345.html">std::string</a> &amp;queue=<a class="el" href="a00345.html">std::string</a>(), const <a class="el" href="a00345.html">std::string</a> &amp;exchange=<a class="el" href="a00345.html">std::string</a>(), const <a class="el" href="a00345.html">std::string</a> &amp;bindingKey=<a class="el" href="a00345.html">std::string</a>(), bool sync=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This command unbinds a queue from an exchange.  <a href="#affaadc91247cfd5724842dcf22979cd6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00362.html">TypedResult</a><br class="typebreak"/>
&lt; <a class="el" href="a00116.html">qpid::framing::ExchangeBoundResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a26e748b13126817eed77e609bdf6d7c2">exchangeBound</a> (const <a class="el" href="a00345.html">std::string</a> &amp;exchange=<a class="el" href="a00345.html">std::string</a>(), const <a class="el" href="a00345.html">std::string</a> &amp;queue=<a class="el" href="a00345.html">std::string</a>(), const <a class="el" href="a00345.html">std::string</a> &amp;bindingKey=<a class="el" href="a00345.html">std::string</a>(), const FieldTable &amp;arguments=FieldTable(), bool sync=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This command is used to request information on the bindings to a particular exchange.  <a href="#a26e748b13126817eed77e609bdf6d7c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00054.html">Completion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a0566092a09b8912dac10fa2b52ec815d">queueDeclare</a> (const <a class="el" href="a00345.html">std::string</a> &amp;queue=<a class="el" href="a00345.html">std::string</a>(), const <a class="el" href="a00345.html">std::string</a> &amp;alternateExchange=<a class="el" href="a00345.html">std::string</a>(), bool passive=false, bool durable=false, bool exclusive=false, bool autoDelete=false, const FieldTable &amp;arguments=FieldTable(), bool sync=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This command creates or checks a queue.  <a href="#a0566092a09b8912dac10fa2b52ec815d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00054.html">Completion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a1e266f5ad9b7af100b2322d7ded4a393">queueDelete</a> (const <a class="el" href="a00345.html">std::string</a> &amp;queue=<a class="el" href="a00345.html">std::string</a>(), bool ifUnused=false, bool ifEmpty=false, bool sync=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This command deletes a queue.  <a href="#a1e266f5ad9b7af100b2322d7ded4a393"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00054.html">Completion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#ac69995a96be1205ab7617c7bc80c12c9">queuePurge</a> (const <a class="el" href="a00345.html">std::string</a> &amp;queue=<a class="el" href="a00345.html">std::string</a>(), bool sync=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This command removes all messages from a queue.  <a href="#ac69995a96be1205ab7617c7bc80c12c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00362.html">TypedResult</a><br class="typebreak"/>
&lt; <a class="el" href="a00265.html">qpid::framing::QueueQueryResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html#a72a55bbf31b38d4a57169e460bb45f32">queueQuery</a> (const <a class="el" href="a00345.html">std::string</a> &amp;queue=<a class="el" href="a00345.html">std::string</a>(), bool sync=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This command requests information about a queue.  <a href="#a72a55bbf31b38d4a57169e460bb45f32"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00333.html">SessionId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00328.html#aba4c611d0f2008bf153b5a0d372d7b32">getId</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the session ID.  <a href="#aba4c611d0f2008bf153b5a0d372d7b32"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00328.html#aa3db8a210e8bdb4d9c04f048a3bc16af">close</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the session.  <a href="#aa3db8a210e8bdb4d9c04f048a3bc16af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00328.html#a198880ec0840c18b0d8a9140d38db699">sync</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronize the session: <a class="el" href="a00328.html#a198880ec0840c18b0d8a9140d38db699" title="Synchronize the session: sync() waits until all commands issued on this session so far have been comp...">sync()</a> waits until all commands issued on this session so far have been completed by the broker.  <a href="#a198880ec0840c18b0d8a9140d38db699"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00556.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00328.html#a90f4dc4899c23d4cfb00360a5f215b26">timeout</a> (<a class="el" href="a00556.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> seconds)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the timeout for this session.  <a href="#a90f4dc4899c23d4cfb00360a5f215b26"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00328.html#a7767cc2b33cdba119824b86ca212dbd6">suspend</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspend the session - detach it from its connection.  <a href="#a7767cc2b33cdba119824b86ca212dbd6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00328.html#a7b6f55034313f9a4ca2d2ae71649b840">resume</a> (<a class="el" href="a00058.html">Connection</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume a suspended session with a new connection.  <a href="#a7b6f55034313f9a4ca2d2ae71649b840"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00556.html#a273cf69d639a59973b6019625df33e30">uint16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00328.html#a2395fbbedb1705bfefc45a70a9b80b6f">getChannel</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the channel associated with this session.  <a href="#a2395fbbedb1705bfefc45a70a9b80b6f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00328.html#aad3b41e7fb8e6d40c309a9b0c7144243">flush</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00328.html#a71b6f8e5c01c5ab1d8dba353f0c2dc6e">markCompleted</a> (const <a class="el" href="a00324.html">framing::SequenceSet</a> &amp;ids, bool notifyPeer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00328.html#ab9d172be089286ffc7b4fda418b87301">markCompleted</a> (const <a class="el" href="a00323.html">framing::SequenceNumber</a> &amp;id, bool cumulative, bool notifyPeer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00328.html#a151e42932f03d3a453bb1598e160a025">sendCompletion</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00328.html#ae4424751cfa94ad272711dae9213cb2c">isValid</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00058.html">Connection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00328.html#ad90f254bc31ff8e5933c4dd14f3a48b5">getConnection</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; SessionImpl &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00328.html#a72d171e291fab3cd457bf04276970904">impl</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>AMQP 0-10 asynchronous session API. </p>
<p>A session is a named interaction between two peers. Session names are chosen by the upper layers and may be used indefinitely. The model layer may associate long-lived or durable state with a given session name. The session layer provides transport of commands associated with this interaction. </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a743b9e85a4c0f0801030eb2f9d7dd396"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::AsyncSession_0_10" ref="a743b9e85a4c0f0801030eb2f9d7dd396" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">qpid::client::no_keyword::AsyncSession_0_10::AsyncSession_0_10 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="a00020.html#aceda8efdadd334c003ecb29c907a4fcf">qpid::client::AsyncSession_0_10</a>.</p>

</div>
</div>
<a class="anchor" id="a91021d33886f0b3c3efb21a7bc4a23b9"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::AsyncSession_0_10" ref="a91021d33886f0b3c3efb21a7bc4a23b9" args="(const SessionBase_0_10 &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QPID_CLIENT_INLINE_EXTERN qpid::client::no_keyword::AsyncSession_0_10::AsyncSession_0_10 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00328.html">SessionBase_0_10</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="a00020.html#a8111365db7bade27159e67f382d16e0f">qpid::client::AsyncSession_0_10</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aa3db8a210e8bdb4d9c04f048a3bc16af"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::close" ref="aa3db8a210e8bdb4d9c04f048a3bc16af" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qpid::client::SessionBase_0_10::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Close the session. </p>
<p>A session is automatically closed when all handles to it are destroyed. </p>

</div>
</div>
<a class="anchor" id="ac0dd0cbb49562d21cb5fcee1d2e14a50"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::dtxCommit" ref="ac0dd0cbb49562d21cb5fcee1d2e14a50" args="(const Xid &amp;xid=Xid(), bool onePhase=false, bool sync=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00362.html">TypedResult</a>&lt;<a class="el" href="a00400.html">qpid::framing::XaResult</a>&gt; qpid::client::no_keyword::AsyncSession_0_10::dtxCommit </td>
          <td>(</td>
          <td class="paramtype">const Xid &amp;&#160;</td>
          <td class="paramname"><em>xid</em> = <code>Xid()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onePhase</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Commit the work done on behalf a transaction branch. </p>
<p>This command commits the work associated with xid. Any produced messages are made available and any consumed messages are discarded.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">xid</td><td>Specifies the xid of the transaction branch to be committed.</td></tr>
    <tr><td class="paramname">onePhase</td><td>Used to indicate whether one-phase or two-phase commit is used.</td></tr>
    <tr><td class="paramname">sync</td><td>If true the broker will respond with completion status as soon as possible. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="a00458_source.html#l00425">qpid::client::AsyncSession_0_10::BOOST_PARAMETER_MEMFUN()</a>.</p>

</div>
</div>
<a class="anchor" id="a1785642b58f23fbe693cf1f8aa3801cc"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::dtxEnd" ref="a1785642b58f23fbe693cf1f8aa3801cc" args="(const Xid &amp;xid=Xid(), bool fail=false, bool suspend=false, bool sync=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00362.html">TypedResult</a>&lt;<a class="el" href="a00400.html">qpid::framing::XaResult</a>&gt; qpid::client::no_keyword::AsyncSession_0_10::dtxEnd </td>
          <td>(</td>
          <td class="paramtype">const Xid &amp;&#160;</td>
          <td class="paramname"><em>xid</em> = <code>Xid()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fail</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>suspend</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This command is called when the work done on behalf a transaction branch finishes or needs to be suspended. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">xid</td><td>Specifies the xid of the transaction branch to be ended.</td></tr>
    <tr><td class="paramname">fail</td><td>If set, indicates that this portion of work has failed; otherwise this portion of work has completed successfully.</td></tr>
    <tr><td class="paramname">suspend</td><td>Indicates that the transaction branch is temporarily suspended in an incomplete state.</td></tr>
    <tr><td class="paramname">sync</td><td>If true the broker will respond with completion status as soon as possible. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="a00458_source.html#l00417">qpid::client::AsyncSession_0_10::BOOST_PARAMETER_MEMFUN()</a>.</p>

</div>
</div>
<a class="anchor" id="a23f18b5323726697a8be9ebaa03be6d6"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::dtxForget" ref="a23f18b5323726697a8be9ebaa03be6d6" args="(const Xid &amp;xid=Xid(), bool sync=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00054.html">Completion</a> qpid::client::no_keyword::AsyncSession_0_10::dtxForget </td>
          <td>(</td>
          <td class="paramtype">const Xid &amp;&#160;</td>
          <td class="paramname"><em>xid</em> = <code>Xid()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This command is called to forget about a heuristically completed transaction branch. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">xid</td><td>Specifies the xid of the transaction branch to be forgotten.</td></tr>
    <tr><td class="paramname">sync</td><td>If true the broker will respond with completion status as soon as possible. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="a00458_source.html#l00432">qpid::client::AsyncSession_0_10::BOOST_PARAMETER_MEMFUN()</a>.</p>

</div>
</div>
<a class="anchor" id="a711fff1c2c2a8d5a00e869af4c969445"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::dtxGetTimeout" ref="a711fff1c2c2a8d5a00e869af4c969445" args="(const Xid &amp;xid=Xid(), bool sync=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00362.html">TypedResult</a>&lt;<a class="el" href="a00101.html">qpid::framing::DtxGetTimeoutResult</a>&gt; qpid::client::no_keyword::AsyncSession_0_10::dtxGetTimeout </td>
          <td>(</td>
          <td class="paramtype">const Xid &amp;&#160;</td>
          <td class="paramname"><em>xid</em> = <code>Xid()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This command obtains the current transaction timeout value in seconds. </p>
<p>If set-timeout was not used prior to invoking this command, the return value is the default timeout; otherwise, the value used in the previous set-timeout call is returned.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">xid</td><td>Specifies the xid of the transaction branch for getting the timeout.</td></tr>
    <tr><td class="paramname">sync</td><td>If true the broker will respond with completion status as soon as possible. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="a00458_source.html#l00438">qpid::client::AsyncSession_0_10::BOOST_PARAMETER_MEMFUN()</a>.</p>

</div>
</div>
<a class="anchor" id="affddc2820d58ad0715b578001610ed00"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::dtxPrepare" ref="affddc2820d58ad0715b578001610ed00" args="(const Xid &amp;xid=Xid(), bool sync=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00362.html">TypedResult</a>&lt;<a class="el" href="a00400.html">qpid::framing::XaResult</a>&gt; qpid::client::no_keyword::AsyncSession_0_10::dtxPrepare </td>
          <td>(</td>
          <td class="paramtype">const Xid &amp;&#160;</td>
          <td class="paramname"><em>xid</em> = <code>Xid()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This command prepares for commitment any message produced or consumed on behalf of xid. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">xid</td><td>Specifies the xid of the transaction branch that can be prepared.</td></tr>
    <tr><td class="paramname">sync</td><td>If true the broker will respond with completion status as soon as possible. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="a00458_source.html#l00444">qpid::client::AsyncSession_0_10::BOOST_PARAMETER_MEMFUN()</a>.</p>

</div>
</div>
<a class="anchor" id="a3dd1a15490e342a38eb226991f6097ee"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::dtxRecover" ref="a3dd1a15490e342a38eb226991f6097ee" args="(bool sync=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00362.html">TypedResult</a>&lt;<a class="el" href="a00102.html">qpid::framing::DtxRecoverResult</a>&gt; qpid::client::no_keyword::AsyncSession_0_10::dtxRecover </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This command is called to obtain a list of transaction branches that are in a prepared or heuristically completed state. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sync</td><td>If true the broker will respond with completion status as soon as possible. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="a00458_source.html#l00450">qpid::client::AsyncSession_0_10::BOOST_PARAMETER_MEMFUN()</a>.</p>

</div>
</div>
<a class="anchor" id="a9eebff183e48d225673f677df5b07606"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::dtxRollback" ref="a9eebff183e48d225673f677df5b07606" args="(const Xid &amp;xid=Xid(), bool sync=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00362.html">TypedResult</a>&lt;<a class="el" href="a00400.html">qpid::framing::XaResult</a>&gt; qpid::client::no_keyword::AsyncSession_0_10::dtxRollback </td>
          <td>(</td>
          <td class="paramtype">const Xid &amp;&#160;</td>
          <td class="paramname"><em>xid</em> = <code>Xid()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This command rolls back the work associated with xid. </p>
<p>Any produced messages are discarded and any consumed messages are re-enqueued.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">xid</td><td>Specifies the xid of the transaction branch that can be rolled back.</td></tr>
    <tr><td class="paramname">sync</td><td>If true the broker will respond with completion status as soon as possible. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="a00458_source.html#l00455">qpid::client::AsyncSession_0_10::BOOST_PARAMETER_MEMFUN()</a>.</p>

</div>
</div>
<a class="anchor" id="af3e6e8138defac20d7a18d7253356dcb"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::dtxSelect" ref="af3e6e8138defac20d7a18d7253356dcb" args="(bool sync=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00054.html">Completion</a> qpid::client::no_keyword::AsyncSession_0_10::dtxSelect </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This command sets the session to use distributed transactions. </p>
<p>The client must use this command at least once on a session before using XA demarcation operations.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sync</td><td>If true the broker will respond with completion status as soon as possible. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="a00458_source.html#l00404">qpid::client::AsyncSession_0_10::BOOST_PARAMETER_MEMFUN()</a>.</p>

</div>
</div>
<a class="anchor" id="a1f7c049e0de88d83052555ba9c5d95e9"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::dtxSetTimeout" ref="a1f7c049e0de88d83052555ba9c5d95e9" args="(const Xid &amp;xid=Xid(), uint32_t timeout=0, bool sync=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00054.html">Completion</a> qpid::client::no_keyword::AsyncSession_0_10::dtxSetTimeout </td>
          <td>(</td>
          <td class="paramtype">const Xid &amp;&#160;</td>
          <td class="paramname"><em>xid</em> = <code>Xid()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00556.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the specified transaction branch timeout value in seconds. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">xid</td><td>Specifies the xid of the transaction branch for setting the timeout.</td></tr>
    <tr><td class="paramname">timeout</td><td>The transaction timeout value in seconds.</td></tr>
    <tr><td class="paramname">sync</td><td>If true the broker will respond with completion status as soon as possible. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="a00458_source.html#l00461">qpid::client::AsyncSession_0_10::BOOST_PARAMETER_MEMFUN()</a>.</p>

</div>
</div>
<a class="anchor" id="a3e1156081acce701155add4f7a19423b"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::dtxStart" ref="a3e1156081acce701155add4f7a19423b" args="(const Xid &amp;xid=Xid(), bool join=false, bool resume=false, bool sync=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00362.html">TypedResult</a>&lt;<a class="el" href="a00400.html">qpid::framing::XaResult</a>&gt; qpid::client::no_keyword::AsyncSession_0_10::dtxStart </td>
          <td>(</td>
          <td class="paramtype">const Xid &amp;&#160;</td>
          <td class="paramname"><em>xid</em> = <code>Xid()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>join</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>resume</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This command is called when messages should be produced and consumed on behalf a transaction branch identified by xid. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">xid</td><td>Specifies the xid of the transaction branch to be started.</td></tr>
    <tr><td class="paramname">join</td><td>Indicate whether this is joining an already associated xid. Indicate that the start applies to joining a transaction previously seen.</td></tr>
    <tr><td class="paramname">resume</td><td>Indicate that the start applies to resuming a suspended transaction branch specified.</td></tr>
    <tr><td class="paramname">sync</td><td>If true the broker will respond with completion status as soon as possible. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="a00458_source.html#l00409">qpid::client::AsyncSession_0_10::BOOST_PARAMETER_MEMFUN()</a>.</p>

</div>
</div>
<a class="anchor" id="a040a07cf41f24d45bf4edfcd66152111"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::exchangeBind" ref="a040a07cf41f24d45bf4edfcd66152111" args="(const std::string &amp;queue=std::string(), const std::string &amp;exchange=std::string(), const std::string &amp;bindingKey=std::string(), const FieldTable &amp;arguments=FieldTable(), bool sync=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00054.html">Completion</a> qpid::client::no_keyword::AsyncSession_0_10::exchangeBind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00345.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>queue</em> = <code><a class="el" href="a00345.html">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00345.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>exchange</em> = <code><a class="el" href="a00345.html">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00345.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>bindingKey</em> = <code><a class="el" href="a00345.html">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FieldTable &amp;&#160;</td>
          <td class="paramname"><em>arguments</em> = <code>FieldTable()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This command binds a queue to an exchange. </p>
<p>Until a queue is bound it will not receive any messages. In a classic messaging model, store-and-forward queues are bound to a direct exchange and subscription queues are bound to a topic exchange.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Specifies the name of the queue to bind.</td></tr>
    <tr><td class="paramname">exchange</td><td></td></tr>
    <tr><td class="paramname">bindingKey</td><td>The binding-key uniquely identifies a binding between a given (exchange, queue) pair. Depending on the exchange configuration, the binding key may be matched against the message routing key in order to make routing decisions. The match algorithm depends on the exchange type. Some exchange types may ignore the binding key when making routing decisions. Refer to the specific exchange type documentation. The meaning of an empty binding key depends on the exchange implementation.</td></tr>
    <tr><td class="paramname">arguments</td><td>A set of arguments for the binding. The syntax and semantics of these arguments depends on the exchange class.</td></tr>
    <tr><td class="paramname">sync</td><td>If true the broker will respond with completion status as soon as possible. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="a00458_source.html#l00493">qpid::client::AsyncSession_0_10::BOOST_PARAMETER_MEMFUN()</a>.</p>

</div>
</div>
<a class="anchor" id="a26e748b13126817eed77e609bdf6d7c2"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::exchangeBound" ref="a26e748b13126817eed77e609bdf6d7c2" args="(const std::string &amp;exchange=std::string(), const std::string &amp;queue=std::string(), const std::string &amp;bindingKey=std::string(), const FieldTable &amp;arguments=FieldTable(), bool sync=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00362.html">TypedResult</a>&lt;<a class="el" href="a00116.html">qpid::framing::ExchangeBoundResult</a>&gt; qpid::client::no_keyword::AsyncSession_0_10::exchangeBound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00345.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>exchange</em> = <code><a class="el" href="a00345.html">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00345.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>queue</em> = <code><a class="el" href="a00345.html">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00345.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>bindingKey</em> = <code><a class="el" href="a00345.html">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FieldTable &amp;&#160;</td>
          <td class="paramname"><em>arguments</em> = <code>FieldTable()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This command is used to request information on the bindings to a particular exchange. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">exchange</td><td>The name of the exchange for which binding information is being requested. If not specified explicitly the default exchange is implied.</td></tr>
    <tr><td class="paramname">queue</td><td>If populated then determine whether the given queue is bound to the exchange.</td></tr>
    <tr><td class="paramname">bindingKey</td><td>If populated defines the binding-key of the binding of interest, if not populated the request will ignore the binding-key on bindings when searching for a match.</td></tr>
    <tr><td class="paramname">arguments</td><td>If populated defines the arguments of the binding of interest if not populated the request will ignore the arguments on bindings when searching for a match</td></tr>
    <tr><td class="paramname">sync</td><td>If true the broker will respond with completion status as soon as possible. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="a00458_source.html#l00510">qpid::client::AsyncSession_0_10::BOOST_PARAMETER_MEMFUN()</a>.</p>

</div>
</div>
<a class="anchor" id="a23cc4d14b9bfa7883c6f48070071b9e9"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::exchangeDeclare" ref="a23cc4d14b9bfa7883c6f48070071b9e9" args="(const std::string &amp;exchange=std::string(), const std::string &amp;type=std::string(), const std::string &amp;alternateExchange=std::string(), bool passive=false, bool durable=false, bool autoDelete=false, const FieldTable &amp;arguments=FieldTable(), bool sync=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00054.html">Completion</a> qpid::client::no_keyword::AsyncSession_0_10::exchangeDeclare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00345.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>exchange</em> = <code><a class="el" href="a00345.html">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00345.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="a00345.html">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00345.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>alternateExchange</em> = <code><a class="el" href="a00345.html">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>passive</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>durable</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoDelete</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FieldTable &amp;&#160;</td>
          <td class="paramname"><em>arguments</em> = <code>FieldTable()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This command creates an exchange if it does not already exist, and if the exchange exists, verifies that it is of the correct and expected class. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">exchange</td><td></td></tr>
    <tr><td class="paramname">type</td><td>Each exchange belongs to one of a set of exchange types implemented by the server. The exchange types define the functionality of the exchange - i.e. how messages are routed through it. It is not valid or meaningful to attempt to change the type of an existing exchange.</td></tr>
    <tr><td class="paramname">alternateExchange</td><td>In the event that a message cannot be routed, this is the name of the exchange to which the message will be sent. Messages transferred using message.transfer will be routed to the alternate-exchange only if they are sent with the "none" accept-mode, and the discard-unroutable delivery property is set to false, and there is no queue to route to for the given message according to the bindings on this exchange.</td></tr>
    <tr><td class="paramname">passive</td><td>If set, the server will not create the exchange. The client can use this to check whether an exchange exists without modifying the server state.</td></tr>
    <tr><td class="paramname">durable</td><td>If set when creating a new exchange, the exchange will be marked as durable. Durable exchanges remain active when a server restarts. Non-durable exchanges (transient exchanges) are purged if/when a server restarts.</td></tr>
    <tr><td class="paramname">autoDelete</td><td>If set, the exchange is deleted automatically when there remain no bindings between the exchange and any queue. Such an exchange will not be automatically deleted until at least one binding has been made to prevent the immediate deletion of the exchange upon creation.</td></tr>
    <tr><td class="paramname">arguments</td><td>A set of arguments for the declaration. The syntax and semantics of these arguments depends on the server implementation. This field is ignored if passive is 1.</td></tr>
    <tr><td class="paramname">sync</td><td>If true the broker will respond with completion status as soon as possible. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="a00458_source.html#l00468">qpid::client::AsyncSession_0_10::BOOST_PARAMETER_MEMFUN()</a>.</p>

</div>
</div>
<a class="anchor" id="a5609565b171ce9346d51349c786a54de"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::exchangeDelete" ref="a5609565b171ce9346d51349c786a54de" args="(const std::string &amp;exchange=std::string(), bool ifUnused=false, bool sync=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00054.html">Completion</a> qpid::client::no_keyword::AsyncSession_0_10::exchangeDelete </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00345.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>exchange</em> = <code><a class="el" href="a00345.html">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ifUnused</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This command deletes an exchange. </p>
<p>When an exchange is deleted all queue bindings on the exchange are cancelled.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">exchange</td><td></td></tr>
    <tr><td class="paramname">ifUnused</td><td>If set, the server will only delete the exchange if it has no queue bindings. If the exchange has queue bindings the server does not delete it but raises an exception instead.</td></tr>
    <tr><td class="paramname">sync</td><td>If true the broker will respond with completion status as soon as possible. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="a00458_source.html#l00480">qpid::client::AsyncSession_0_10::BOOST_PARAMETER_MEMFUN()</a>.</p>

</div>
</div>
<a class="anchor" id="a993fadf3963c9ac0914b9f3cc66d8526"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::exchangeQuery" ref="a993fadf3963c9ac0914b9f3cc66d8526" args="(const std::string &amp;name=std::string(), bool sync=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00362.html">TypedResult</a>&lt;<a class="el" href="a00117.html">qpid::framing::ExchangeQueryResult</a>&gt; qpid::client::no_keyword::AsyncSession_0_10::exchangeQuery </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00345.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code><a class="el" href="a00345.html">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This command is used to request information on a particular exchange. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the exchange for which information is requested. If not specified explicitly the default exchange is implied.</td></tr>
    <tr><td class="paramname">sync</td><td>If true the broker will respond with completion status as soon as possible. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="a00458_source.html#l00487">qpid::client::AsyncSession_0_10::BOOST_PARAMETER_MEMFUN()</a>.</p>

</div>
</div>
<a class="anchor" id="affaadc91247cfd5724842dcf22979cd6"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::exchangeUnbind" ref="affaadc91247cfd5724842dcf22979cd6" args="(const std::string &amp;queue=std::string(), const std::string &amp;exchange=std::string(), const std::string &amp;bindingKey=std::string(), bool sync=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00054.html">Completion</a> qpid::client::no_keyword::AsyncSession_0_10::exchangeUnbind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00345.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>queue</em> = <code><a class="el" href="a00345.html">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00345.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>exchange</em> = <code><a class="el" href="a00345.html">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00345.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>bindingKey</em> = <code><a class="el" href="a00345.html">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This command unbinds a queue from an exchange. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Specifies the name of the queue to unbind.</td></tr>
    <tr><td class="paramname">exchange</td><td>The name of the exchange to unbind from.</td></tr>
    <tr><td class="paramname">bindingKey</td><td>Specifies the binding-key of the binding to unbind.</td></tr>
    <tr><td class="paramname">sync</td><td>If true the broker will respond with completion status as soon as possible. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="a00458_source.html#l00502">qpid::client::AsyncSession_0_10::BOOST_PARAMETER_MEMFUN()</a>.</p>

</div>
</div>
<a class="anchor" id="aa20922961c2e4dc247e96aea9eb3d3ce"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::executionException" ref="aa20922961c2e4dc247e96aea9eb3d3ce" args="(uint16_t errorCode=0, const SequenceNumber &amp;commandId=SequenceNumber(), uint8_t classCode=0, uint8_t commandCode=0, uint8_t fieldIndex=0, const std::string &amp;description=std::string(), const FieldTable &amp;errorInfo=FieldTable(), bool sync=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00054.html">Completion</a> qpid::client::no_keyword::AsyncSession_0_10::executionException </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00556.html#a273cf69d639a59973b6019625df33e30">uint16_t</a>&#160;</td>
          <td class="paramname"><em>errorCode</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SequenceNumber &amp;&#160;</td>
          <td class="paramname"><em>commandId</em> = <code>SequenceNumber()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00556.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a>&#160;</td>
          <td class="paramname"><em>classCode</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00556.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a>&#160;</td>
          <td class="paramname"><em>commandCode</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00556.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a>&#160;</td>
          <td class="paramname"><em>fieldIndex</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00345.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>description</em> = <code><a class="el" href="a00345.html">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FieldTable &amp;&#160;</td>
          <td class="paramname"><em>errorInfo</em> = <code>FieldTable()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This command informs a peer of an execution exception. </p>
<p>The command-id, when given, correlates the error to a specific command.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">errorCode</td><td></td></tr>
    <tr><td class="paramname">commandId</td><td>The command-id of the command which caused the exception. If the exception was not caused by a specific command, this value is not set.</td></tr>
    <tr><td class="paramname">classCode</td><td></td></tr>
    <tr><td class="paramname">commandCode</td><td></td></tr>
    <tr><td class="paramname">fieldIndex</td><td>The zero based index of the exceptional field within the arguments to the exceptional command. If the exception was not caused by a specific field, this value is not set.</td></tr>
    <tr><td class="paramname">description</td><td>The description provided is implementation defined, but MUST be in the language appropriate for the selected locale. The intention is that this description is suitable for logging or alerting output.</td></tr>
    <tr><td class="paramname">errorInfo</td><td></td></tr>
    <tr><td class="paramname">sync</td><td>If true the broker will respond with completion status as soon as possible. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="a00458_source.html#l00288">qpid::client::AsyncSession_0_10::BOOST_PARAMETER_MEMFUN()</a>.</p>

</div>
</div>
<a class="anchor" id="a050559a19abe029d0e97ab42d54cde90"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::executionResult" ref="a050559a19abe029d0e97ab42d54cde90" args="(const SequenceNumber &amp;commandId=SequenceNumber(), const std::string &amp;value=std::string(), bool sync=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00054.html">Completion</a> qpid::client::no_keyword::AsyncSession_0_10::executionResult </td>
          <td>(</td>
          <td class="paramtype">const SequenceNumber &amp;&#160;</td>
          <td class="paramname"><em>commandId</em> = <code>SequenceNumber()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00345.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em> = <code><a class="el" href="a00345.html">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This command carries data resulting from the execution of a command. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">commandId</td><td></td></tr>
    <tr><td class="paramname">value</td><td></td></tr>
    <tr><td class="paramname">sync</td><td>If true the broker will respond with completion status as soon as possible. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="a00458_source.html#l00281">qpid::client::AsyncSession_0_10::BOOST_PARAMETER_MEMFUN()</a>.</p>

</div>
</div>
<a class="anchor" id="a0fe280bdbf655e1c4dd4cb350415fa69"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::executionSync" ref="a0fe280bdbf655e1c4dd4cb350415fa69" args="(bool sync=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00054.html">Completion</a> qpid::client::no_keyword::AsyncSession_0_10::executionSync </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This command is complete when all prior commands are completed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sync</td><td>If true the broker will respond with completion status as soon as possible. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="a00458_source.html#l00276">qpid::client::AsyncSession_0_10::BOOST_PARAMETER_MEMFUN()</a>.</p>

</div>
</div>
<a class="anchor" id="aad3b41e7fb8e6d40c309a9b0c7144243"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::flush" ref="aad3b41e7fb8e6d40c309a9b0c7144243" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qpid::client::SessionBase_0_10::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2395fbbedb1705bfefc45a70a9b80b6f"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::getChannel" ref="a2395fbbedb1705bfefc45a70a9b80b6f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00556.html#a273cf69d639a59973b6019625df33e30">uint16_t</a> qpid::client::SessionBase_0_10::getChannel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the channel associated with this session. </p>

</div>
</div>
<a class="anchor" id="ad90f254bc31ff8e5933c4dd14f3a48b5"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::getConnection" ref="ad90f254bc31ff8e5933c4dd14f3a48b5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00058.html">Connection</a> qpid::client::SessionBase_0_10::getConnection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aba4c611d0f2008bf153b5a0d372d7b32"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::getId" ref="aba4c611d0f2008bf153b5a0d372d7b32" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00333.html">SessionId</a> qpid::client::SessionBase_0_10::getId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the session ID. </p>

</div>
</div>
<a class="anchor" id="ae4424751cfa94ad272711dae9213cb2c"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::isValid" ref="ae4424751cfa94ad272711dae9213cb2c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool qpid::client::SessionBase_0_10::isValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a71b6f8e5c01c5ab1d8dba353f0c2dc6e"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::markCompleted" ref="a71b6f8e5c01c5ab1d8dba353f0c2dc6e" args="(const framing::SequenceSet &amp;ids, bool notifyPeer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qpid::client::SessionBase_0_10::markCompleted </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00324.html">framing::SequenceSet</a> &amp;&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>notifyPeer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab9d172be089286ffc7b4fda418b87301"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::markCompleted" ref="ab9d172be089286ffc7b4fda418b87301" args="(const framing::SequenceNumber &amp;id, bool cumulative, bool notifyPeer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qpid::client::SessionBase_0_10::markCompleted </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00323.html">framing::SequenceNumber</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cumulative</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>notifyPeer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad821639cdce49f66cd30112ec5791742"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::messageAccept" ref="ad821639cdce49f66cd30112ec5791742" args="(const SequenceSet &amp;transfers=SequenceSet(), bool sync=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00054.html">Completion</a> qpid::client::no_keyword::AsyncSession_0_10::messageAccept </td>
          <td>(</td>
          <td class="paramtype">const SequenceSet &amp;&#160;</td>
          <td class="paramname"><em>transfers</em> = <code>SequenceSet()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accepts the message. </p>
<p>Once a transfer is accepted, the command-id may no longer be referenced from other commands.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">transfers</td><td>Identifies the messages previously transferred that should be accepted.</td></tr>
    <tr><td class="paramname">sync</td><td>If true the broker will respond with completion status as soon as possible. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="a00458_source.html#l00309">qpid::client::AsyncSession_0_10::BOOST_PARAMETER_MEMFUN()</a>.</p>

</div>
</div>
<a class="anchor" id="a6ab77ab430ef121a86aa0c6bf3d3d482"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::messageAcquire" ref="a6ab77ab430ef121a86aa0c6bf3d3d482" args="(const SequenceSet &amp;transfers=SequenceSet(), bool sync=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00362.html">TypedResult</a>&lt;<a class="el" href="a00208.html">qpid::framing::MessageAcquireResult</a>&gt; qpid::client::no_keyword::AsyncSession_0_10::messageAcquire </td>
          <td>(</td>
          <td class="paramtype">const SequenceSet &amp;&#160;</td>
          <td class="paramname"><em>transfers</em> = <code>SequenceSet()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Acquires previously transferred messages for consumption. </p>
<p>The acquired ids (if any) are sent via message.acquired.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">transfers</td><td>Indicates the messages to be acquired.</td></tr>
    <tr><td class="paramname">sync</td><td>If true the broker will respond with completion status as soon as possible. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="a00458_source.html#l00330">qpid::client::AsyncSession_0_10::BOOST_PARAMETER_MEMFUN()</a>.</p>

</div>
</div>
<a class="anchor" id="a6515de4bd5583caf79678fece1ac4324"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::messageCancel" ref="a6515de4bd5583caf79678fece1ac4324" args="(const std::string &amp;destination=std::string(), bool sync=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00054.html">Completion</a> qpid::client::no_keyword::AsyncSession_0_10::messageCancel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00345.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em> = <code><a class="el" href="a00345.html">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This command cancels a subscription. </p>
<p>This does not affect already delivered messages, but it does mean the server will not send any more messages for that subscription. The client may receive an arbitrary number of messages in between sending the cancel command and receiving notification that the cancel command is complete.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td></td></tr>
    <tr><td class="paramname">sync</td><td>If true the broker will respond with completion status as soon as possible. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="a00458_source.html#l00356">qpid::client::AsyncSession_0_10::BOOST_PARAMETER_MEMFUN()</a>.</p>

</div>
</div>
<a class="anchor" id="ad1c3d9b0cdcd251924e7b9250014514b"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::messageFlow" ref="ad1c3d9b0cdcd251924e7b9250014514b" args="(const std::string &amp;destination=std::string(), uint8_t unit=0, uint32_t value=0, bool sync=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00054.html">Completion</a> qpid::client::no_keyword::AsyncSession_0_10::messageFlow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00345.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em> = <code><a class="el" href="a00345.html">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00556.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a>&#160;</td>
          <td class="paramname"><em>unit</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00556.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>value</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This command controls the flow of message data to a given destination. </p>
<p>It is used by the recipient of messages to dynamically match the incoming rate of message flow to its processing or forwarding capacity. Upon receipt of this command, the sender must add "value" number of the specified unit to the available credit balance for the specified destination. A value of (0xFFFFFFFF) indicates an infinite amount of credit. This disables any limit for the given unit until the credit balance is zeroed with message.stop or message.flush.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td></td></tr>
    <tr><td class="paramname">unit</td><td>The unit of value.</td></tr>
    <tr><td class="paramname">value</td><td>If the value is not set then this indicates an infinite amount of credit.</td></tr>
    <tr><td class="paramname">sync</td><td>If true the broker will respond with completion status as soon as possible. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="a00458_source.html#l00369">qpid::client::AsyncSession_0_10::BOOST_PARAMETER_MEMFUN()</a>.</p>

</div>
</div>
<a class="anchor" id="a71fc25ddb2ea172db942dcd04745f9c5"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::messageFlush" ref="a71fc25ddb2ea172db942dcd04745f9c5" args="(const std::string &amp;destination=std::string(), bool sync=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00054.html">Completion</a> qpid::client::no_keyword::AsyncSession_0_10::messageFlush </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00345.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em> = <code><a class="el" href="a00345.html">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Forces the sender to exhaust his credit supply. </p>
<p>The sender's credit will always be zero when this command completes. The command completes when immediately available message data has been transferred, or when the credit supply is exhausted.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td></td></tr>
    <tr><td class="paramname">sync</td><td>If true the broker will respond with completion status as soon as possible. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="a00458_source.html#l00377">qpid::client::AsyncSession_0_10::BOOST_PARAMETER_MEMFUN()</a>.</p>

</div>
</div>
<a class="anchor" id="a60b5beb353f7e64a82acd269493a8b56"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::messageReject" ref="a60b5beb353f7e64a82acd269493a8b56" args="(const SequenceSet &amp;transfers=SequenceSet(), uint16_t code=0, const std::string &amp;text=std::string(), bool sync=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00054.html">Completion</a> qpid::client::no_keyword::AsyncSession_0_10::messageReject </td>
          <td>(</td>
          <td class="paramtype">const SequenceSet &amp;&#160;</td>
          <td class="paramname"><em>transfers</em> = <code>SequenceSet()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00556.html#a273cf69d639a59973b6019625df33e30">uint16_t</a>&#160;</td>
          <td class="paramname"><em>code</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00345.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>text</em> = <code><a class="el" href="a00345.html">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates that the message transfers are unprocessable in some way. </p>
<p>A server may reject a message if it is unroutable. A client may reject a message if it is invalid. A message may be rejected for other reasons as well. Once a transfer is rejected, the command-id may no longer be referenced from other commands.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">transfers</td><td>Identifies the messages previously transferred that should be rejected.</td></tr>
    <tr><td class="paramname">code</td><td>Code describing the reason for rejection.</td></tr>
    <tr><td class="paramname">text</td><td>Text describing the reason for rejection.</td></tr>
    <tr><td class="paramname">sync</td><td>If true the broker will respond with completion status as soon as possible. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="a00458_source.html#l00315">qpid::client::AsyncSession_0_10::BOOST_PARAMETER_MEMFUN()</a>.</p>

</div>
</div>
<a class="anchor" id="a44104ba860b5bb0ac211f9d977c86a68"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::messageRelease" ref="a44104ba860b5bb0ac211f9d977c86a68" args="(const SequenceSet &amp;transfers=SequenceSet(), bool setRedelivered=false, bool sync=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00054.html">Completion</a> qpid::client::no_keyword::AsyncSession_0_10::messageRelease </td>
          <td>(</td>
          <td class="paramtype">const SequenceSet &amp;&#160;</td>
          <td class="paramname"><em>transfers</em> = <code>SequenceSet()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>setRedelivered</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Release previously transferred messages. </p>
<p>When acquired messages are released, they become available for acquisition by any subscriber. Once a transfer is released, the command-id may no longer be referenced from other commands.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">transfers</td><td>Indicates the messages to be released.</td></tr>
    <tr><td class="paramname">setRedelivered</td><td>By setting set-redelivered to true, any acquired messages released to a queue with this command will be marked as redelivered on their next transfer from that queue. If this flag is not set, then an acquired message will retain its original redelivered status on the queue. Messages that are not acquired are unaffected by the value of this flag.</td></tr>
    <tr><td class="paramname">sync</td><td>If true the broker will respond with completion status as soon as possible. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="a00458_source.html#l00323">qpid::client::AsyncSession_0_10::BOOST_PARAMETER_MEMFUN()</a>.</p>

</div>
</div>
<a class="anchor" id="a123c5719b317341ecdb3de6d60207303"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::messageResume" ref="a123c5719b317341ecdb3de6d60207303" args="(const std::string &amp;destination=std::string(), const std::string &amp;resumeId=std::string(), bool sync=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00362.html">TypedResult</a>&lt;<a class="el" href="a00212.html">qpid::framing::MessageResumeResult</a>&gt; qpid::client::no_keyword::AsyncSession_0_10::messageResume </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00345.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em> = <code><a class="el" href="a00345.html">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00345.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>resumeId</em> = <code><a class="el" href="a00345.html">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This command resumes an interrupted transfer. </p>
<p>The recipient should return the amount of partially transferred data associated with the given resume-id, or zero if there is no data at all. If a non-zero result is returned, the recipient should expect to receive message fragment(s) containing the remainder of the interrupted message.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>The destination to which the remaining message fragments are transferred.</td></tr>
    <tr><td class="paramname">resumeId</td><td>The name of the transfer being resumed.</td></tr>
    <tr><td class="paramname">sync</td><td>If true the broker will respond with completion status as soon as possible. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="a00458_source.html#l00336">qpid::client::AsyncSession_0_10::BOOST_PARAMETER_MEMFUN()</a>.</p>

</div>
</div>
<a class="anchor" id="ac30416dd3467e79a2e0e9966139da3c8"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::messageSetFlowMode" ref="ac30416dd3467e79a2e0e9966139da3c8" args="(const std::string &amp;destination=std::string(), uint8_t flowMode=0, bool sync=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00054.html">Completion</a> qpid::client::no_keyword::AsyncSession_0_10::messageSetFlowMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00345.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em> = <code><a class="el" href="a00345.html">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00556.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a>&#160;</td>
          <td class="paramname"><em>flowMode</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the mode of flow control used for a given destination to either window or credit based flow control. </p>
<p>With credit based flow control, the sender of messages continually maintains its current credit balance with the recipient. The credit balance consists of two values, a message count, and a byte count. Whenever message data is sent, both counts must be decremented. If either value reaches zero, the flow of message data must stop. Additional credit is received via the message.flow command.</p>
<p>The sender MUST NOT send partial assemblies. This means that if there is not enough byte credit available to send a complete message, the sender must either wait or use message fragmentation (see the fragment-properties header struct) to send the first part of the message data in a complete assembly.</p>
<p>Window based flow control is identical to credit based flow control, however message transfer completion implicitly grants a single unit of message credit, and the size of the message in byte credits for each completed message transfer. <a class="el" href="a00054.html" title="Asynchronous commands that do not return a result will return a Completion.">Completion</a> of the transfer command with session.completed is the only way credit is implicitly updated; message.accept, message.release, message.reject, tx.commit and tx.rollback have no effect on the outstanding credit balances.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td></td></tr>
    <tr><td class="paramname">flowMode</td><td>The new flow control mode.</td></tr>
    <tr><td class="paramname">sync</td><td>If true the broker will respond with completion status as soon as possible. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="a00458_source.html#l00362">qpid::client::AsyncSession_0_10::BOOST_PARAMETER_MEMFUN()</a>.</p>

</div>
</div>
<a class="anchor" id="af1946069aa7c0d8a01cb5ddedfa116d2"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::messageStop" ref="af1946069aa7c0d8a01cb5ddedfa116d2" args="(const std::string &amp;destination=std::string(), bool sync=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00054.html">Completion</a> qpid::client::no_keyword::AsyncSession_0_10::messageStop </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00345.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em> = <code><a class="el" href="a00345.html">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>On receipt of this command, a producer of messages MUST set his credit to zero for the given destination. </p>
<p>When notifying of completion, credit MUST be zero and no further messages will be sent until such a time as further credit is received.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td></td></tr>
    <tr><td class="paramname">sync</td><td>If true the broker will respond with completion status as soon as possible. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="a00458_source.html#l00383">qpid::client::AsyncSession_0_10::BOOST_PARAMETER_MEMFUN()</a>.</p>

</div>
</div>
<a class="anchor" id="a0c5e77d5360857699d93284478b1782d"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::messageSubscribe" ref="a0c5e77d5360857699d93284478b1782d" args="(const std::string &amp;queue=std::string(), const std::string &amp;destination=std::string(), uint8_t acceptMode=0, uint8_t acquireMode=0, bool exclusive=false, const std::string &amp;resumeId=std::string(), uint64_t resumeTtl=0, const FieldTable &amp;arguments=FieldTable(), bool sync=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00054.html">Completion</a> qpid::client::no_keyword::AsyncSession_0_10::messageSubscribe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00345.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>queue</em> = <code><a class="el" href="a00345.html">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00345.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em> = <code><a class="el" href="a00345.html">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00556.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a>&#160;</td>
          <td class="paramname"><em>acceptMode</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00556.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a>&#160;</td>
          <td class="paramname"><em>acquireMode</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exclusive</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00345.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>resumeId</em> = <code><a class="el" href="a00345.html">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>resumeTtl</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FieldTable &amp;&#160;</td>
          <td class="paramname"><em>arguments</em> = <code>FieldTable()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This command asks the server to start a "subscription", which is a request for messages from a specific queue. </p>
<p>Subscriptions last as long as the session they were created on, or until the client cancels them.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Specifies the name of the subscribed queue.</td></tr>
    <tr><td class="paramname">destination</td><td>The client specified name for the subscription. This is used as the destination for all messages transferred from this subscription. The destination is scoped to the session.</td></tr>
    <tr><td class="paramname">acceptMode</td><td>The accept-mode to use for messages transferred from this subscription.</td></tr>
    <tr><td class="paramname">acquireMode</td><td>The acquire-mode to use for messages transferred from this subscription.</td></tr>
    <tr><td class="paramname">exclusive</td><td>Request an exclusive subscription. This prevents other subscribers from subscribing to the queue.</td></tr>
    <tr><td class="paramname">resumeId</td><td>Requests that the broker use the supplied resume-id when transferring messages for this subscription.</td></tr>
    <tr><td class="paramname">resumeTtl</td><td>Requested duration in milliseconds for the broker use as resume-ttl when transferring messages for this subscription.</td></tr>
    <tr><td class="paramname">arguments</td><td>The syntax and semantics of these arguments depends on the providers implementation.</td></tr>
    <tr><td class="paramname">sync</td><td>If true the broker will respond with completion status as soon as possible. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="a00458_source.html#l00343">qpid::client::AsyncSession_0_10::BOOST_PARAMETER_MEMFUN()</a>.</p>

</div>
</div>
<a class="anchor" id="a745689ddd87824f8e4e60b94402ac08d"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::messageTransfer" ref="a745689ddd87824f8e4e60b94402ac08d" args="(const std::string &amp;destination=std::string(), uint8_t acceptMode=1, uint8_t acquireMode=0, const Message &amp;content=Message(std::string()), bool sync=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00054.html">Completion</a> qpid::client::no_keyword::AsyncSession_0_10::messageTransfer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00345.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em> = <code><a class="el" href="a00345.html">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00556.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a>&#160;</td>
          <td class="paramname"><em>acceptMode</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00556.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a>&#160;</td>
          <td class="paramname"><em>acquireMode</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00206.html">Message</a> &amp;&#160;</td>
          <td class="paramname"><em>content</em> = <code><a class="el" href="a00206.html">Message</a>(<a class="el" href="a00345.html">std::string</a>())</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This command transfers a message between two peers. </p>
<p>When a client uses this command to publish a message to a broker, the destination identifies a specific exchange. The message will then be routed to queues as defined by the exchange configuration.</p>
<p>The client may request a broker to transfer messages to it, from a particular queue, by issuing a subscribe command. The subscribe command specifies the destination that the broker should use for any resulting transfers.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>Specifies the destination to which the message is to be transferred.</td></tr>
    <tr><td class="paramname">acceptMode</td><td>Indicates whether message.accept, session.complete, or nothing at all is required to indicate successful transfer of the message.</td></tr>
    <tr><td class="paramname">acquireMode</td><td>Indicates whether or not the transferred message has been acquired.</td></tr>
    <tr><td class="paramname">content</td><td><a class="el" href="a00206.html" title="A message sent to or received from the broker.">Message</a> content</td></tr>
    <tr><td class="paramname">sync</td><td>If true the broker will respond with completion status as soon as possible. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="a00458_source.html#l00300">qpid::client::AsyncSession_0_10::BOOST_PARAMETER_MEMFUN()</a>.</p>

</div>
</div>
<a class="anchor" id="a5ae453e369fa2f4e8904e7088fad6931"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::operator=" ref="a5ae453e369fa2f4e8904e7088fad6931" args="(const SessionBase_0_10 &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QPID_CLIENT_INLINE_EXTERN <a class="el" href="a00019.html">AsyncSession_0_10</a>&amp; qpid::client::no_keyword::AsyncSession_0_10::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00328.html">SessionBase_0_10</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="a00020.html#ac0e27a5ab4faf09552fa596374dead9a">qpid::client::AsyncSession_0_10</a>.</p>

</div>
</div>
<a class="anchor" id="a0566092a09b8912dac10fa2b52ec815d"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::queueDeclare" ref="a0566092a09b8912dac10fa2b52ec815d" args="(const std::string &amp;queue=std::string(), const std::string &amp;alternateExchange=std::string(), bool passive=false, bool durable=false, bool exclusive=false, bool autoDelete=false, const FieldTable &amp;arguments=FieldTable(), bool sync=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00054.html">Completion</a> qpid::client::no_keyword::AsyncSession_0_10::queueDeclare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00345.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>queue</em> = <code><a class="el" href="a00345.html">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00345.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>alternateExchange</em> = <code><a class="el" href="a00345.html">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>passive</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>durable</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exclusive</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoDelete</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FieldTable &amp;&#160;</td>
          <td class="paramname"><em>arguments</em> = <code>FieldTable()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This command creates or checks a queue. </p>
<p>When creating a new queue the client can specify various properties that control the durability of the queue and its contents, and the level of sharing for the queue.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td></td></tr>
    <tr><td class="paramname">alternateExchange</td><td>The alternate-exchange field specifies how messages on this queue should be treated when they are rejected by a subscriber, or when they are orphaned by queue deletion. When present, rejected or orphaned messages MUST be routed to the alternate-exchange. In all cases the messages MUST be removed from the queue.</td></tr>
    <tr><td class="paramname">passive</td><td>If set, the server will not create the queue. This field allows the client to assert the presence of a queue without modifying the server state.</td></tr>
    <tr><td class="paramname">durable</td><td>If set when creating a new queue, the queue will be marked as durable. Durable queues remain active when a server restarts. Non-durable queues (transient queues) are purged if/when a server restarts. Note that durable queues do not necessarily hold persistent messages, although it does not make sense to send persistent messages to a transient queue.</td></tr>
    <tr><td class="paramname">exclusive</td><td>Exclusive queues can only be used from one session at a time. Once a session declares an exclusive queue, that queue cannot be used by any other session until the declaring session closes.</td></tr>
    <tr><td class="paramname">autoDelete</td><td>If this field is set and the exclusive field is also set, then the queue MUST be deleted when the session closes.</td></tr>
  </table>
  </dd>
</dl>
<p>If this field is set and the exclusive field is not set the queue is deleted when all the consumers have finished using it. Last consumer can be cancelled either explicitly or because its session is closed. If there was no consumer ever on the queue, it won't be deleted.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">arguments</td><td>A set of arguments for the declaration. The syntax and semantics of these arguments depends on the server implementation. This field is ignored if passive is 1.</td></tr>
    <tr><td class="paramname">sync</td><td>If true the broker will respond with completion status as soon as possible. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="a00458_source.html#l00519">qpid::client::AsyncSession_0_10::BOOST_PARAMETER_MEMFUN()</a>.</p>

</div>
</div>
<a class="anchor" id="a1e266f5ad9b7af100b2322d7ded4a393"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::queueDelete" ref="a1e266f5ad9b7af100b2322d7ded4a393" args="(const std::string &amp;queue=std::string(), bool ifUnused=false, bool ifEmpty=false, bool sync=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00054.html">Completion</a> qpid::client::no_keyword::AsyncSession_0_10::queueDelete </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00345.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>queue</em> = <code><a class="el" href="a00345.html">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ifUnused</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ifEmpty</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This command deletes a queue. </p>
<p>When a queue is deleted any pending messages are sent to the alternate-exchange if defined, or discarded if it is not.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Specifies the name of the queue to delete.</td></tr>
    <tr><td class="paramname">ifUnused</td><td>If set, the server will only delete the queue if it has no consumers. If the queue has consumers the server does does not delete it but raises an exception instead.</td></tr>
    <tr><td class="paramname">ifEmpty</td><td>If set, the server will only delete the queue if it has no messages.</td></tr>
    <tr><td class="paramname">sync</td><td>If true the broker will respond with completion status as soon as possible. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="a00458_source.html#l00531">qpid::client::AsyncSession_0_10::BOOST_PARAMETER_MEMFUN()</a>.</p>

</div>
</div>
<a class="anchor" id="ac69995a96be1205ab7617c7bc80c12c9"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::queuePurge" ref="ac69995a96be1205ab7617c7bc80c12c9" args="(const std::string &amp;queue=std::string(), bool sync=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00054.html">Completion</a> qpid::client::no_keyword::AsyncSession_0_10::queuePurge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00345.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>queue</em> = <code><a class="el" href="a00345.html">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This command removes all messages from a queue. </p>
<p>It does not cancel subscribers. Purged messages are deleted without any formal "undo" mechanism.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Specifies the name of the queue to purge.</td></tr>
    <tr><td class="paramname">sync</td><td>If true the broker will respond with completion status as soon as possible. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="a00458_source.html#l00539">qpid::client::AsyncSession_0_10::BOOST_PARAMETER_MEMFUN()</a>.</p>

</div>
</div>
<a class="anchor" id="a72a55bbf31b38d4a57169e460bb45f32"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::queueQuery" ref="a72a55bbf31b38d4a57169e460bb45f32" args="(const std::string &amp;queue=std::string(), bool sync=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00362.html">TypedResult</a>&lt;<a class="el" href="a00265.html">qpid::framing::QueueQueryResult</a>&gt; qpid::client::no_keyword::AsyncSession_0_10::queueQuery </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00345.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>queue</em> = <code><a class="el" href="a00345.html">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This command requests information about a queue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td></td></tr>
    <tr><td class="paramname">sync</td><td>If true the broker will respond with completion status as soon as possible. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="a00458_source.html#l00545">qpid::client::AsyncSession_0_10::BOOST_PARAMETER_MEMFUN()</a>.</p>

</div>
</div>
<a class="anchor" id="a7b6f55034313f9a4ca2d2ae71649b840"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::resume" ref="a7b6f55034313f9a4ca2d2ae71649b840" args="(Connection)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qpid::client::SessionBase_0_10::resume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00058.html">Connection</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resume a suspended session with a new connection. </p>

</div>
</div>
<a class="anchor" id="a151e42932f03d3a453bb1598e160a025"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::sendCompletion" ref="a151e42932f03d3a453bb1598e160a025" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qpid::client::SessionBase_0_10::sendCompletion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7767cc2b33cdba119824b86ca212dbd6"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::suspend" ref="a7767cc2b33cdba119824b86ca212dbd6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qpid::client::SessionBase_0_10::suspend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Suspend the session - detach it from its connection. </p>

</div>
</div>
<a class="anchor" id="a198880ec0840c18b0d8a9140d38db699"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::sync" ref="a198880ec0840c18b0d8a9140d38db699" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qpid::client::SessionBase_0_10::sync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Synchronize the session: <a class="el" href="a00328.html#a198880ec0840c18b0d8a9140d38db699" title="Synchronize the session: sync() waits until all commands issued on this session so far have been comp...">sync()</a> waits until all commands issued on this session so far have been completed by the broker. </p>
<p>Note <a class="el" href="a00328.html#a198880ec0840c18b0d8a9140d38db699" title="Synchronize the session: sync() waits until all commands issued on this session so far have been comp...">sync()</a> is always synchronous, even on an AsyncSession object because that's almost always what you want. You can call <a class="el" href="a00019.html#a0fe280bdbf655e1c4dd4cb350415fa69" title="This command is complete when all prior commands are completed.">AsyncSession::executionSync()</a> directly in the unusual event that you want to do an asynchronous sync. </p>

</div>
</div>
<a class="anchor" id="a90f4dc4899c23d4cfb00360a5f215b26"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::timeout" ref="a90f4dc4899c23d4cfb00360a5f215b26" args="(uint32_t seconds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00556.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> qpid::client::SessionBase_0_10::timeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00556.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>seconds</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the timeout for this session. </p>

</div>
</div>
<a class="anchor" id="a62be3d27b93a47294dc8772b79aed768"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::txCommit" ref="a62be3d27b93a47294dc8772b79aed768" args="(bool sync=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00054.html">Completion</a> qpid::client::no_keyword::AsyncSession_0_10::txCommit </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This command commits all messages published and accepted in the current transaction. </p>
<p>A new transaction starts immediately after a commit.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sync</td><td>If true the broker will respond with completion status as soon as possible. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="a00458_source.html#l00394">qpid::client::AsyncSession_0_10::BOOST_PARAMETER_MEMFUN()</a>.</p>

</div>
</div>
<a class="anchor" id="a6fc047d1410d33cd1ba45cdc269dc62c"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::txRollback" ref="a6fc047d1410d33cd1ba45cdc269dc62c" args="(bool sync=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00054.html">Completion</a> qpid::client::no_keyword::AsyncSession_0_10::txRollback </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This command abandons the current transaction. </p>
<p>In particular the transfers from Client to Server (publishes) and accepts of transfers from Server to Client which occurred in the current transaction are discarded. A new transaction starts immediately after a rollback.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sync</td><td>If true the broker will respond with completion status as soon as possible. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="a00458_source.html#l00399">qpid::client::AsyncSession_0_10::BOOST_PARAMETER_MEMFUN()</a>.</p>

</div>
</div>
<a class="anchor" id="a5dbd9d674e51bf67d4bd97a033fad1f7"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::txSelect" ref="a5dbd9d674e51bf67d4bd97a033fad1f7" args="(bool sync=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00054.html">Completion</a> qpid::client::no_keyword::AsyncSession_0_10::txSelect </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This command sets the session to use standard transactions. </p>
<p>The client must use this command exactly once on a session before using the Commit or Rollback commands.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sync</td><td>If true the broker will respond with completion status as soon as possible. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="a00458_source.html#l00389">qpid::client::AsyncSession_0_10::BOOST_PARAMETER_MEMFUN()</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a72d171e291fab3cd457bf04276970904"></a><!-- doxytag: member="qpid::client::no_keyword::AsyncSession_0_10::impl" ref="a72d171e291fab3cd457bf04276970904" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;SessionImpl&gt; <a class="el" href="a00328.html#a72d171e291fab3cd457bf04276970904">qpid::client::SessionBase_0_10::impl</a><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00478_source.html#l00104">104</a> of file <a class="el" href="a00478_source.html">SessionBase_0_10.h</a>.</p>

<p>Referenced by <a class="el" href="a00458_source.html#l00559">qpid::client::AsyncSession_0_10::operator=()</a>, and <a class="el" href="a00474_source.html#l00559">qpid::client::Session_0_10::operator=()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>qpid/client/no_keyword/<a class="el" href="a00459_source.html">AsyncSession_0_10.h</a></li>
</ul>
</div>
<!--
 
 Licensed to the Apache Software Foundation (ASF) under one
 or more contributor license agreements.  See the NOTICE file
 distributed with this work for additional information
 regarding copyright ownership.  The ASF licenses this file
 to you under the Apache License, Version 2.0 (the
 "License"); you may not use this file except in compliance
 with the License.  You may obtain a copy of the License at
 
   http://www.apache.org/licenses/LICENSE-2.0
 
 Unless required by applicable law or agreed to in writing,
 software distributed under the License is distributed on an
 "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 KIND, either express or implied.  See the License for the
 specific language governing permissions and limitations
 under the License.
 
-->

<hr size="1">
<address style="text-align: left;"><small>
Qpid C++ API Reference</small></address>

<address style="text-align: right;">
<small>
Generated on Mon Jan 16 2012 for Qpid C++ Client API by&nbsp;<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.7.5</small>
</address>
</body>
</html>
