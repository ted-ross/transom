<div class="docbook"><div class="book" title="AMQP Messaging Broker (Implemented in C++)"><div class="titlepage"><div><div><h1 class="title"><a id="idp19249600" />AMQP Messaging Broker (Implemented in C++)</h1></div></div><hr /></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="preface"><a href="#idp19249072">Introduction</a></span></dt><dt><span class="chapter"><a href="#idp26750624">1. 
      Running the AMQP Messaging Broker
    </a></span></dt><dd><dl><dt><span class="section"><a href="#section-Running-a-Qpid-CPP-Broker">1.1. 
    Running a Qpid C++ Broker
  </a></span></dt><dd><dl><dt><span class="section"><a href="#RASC-BuildingtheCppBrokerandClientLibraries">1.1.1. 
            Building the
            C++ Broker and Client Libraries
          </a></span></dt><dt><span class="section"><a href="#RASC-RunningtheCppBroker">1.1.2. 
            Running the C++ Broker
          </a></span></dt><dt><span class="section"><a href="#RASC-Mostcommonquestionsgettingqpiddrunning">1.1.3. 
            Most
            common questions getting qpidd running
          </a></span></dt><dt><span class="section"><a href="#RASC-Authentication">1.1.4. 
            Authentication
          </a></span></dt><dt><span class="section"><a href="#RASC-Slightlymorecomplexconfiguration">1.1.5. 
            Slightly more
            complex configuration
          </a></span></dt><dt><span class="section"><a href="#RASC-Loadingextramodules">1.1.6. 
            Loading extra modules
          </a></span></dt><dt><span class="section"><a href="#RASC-message-timestamps">1.1.7. Timestamping Received Messages</a></span></dt></dl></dd><dt><span class="section"><a href="#idp26767520">1.2. 
      Cheat Sheet for configuring Queue Options
    </a></span></dt><dd><dl><dt><span class="section"><a href="#CheatSheetforconfiguringQueueOptions-ConfiguringQueueOptions">1.2.1. 
            Configuring
            Queue Options
          </a></span></dt></dl></dd><dt><span class="section"><a href="#idp26745808">1.3. 
    Cheat Sheet for configuring Exchange Options
  </a></span></dt><dd><dl><dt><span class="section"><a href="#CheatSheetforconfiguringExchangeOptions-ConfiguringExchangeOptions">1.3.1. 
      Configuring Exchange Options
    </a></span></dt></dl></dd><dt><span class="section"><a href="#chap-Messaging_User_Guide-Broker_Federation">1.4. Broker Federation</a></span></dt><dd><dl><dt><span class="section"><a href="#sect-Messaging_User_Guide-Broker_Federation-Message_Routes">1.4.1. Message Routes</a></span></dt><dt><span class="section"><a href="#sect-Messaging_User_Guide-Broker_Federation-Federation_Topologies">1.4.2. Federation Topologies</a></span></dt><dt><span class="section"><a href="#sect-Messaging_User_Guide-Broker_Federation-Federation_among_High_Availability_Message_Clusters">1.4.3. Federation among High Availability Message Clusters</a></span></dt><dt><span class="section"><a href="#sect-Messaging_User_Guide-Broker_Federation-The_qpid_route_Utility">1.4.4. The qpid-route Utility</a></span></dt></dl></dd><dt><span class="section"><a href="#chap-Messaging_User_Guide-Security">1.5. Security</a></span></dt><dd><dl><dt><span class="section"><a href="#sect-Messaging_User_Guide-Security-User_Authentication">1.5.1. User Authentication</a></span></dt><dt><span class="section"><a href="#sect-Messaging_User_Guide-Security-Authorization">1.5.2. Authorization</a></span></dt><dt><span class="section"><a href="#sect-Messaging_User_Guide-Authorization-Specifying_ACL_Quotas">1.5.3. User Connection and Queue Quotas</a></span></dt><dt><span class="section"><a href="#sect-Messaging_User_Guide-Security-Encryption_using_SSL">1.5.4. Encryption using SSL</a></span></dt></dl></dd><dt><span class="section"><a href="#idp29424512">1.6. LVQ - Last Value Queue</a></span></dt><dd><dl><dt><span class="section"><a href="#LVQ-UnderstandingLVQ">1.6.1. Understanding LVQ</a></span></dt><dt><span class="section"><a href="#LVQ-Creating">1.6.2. Creating a Last Value Queue</a></span></dt><dt><span class="section"><a href="#LVQ-Example">1.6.3. LVQ Example</a></span></dt><dt><span class="section"><a href="#LVQ-Deprecated">1.6.4. Deprecated LVQ Modes</a></span></dt></dl></dd><dt><span class="section"><a href="#queue-state-replication">1.7. 
    Queue State Replication
  </a></span></dt><dd><dl><dt><span class="section"><a href="#queuestatereplication-AsynchronousReplicationofQueueState">1.7.1. 
      Asynchronous
      Replication of Queue State
    </a></span></dt></dl></dd><dt><span class="section"><a href="#producer-flow-control">1.8. 
    Producer Flow Control
  </a></span></dt><dd><dl><dt><span class="section"><a href="#producerflowcontrol-Overview">1.8.1. 
      Overview
    </a></span></dt><dt><span class="section"><a href="#producerflowcontrol-UserInterface">1.8.2. 
        User Interface
      </a></span></dt></dl></dd><dt><span class="section"><a href="#AMQP-Compatibility">1.9. 
      AMQP compatibility
    </a></span></dt><dd><dl><dt><span class="section"><a href="#AMQPcompatibility-AMQPCompatibilityofQpidreleases-3A">1.9.1. 
            AMQP
            Compatibility of Qpid releases:
          </a></span></dt><dt><span class="section"><a href="#AMQPcompatibility-InteroptablebyAMQPspecificationversion">1.9.2. 
            Interop
            table by AMQP specification version
          </a></span></dt></dl></dd><dt><span class="section"><a href="#QpidInteroperabilityDocumentation-QpidInteroperabilityDocumentation">1.10. Qpid Interoperability Documentation</a></span></dt><dd><dl><dt><span class="section"><a href="#QpidInteroperabilityDocumentation-SASL">1.10.1. 
            SASL
          </a></span></dt></dl></dd><dt><span class="section"><a href="#Using-message-groups">1.11. 
    Using Message Groups
  </a></span></dt><dd><dl><dt><span class="section"><a href="#usingmessagegroups-Overview">1.11.1. 
      Overview
    </a></span></dt><dt><span class="section"><a href="#usingmessagegroups-GroupingMessages">1.11.2. 
        Grouping Messages
      </a></span></dt><dt><span class="section"><a href="#usingmessagegroups-BrokerRole">1.11.3. 
        The Role of the Broker
      </a></span></dt><dt><span class="section"><a href="#usingmessagegroups-ConsumerGuide">1.11.4. 
        Well Behaved Consumers
      </a></span></dt><dt><span class="section"><a href="#usingmessagegroups-BrokerConfig">1.11.5. 
        Broker Configuration
      </a></span></dt></dl></dd><dt><span class="section"><a href="#chapter-ha">1.12. Active-Passive Messaging Clusters</a></span></dt><dd><dl><dt><span class="section"><a href="#ha-overview">1.12.1. Overview</a></span></dt><dt><span class="section"><a href="#ha-virtual-ip">1.12.2. Virtual IP Addresses</a></span></dt><dt><span class="section"><a href="#ha-broker-config">1.12.3. Configuring the Brokers</a></span></dt><dt><span class="section"><a href="#ha-rm">1.12.4. The Cluster Resource Manager</a></span></dt><dt><span class="section"><a href="#ha-rm-config">1.12.5. Configuring <span class="command"><strong>rgmanager</strong></span> as resource manager</a></span></dt><dt><span class="section"><a href="#ha-broker-admin">1.12.6. Broker Administration Tools</a></span></dt><dt><span class="section"><a href="#ha-replicate-values">1.12.7. Controlling replication of queues and exchanges</a></span></dt><dt><span class="section"><a href="#ha-failover">1.12.8. Client Connection and Fail-over</a></span></dt><dt><span class="section"><a href="#ha-security">1.12.9. Security.</a></span></dt><dt><span class="section"><a href="#ha-other-rm">1.12.10. Integrating with other Cluster Resource Managers</a></span></dt><dt><span class="section"><a href="#ha-queue-replication">1.12.11. Replicating specific queues</a></span></dt><dt><span class="section"><a href="#ha-store">1.12.12. Using a message store in a cluster</a></span></dt></dl></dd><dt><span class="section"><a href="#idp30497168">1.13. Queue Replication with the HA module</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chapter-Managing-CPP-Broker">2. 
      Managing the AMQP Messaging Broker
    </a></span></dt><dd><dl><dt><span class="section"><a href="#section-Managing-CPP-Broker">2.1.  Managing the C++ Broker </a></span></dt><dd><dl><dt><span class="section"><a href="#MgmtC-2B-2B-Usingqpidconfig">2.1.1. 
            Using qpid-config
          </a></span></dt><dt><span class="section"><a href="#MgmtC-2B-2B-Usingqpidroute">2.1.2. 
            Using qpid-route
          </a></span></dt><dt><span class="section"><a href="#MgmtC-2B-2B-Usingqpidtool">2.1.3. 
            Using qpid-tool
          </a></span></dt><dt><span class="section"><a href="#MgmtC-2B-2B-Usingqpidprintevents">2.1.4. 
            Using
            qpid-printevents
          </a></span></dt><dt><span class="section"><a href="#idp27654976">2.1.5. Using qpid-ha</a></span></dt></dl></dd><dt><span class="section"><a href="#idp29386832">2.2. 
      Qpid Management Framework
    </a></span></dt><dd><dl><dt><span class="section"><a href="#QpidManagementFramework-WhatIsQMF">2.2.1. 
            What Is QMF
          </a></span></dt><dt><span class="section"><a href="#QpidManagementFramework-GettingStartedwithQMF">2.2.2. 
            Getting
            Started with QMF
          </a></span></dt><dt><span class="section"><a href="#QpidManagementFramework-QMFConcepts">2.2.3. 
            QMF Concepts
          </a></span></dt><dt><span class="section"><a href="#QpidManagementFramework-TheQMFProtocol">2.2.4. 
            The QMF
            Protocol
          </a></span></dt><dt><span class="section"><a href="#QpidManagementFramework-HowtoWriteaQMFConsole">2.2.5. 
            How
            to Write a QMF Console
          </a></span></dt><dt><span class="section"><a href="#QpidManagementFramework-HowtoWriteaQMFAgent">2.2.6. 
            How to
            Write a QMF Agent
          </a></span></dt></dl></dd><dt><span class="section"><a href="#idp30998832">2.3. 
      QMF Python Console Tutorial
    </a></span></dt><dd><dl><dt><span class="section"><a href="#QMFPythonConsoleTutorial-PrerequisiteInstallQpidMessaging">2.3.1. 
            Prerequisite
            - Install Qpid Messaging
          </a></span></dt><dt><span class="section"><a href="#QMFPythonConsoleTutorial-SynchronousConsoleOperations">2.3.2. 
            Synchronous
            Console Operations
          </a></span></dt><dt><span class="section"><a href="#QMFPythonConsoleTutorial-AsynchronousConsoleOperations">2.3.3. 
            Asynchronous
            Console Operations
          </a></span></dt><dt><span class="section"><a href="#QMFPythonConsoleTutorial-DiscoveringwhatKindsofObjectsareAvailable">2.3.4. 
            Discovering what Kinds of Objects are Available
          </a></span></dt></dl></dd></dl></dd></dl></div><div class="list-of-tables"><p><strong>List of Tables</strong></p><dl><dt>1.1. <a href="#idp26828544">QMF Management - Broker Methods for Managing the Timestamp Configuration</a></dt><dt>1.2. <a href="#tabl-Messaging_User_Guide-The_qpid_route_Utility-qpid_route_options"><span class="command">qpid-route</span> options</a></dt><dt>1.3. <a href="#tabl-Messaging_User_Guide-Resilient_Connections-State_values_in_qpid_route_list_connections">State values in <span class="command">$ qpid-route list connections</span></a></dt><dt>1.4. <a href="#tabl-Messaging_User_Guide-ACL_Syntax-ACL_Rules_permission">ACL Rules: permission</a></dt><dt>1.5. <a href="#tabl-Messaging_User_Guide-ACL_Syntax-ACL_Rulesaction">ACL Rules:action</a></dt><dt>1.6. <a href="#tabl-Messaging_User_Guide-ACL_Syntax-ACL_Rulesobject">ACL Rules:object</a></dt><dt>1.7. <a href="#tabl-Messaging_User_Guide-ACL_Syntax-ACL_Rulesproperty">ACL Rules:property</a></dt><dt>1.8. <a href="#tabl-Messaging_User_Guide-ACL_Syntax-ACL_ActionObject_properties">ACL Properties Allowed for each Action and Object</a></dt><dt>1.9. <a href="#tabl-Messaging_User_Guide-ACL_Syntax-ACL_UsernameSubstitution">ACL User Name and Domain Name Substitution Keywords</a></dt><dt>1.10. <a href="#tabl-Messaging_User_Guide-ACL_Syntax-ACL_TopicExchangeMatch">Topic Exchange Wildcard Match Examples</a></dt><dt>1.11. <a href="#tabl-Messaging_User_Guide-Enabling_SSL_in_Clients-SSL_Client_Environment_Variables_for_C_clients">SSL Client Environment Variables for C++ clients</a></dt><dt>1.12. <a href="#idp31134576">Queue Declare Method Flow Control Arguments</a></dt><dt>1.13. <a href="#idp32099808">Flow Control Statistics available in Queue's QMF Class</a></dt><dt>1.14. <a href="#idp27396656">AMQP Version Support by Qpid Release</a></dt><dt>1.15. <a href="#idp30294160">AMQP Version Support - alternate format</a></dt><dt>1.16. <a href="#idp27690240">SASL Mechanism Support</a></dt><dt>1.17. <a href="#idp30531280">SASL Custom Mechanisms</a></dt><dt>1.18. <a href="#idp29354752">qpid-config options for creating message group queues</a></dt><dt>1.19. <a href="#idp27709280">Queue Declare/Address Syntax Message Group Configuration Arguments</a></dt><dt>1.20. <a href="#ha-broker-options">Broker Options for High Availability Messaging Cluster</a></dt><dt>1.21. <a href="#ha-broker-security-options">Security options for High Availability Messaging Cluster</a></dt><dt>2.1. <a href="#idp30994960">XML Attributes for QMF Properties and Statistics</a></dt><dt>2.2. <a href="#idp27876336">QMF Datatypes</a></dt><dt>2.3. <a href="#idp32052304">XML Schema Mapping for QMF Types</a></dt><dt>2.4. <a href="#idp27374880">QMF Python Console Class Methods</a></dt></dl></div><div class="list-of-examples"><p><strong>List of Examples</strong></p><dl><dt>1.1. <a href="#idp26835344">Enabling Message Timestamping via QMF - Python</a></dt><dt>1.2. <a href="#idp30717904">Creating a message group queue via qpid-config</a></dt><dt>1.3. <a href="#idp29249200">Creating a message group queue using address syntax (C++)</a></dt><dt>1.4. <a href="#idp31950672">Overriding the default message group identifier for the broker</a></dt></dl></div><div class="preface" title="Introduction"><div class="titlepage"><div><div><h2 class="title"><a id="idp19249072" />Introduction</h2></div></div></div><p>Qpid provides two AMQP messaging brokers:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Implemented in C++ - high performance, low latency, and RDMA support.</p></li><li class="listitem"><p>Implemented in Java - Fully JMS compliant, runs on any Java platform.</p></li></ul></div><p>Both AMQP messaging brokers support clients in multiple
    languages, as long as the messaging client and the messaging
    broker use the same version of AMQP. See <a class="link" href="#AMQP-Compatibility" title="1.9.&#160; AMQP compatibility">AMQP Compatibility</a> to see
    which messaging clients work with each broker.</p><p>This manual contains information specific to the broker that is implemented in C++.</p></div><div class="chapter" title="Chapter&#160;1.&#160; Running the AMQP Messaging Broker"><div class="titlepage"><div><div><h2 class="title"><a id="idp26750624" />Chapter&#160;1.&#160;
      Running the AMQP Messaging Broker
    </h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="section"><a href="#section-Running-a-Qpid-CPP-Broker">1.1. 
    Running a Qpid C++ Broker
  </a></span></dt><dd><dl><dt><span class="section"><a href="#RASC-BuildingtheCppBrokerandClientLibraries">1.1.1. 
            Building the
            C++ Broker and Client Libraries
          </a></span></dt><dt><span class="section"><a href="#RASC-RunningtheCppBroker">1.1.2. 
            Running the C++ Broker
          </a></span></dt><dt><span class="section"><a href="#RASC-Mostcommonquestionsgettingqpiddrunning">1.1.3. 
            Most
            common questions getting qpidd running
          </a></span></dt><dt><span class="section"><a href="#RASC-Authentication">1.1.4. 
            Authentication
          </a></span></dt><dt><span class="section"><a href="#RASC-Slightlymorecomplexconfiguration">1.1.5. 
            Slightly more
            complex configuration
          </a></span></dt><dt><span class="section"><a href="#RASC-Loadingextramodules">1.1.6. 
            Loading extra modules
          </a></span></dt><dt><span class="section"><a href="#RASC-message-timestamps">1.1.7. Timestamping Received Messages</a></span></dt></dl></dd><dt><span class="section"><a href="#idp26767520">1.2. 
      Cheat Sheet for configuring Queue Options
    </a></span></dt><dd><dl><dt><span class="section"><a href="#CheatSheetforconfiguringQueueOptions-ConfiguringQueueOptions">1.2.1. 
            Configuring
            Queue Options
          </a></span></dt></dl></dd><dt><span class="section"><a href="#idp26745808">1.3. 
    Cheat Sheet for configuring Exchange Options
  </a></span></dt><dd><dl><dt><span class="section"><a href="#CheatSheetforconfiguringExchangeOptions-ConfiguringExchangeOptions">1.3.1. 
      Configuring Exchange Options
    </a></span></dt></dl></dd><dt><span class="section"><a href="#chap-Messaging_User_Guide-Broker_Federation">1.4. Broker Federation</a></span></dt><dd><dl><dt><span class="section"><a href="#sect-Messaging_User_Guide-Broker_Federation-Message_Routes">1.4.1. Message Routes</a></span></dt><dt><span class="section"><a href="#sect-Messaging_User_Guide-Broker_Federation-Federation_Topologies">1.4.2. Federation Topologies</a></span></dt><dt><span class="section"><a href="#sect-Messaging_User_Guide-Broker_Federation-Federation_among_High_Availability_Message_Clusters">1.4.3. Federation among High Availability Message Clusters</a></span></dt><dt><span class="section"><a href="#sect-Messaging_User_Guide-Broker_Federation-The_qpid_route_Utility">1.4.4. The qpid-route Utility</a></span></dt></dl></dd><dt><span class="section"><a href="#chap-Messaging_User_Guide-Security">1.5. Security</a></span></dt><dd><dl><dt><span class="section"><a href="#sect-Messaging_User_Guide-Security-User_Authentication">1.5.1. User Authentication</a></span></dt><dt><span class="section"><a href="#sect-Messaging_User_Guide-Security-Authorization">1.5.2. Authorization</a></span></dt><dt><span class="section"><a href="#sect-Messaging_User_Guide-Authorization-Specifying_ACL_Quotas">1.5.3. User Connection and Queue Quotas</a></span></dt><dt><span class="section"><a href="#sect-Messaging_User_Guide-Security-Encryption_using_SSL">1.5.4. Encryption using SSL</a></span></dt></dl></dd><dt><span class="section"><a href="#idp29424512">1.6. LVQ - Last Value Queue</a></span></dt><dd><dl><dt><span class="section"><a href="#LVQ-UnderstandingLVQ">1.6.1. Understanding LVQ</a></span></dt><dt><span class="section"><a href="#LVQ-Creating">1.6.2. Creating a Last Value Queue</a></span></dt><dt><span class="section"><a href="#LVQ-Example">1.6.3. LVQ Example</a></span></dt><dt><span class="section"><a href="#LVQ-Deprecated">1.6.4. Deprecated LVQ Modes</a></span></dt></dl></dd><dt><span class="section"><a href="#queue-state-replication">1.7. 
    Queue State Replication
  </a></span></dt><dd><dl><dt><span class="section"><a href="#queuestatereplication-AsynchronousReplicationofQueueState">1.7.1. 
      Asynchronous
      Replication of Queue State
    </a></span></dt></dl></dd><dt><span class="section"><a href="#producer-flow-control">1.8. 
    Producer Flow Control
  </a></span></dt><dd><dl><dt><span class="section"><a href="#producerflowcontrol-Overview">1.8.1. 
      Overview
    </a></span></dt><dt><span class="section"><a href="#producerflowcontrol-UserInterface">1.8.2. 
        User Interface
      </a></span></dt></dl></dd><dt><span class="section"><a href="#AMQP-Compatibility">1.9. 
      AMQP compatibility
    </a></span></dt><dd><dl><dt><span class="section"><a href="#AMQPcompatibility-AMQPCompatibilityofQpidreleases-3A">1.9.1. 
            AMQP
            Compatibility of Qpid releases:
          </a></span></dt><dt><span class="section"><a href="#AMQPcompatibility-InteroptablebyAMQPspecificationversion">1.9.2. 
            Interop
            table by AMQP specification version
          </a></span></dt></dl></dd><dt><span class="section"><a href="#QpidInteroperabilityDocumentation-QpidInteroperabilityDocumentation">1.10. Qpid Interoperability Documentation</a></span></dt><dd><dl><dt><span class="section"><a href="#QpidInteroperabilityDocumentation-SASL">1.10.1. 
            SASL
          </a></span></dt></dl></dd><dt><span class="section"><a href="#Using-message-groups">1.11. 
    Using Message Groups
  </a></span></dt><dd><dl><dt><span class="section"><a href="#usingmessagegroups-Overview">1.11.1. 
      Overview
    </a></span></dt><dt><span class="section"><a href="#usingmessagegroups-GroupingMessages">1.11.2. 
        Grouping Messages
      </a></span></dt><dt><span class="section"><a href="#usingmessagegroups-BrokerRole">1.11.3. 
        The Role of the Broker
      </a></span></dt><dt><span class="section"><a href="#usingmessagegroups-ConsumerGuide">1.11.4. 
        Well Behaved Consumers
      </a></span></dt><dt><span class="section"><a href="#usingmessagegroups-BrokerConfig">1.11.5. 
        Broker Configuration
      </a></span></dt></dl></dd><dt><span class="section"><a href="#chapter-ha">1.12. Active-Passive Messaging Clusters</a></span></dt><dd><dl><dt><span class="section"><a href="#ha-overview">1.12.1. Overview</a></span></dt><dt><span class="section"><a href="#ha-virtual-ip">1.12.2. Virtual IP Addresses</a></span></dt><dt><span class="section"><a href="#ha-broker-config">1.12.3. Configuring the Brokers</a></span></dt><dt><span class="section"><a href="#ha-rm">1.12.4. The Cluster Resource Manager</a></span></dt><dt><span class="section"><a href="#ha-rm-config">1.12.5. Configuring <span class="command"><strong>rgmanager</strong></span> as resource manager</a></span></dt><dt><span class="section"><a href="#ha-broker-admin">1.12.6. Broker Administration Tools</a></span></dt><dt><span class="section"><a href="#ha-replicate-values">1.12.7. Controlling replication of queues and exchanges</a></span></dt><dt><span class="section"><a href="#ha-failover">1.12.8. Client Connection and Fail-over</a></span></dt><dt><span class="section"><a href="#ha-security">1.12.9. Security.</a></span></dt><dt><span class="section"><a href="#ha-other-rm">1.12.10. Integrating with other Cluster Resource Managers</a></span></dt><dt><span class="section"><a href="#ha-queue-replication">1.12.11. Replicating specific queues</a></span></dt><dt><span class="section"><a href="#ha-store">1.12.12. Using a message store in a cluster</a></span></dt></dl></dd><dt><span class="section"><a href="#idp30497168">1.13. Queue Replication with the HA module</a></span></dt></dl></div><div class="section" title="1.1.&#160; Running a Qpid C++ Broker"><div class="titlepage"><div><div><h2 class="title"><a id="section-Running-a-Qpid-CPP-Broker" />1.1.&#160;
    Running a Qpid C++ Broker
  </h2></div></div></div><div class="section" title="1.1.1.&#160; Building the C++ Broker and Client Libraries"><div class="titlepage"><div><div><h3 class="title"><a id="RASC-BuildingtheCppBrokerandClientLibraries" />1.1.1.&#160;
            Building the
            C++ Broker and Client Libraries
          </h3></div></div></div><p>
            The root directory for the C++ distribution is named
            qpidc-0.4. The README file in that directory gives
            instructions for building the broker and client libraries. In
            most cases you will do the following:
          </p><pre class="programlisting">
[qpidc-0.4]$ ./configure
[qpidc-0.4]$ make
</pre></div><div class="section" title="1.1.2.&#160; Running the C++ Broker"><div class="titlepage"><div><div><h3 class="title"><a id="RASC-RunningtheCppBroker" />1.1.2.&#160;
            Running the C++ Broker
          </h3></div></div></div><p>
            Once you have built the broker and client libraries, you can
            start the broker from the command line:
          </p><pre class="programlisting">
[qpidc-0.4]$ src/qpidd
</pre><p>
            Use the --daemon option to run the broker as a daemon
            process:
          </p><pre class="programlisting">
[qpidc-0.4]$ src/qpidd --daemon
</pre><p>
            You can stop a running daemon with the --quit option:
          </p><pre class="programlisting">
[qpidc-0.4]$ src/qpidd --quit
</pre><p>
            You can see all available options with the --help option
          </p><pre class="programlisting">
[qpidc-0.4]$ src/qpidd --help
</pre></div><div class="section" title="1.1.3.&#160; Most common questions getting qpidd running"><div class="titlepage"><div><div><h3 class="title"><a id="RASC-Mostcommonquestionsgettingqpiddrunning" />1.1.3.&#160;
            Most
            common questions getting qpidd running
          </h3></div></div></div><div class="section" title="1.1.3.1.&#160; Error when starting broker: &quot;no data directory&quot;"><div class="titlepage"><div><div><h4 class="title"><a id="RASC-Errorwhenstartingbroker-3A-22nodatadirectory-22" />1.1.3.1.&#160;
            Error
            when starting broker: "no data directory"
          </h4></div></div></div><p>
            The qpidd broker requires you to set a data directory or specify
            --no-data-dir (see help for more details). The data
            directory is used for the journal, so it is important when
            reliability counts. Make sure your process has write permission
            to the data directory.
          </p><p>
            The default location is
          </p><pre class="programlisting">
/lib/var/qpidd
</pre><p>
            An alternate location can be set with --data-dir
          </p></div><div class="section" title="1.1.3.2.&#160; Error when starting broker: &quot;that process is locked&quot;"><div class="titlepage"><div><div><h4 class="title"><a id="RASC-Errorwhenstartingbroker-3A-22thatprocessislocked-22" />1.1.3.2.&#160;
            Error
            when starting broker: "that process is locked"
          </h4></div></div></div><p>
            Note that when qpidd starts it creates a lock file is data
            directory are being used. If you have a un-controlled exit,
            please mail
            the trace from the core to the dev@qpid.apache.org mailing list.
            To clear the lock run
          </p><pre class="programlisting">
./qpidd -q
</pre><p>
            It should also be noted that multiple brokers can be run on the
            same host. To do so set alternate data directories for each qpidd
            instance.
          </p></div><div class="section" title="1.1.3.3.&#160; Using a configuration file"><div class="titlepage"><div><div><h4 class="title"><a id="RASC-Usingaconfigurationfile" />1.1.3.3.&#160;
            Using a configuration
            file
          </h4></div></div></div><p>
            Each option that can be specified on the command line can also be
            specified in a configuration file. To see available options, use
            --help on the command line:
          </p><pre class="programlisting">
./qpidd --help
</pre><p>
            A configuration file uses name/value pairs, one on each line. To
            convert a command line option to a configuration file entry:
          </p><p>
            a.) remove the '--' from the beginning of the option.
            b.) place a '=' between the option and the value (use
            <span class="emphasis"><em>yes</em></span> or <span class="emphasis"><em>true</em></span> to enable options that take no
            value when specified on the command line).
            c.) place one option per line.
          </p><p>
            For instance, the --daemon option takes no value, the
            --log-to-syslog option takes the values yes or
            no. The following configuration file sets these two
            options:
          </p><pre class="programlisting">
daemon=yes
log-to-syslog=yes
</pre></div><div class="section" title="1.1.3.4.&#160; Can I use any Language client with the C++ Broker?"><div class="titlepage"><div><div><h4 class="title"><a id="RASC-CanIuseanyLanguageclientwiththeCppBroker-3F" />1.1.3.4.&#160;
            Can I use
            any Language client with the C++ Broker?
          </h4></div></div></div><p>
            Yes, all the clients work with the C++ broker; it is written in
            C+<span class="emphasis"><em>, but uses the AMQP wire protocol. Any broker can be used
            with any client that uses the same AMQP version. When running the
            C</em></span>+ broker, it is highly recommended to run AMQP 0-10.
          </p><p>
            Note that JMS also works with the C++ broker.
          </p></div></div><div class="section" title="1.1.4.&#160; Authentication"><div class="titlepage"><div><div><h3 class="title"><a id="RASC-Authentication" />1.1.4.&#160;
            Authentication
          </h3></div></div></div><div class="section" title="1.1.4.1.&#160; Linux"><div class="titlepage"><div><div><h4 class="title"><a id="RASC-Linux" />1.1.4.1.&#160;
            Linux
          </h4></div></div></div><p>
            The PLAIN authentication is done on a username+password, which is
            stored in the sasldb_path file. Usernames and passwords can be
            added to the file using the command:
          </p><pre class="programlisting">
saslpasswd2 -f /var/lib/qpidd/qpidd.sasldb -u &lt;REALM&gt; &lt;USER&gt;
</pre><p>
            The REALM is important and should be the same as the
            --auth-realm
            option to the broker. This lets the broker properly find the user
            in
            the sasldb file.
          </p><p>
            Existing user accounts may be listed with:
          </p><pre class="programlisting">
sasldblistusers2 -f /var/lib/qpidd/qpidd.sasldb
</pre><p>
            NOTE: The sasldb file must be readable by the user running the
            qpidd daemon, and should be readable only by that user.
          </p></div><div class="section" title="1.1.4.2.&#160; Windows"><div class="titlepage"><div><div><h4 class="title"><a id="RASC-Windows" />1.1.4.2.&#160;
            Windows
          </h4></div></div></div><p>
            On Windows, the users are authenticated against the local
            machine. You should add the appropriate users using the standard
            Windows tools (Control Panel-&gt;User Accounts). To run many of
            the examples, you will need to create a user "guest" with
            password "guest".
          </p><p>
            If you cannot or do not want to create new users, you can run
            without authentication by specifying the no-auth option to the
            broker.
          </p></div></div><div class="section" title="1.1.5.&#160; Slightly more complex configuration"><div class="titlepage"><div><div><h3 class="title"><a id="RASC-Slightlymorecomplexconfiguration" />1.1.5.&#160;
            Slightly more
            complex configuration
          </h3></div></div></div><p>
            The easiest way to get a full listing of the broker's options are
            to use the --help command, run it locally for the latest set of
            options. These options can then be set in the conf file for
            convenience (see above)
          </p><pre class="programlisting">
./qpidd --help

Usage: qpidd OPTIONS
Options:
  -h [ --help ]                    Displays the help message
  -v [ --version ]                 Displays version information
  --config FILE (/etc/qpidd.conf)  Reads configuration from FILE

Module options:
  --module-dir DIR (/usr/lib/qpidd)  Load all .so modules in this directory
  --load-module FILE                 Specifies additional module(s) to be loaded
  --no-module-dir                    Don't load modules from module directory

Broker Options:
  --data-dir DIR (/var/lib/qpidd)   Directory to contain persistent data generated by the broker
  --no-data-dir                     Don't use a data directory.  No persistent
                                    configuration will be loaded or stored
  -p [ --port ] PORT (5672)         Tells the broker to listen on PORT
  --worker-threads N (3)            Sets the broker thread pool size
  --max-connections N (500)         Sets the maximum allowed connections
  --connection-backlog N (10)       Sets the connection backlog limit for the
                                    server socket
  --staging-threshold N (5000000)   Stages messages over N bytes to disk
  -m [ --mgmt-enable ] yes|no (1)   Enable Management
  --mgmt-pub-interval SECONDS (10)  Management Publish Interval
  --ack N (0)                       Send session.ack/solicit-ack at least every
                                    N frames. 0 disables voluntary ack/solitict
                                   -ack

Daemon options:
  -d [ --daemon ]             Run as a daemon.
  -w [ --wait ] SECONDS (10)  Sets the maximum wait time to initialize the
                              daemon. If the daemon fails to initialize, prints
                              an error and returns 1
  -c [ --check ]              Prints the daemon's process ID to stdout and
                              returns 0 if the daemon is running, otherwise
                              returns 1
  -q [ --quit ]               Tells the daemon to shut down
Logging options:
  --log-output FILE (stderr)  Send log output to FILE. FILE can be a file name
                              or one of the special values:
                              stderr, stdout, syslog
  -t [ --trace ]              Enables all logging
  --log-enable RULE (error+)  Enables logging for selected levels and component
                              s. RULE is in the form 'LEVEL+:PATTERN'
                              Levels are one of:
                              trace debug info notice warning error critical
                              For example:
                              '--log-enable warning+' logs all warning, error
                              and critical messages.
                              '--log-enable debug:framing' logs debug messages
                              from the framing namespace. This option can be
                              used multiple times
  --log-time yes|no (1)       Include time in log messages
  --log-level yes|no (1)      Include severity level in log messages
  --log-source yes|no (0)     Include source file:line in log messages
  --log-thread yes|no (0)     Include thread ID in log messages
  --log-function yes|no (0)   Include function signature in log messages
</pre></div><div class="section" title="1.1.6.&#160; Loading extra modules"><div class="titlepage"><div><div><h3 class="title"><a id="RASC-Loadingextramodules" />1.1.6.&#160;
            Loading extra modules
          </h3></div></div></div><p>
            By default the broker will load all the modules in the module
            directory, however it will NOT display options for modules that
            are not loaded. So to see the options for extra modules loaded
            you need to load the module and then add the help command like
            this:
          </p><pre class="programlisting">
./qpidd --load-module libbdbstore.so --help
Usage: qpidd OPTIONS
Options:
  -h [ --help ]                    Displays the help message
  -v [ --version ]                 Displays version information
  --config FILE (/etc/qpidd.conf)  Reads configuration from FILE


 / .... non module options would be here ... /


Store Options:
  --store-directory DIR     Store directory location for persistence (overrides
                            --data-dir)
  --store-async yes|no (1)  Use async persistence storage - if store supports
                            it, enables AIO O_DIRECT.
  --store-force yes|no (0)  Force changing modes of store, will delete all
                            existing data if mode is changed. Be SURE you want
                            to do this!
  --num-jfiles N (8)        Number of files in persistence journal
  --jfile-size-pgs N (24)   Size of each journal file in multiples of read
                            pages (1 read page = 64kiB)
</pre></div><div class="section" title="1.1.7.&#160;Timestamping Received Messages"><div class="titlepage"><div><div><h3 class="title"><a id="RASC-message-timestamps" />1.1.7.&#160;Timestamping Received Messages</h3></div></div></div><p>
    The AMQP 0-10 specification defines a <span class="emphasis"><em>timestamp</em></span> message delivery
    property. The timestamp delivery property is a <span class="emphasis"><em>datetime</em></span> value
    that is written to each message that arrives at the broker.  See the description of
    "message.delivery-properties" in the "Command Classes" section of the AMQP 0-10
    specification for more detail.
  </p><p>
    See the <span class="emphasis"><em>Programming in Apache Qpid</em></span> documentation for
    information regarding how clients may access the timestamp value in received
    messages.
  </p><p>
    By default, this timestamping feature is disabled.  To enable timestamping, use the
    <span class="emphasis"><em>enable-timestamp</em></span> broker configuration option.  Setting the
    enable-timestamp option to 'yes' will enable message timestamping:
  </p><pre class="programlisting">
./qpidd --enable-timestamp yes
  </pre><p>
    Message timestamping can also be enabled (and disabled) without restarting the broker.
    The QMF Broker management object defines two methods for accessing the timestamp
    configuration:
  </p><div class="table"><a id="idp26828544" /><p class="title"><strong>Table&#160;1.1.&#160;QMF Management - Broker Methods for Managing the Timestamp Configuration</strong></p><div class="table-contents"><table border="1" summary="QMF Management - Broker Methods for Managing the Timestamp Configuration"><colgroup><col /><col /></colgroup><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody><tr><td>getTimestampConfig</td><td>Get the message timestamping configuration.  Returns True if received messages are timestamped.</td></tr><tr><td>setTimestampConfig</td><td>Set the message timestamping configuration. Set True to enable timestamping received messages, False to disable timestamping.</td></tr></tbody></table></div></div><br class="table-break" /><div class="example"><a id="idp26835344" /><p class="title"><strong>Example&#160;1.1.&#160;Enabling Message Timestamping via QMF - Python</strong></p><div class="example-contents"><p>
      The following code fragment uses these QMF method calls to enable message timestamping.
    </p><pre class="programlisting" lang="python" xml:lang="python">
# get the state of the timestamp configuration
broker = self.qmf.getObjects(_class="broker")[0]
rc = broker.getTimestampConfig()
self.assertEqual(rc.status, 0)
self.assertEqual(rc.text, "OK")
print("The timestamp setting is %s" % str(rc.receive))

# try to enable it
rc = broker.setTimestampConfig(True)
self.assertEqual(rc.status, 0)
self.assertEqual(rc.text, "OK")
    </pre></div></div><br class="example-break" /></div></div><div class="section" title="1.2.&#160; Cheat Sheet for configuring Queue Options"><div class="titlepage"><div><div><h2 class="title"><a id="idp26767520" />1.2.&#160;
      Cheat Sheet for configuring Queue Options
    </h2></div></div></div><div class="section" title="1.2.1.&#160; Configuring Queue Options"><div class="titlepage"><div><div><h3 class="title"><a id="CheatSheetforconfiguringQueueOptions-ConfiguringQueueOptions" />1.2.1.&#160;
            Configuring
            Queue Options
          </h3></div></div></div><p>
            The C++ Broker M4 or later supports the following additional
            Queue constraints.
          </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>
                <a class="xref" href="#CheatSheetforconfiguringQueueOptions-ConfiguringQueueOptions" title="1.2.1.&#160; Configuring Queue Options">Section&#160;1.2.1, &#8220;
            Configuring
            Queue Options
          &#8221;</a>
              </p></li><li class="listitem"><p>
                </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>
                    <a class="xref" href="#CheatSheetforconfiguringQueueOptions-ApplyingQueueSizingConstraints" title="1.2.1.1.&#160; Applying Queue Sizing Constraints">Section&#160;1.2.1.1, &#8220;
            Applying Queue Sizing Constraints
          &#8221;</a>
                  </p></li><li class="listitem"><p>
                    <a class="xref" href="#CheatSheetforconfiguringQueueOptions-ChangingtheQueueorderingBehaviors-28FIFO-2FLVQ-29" title="1.2.1.2.&#160; Changing the Queue ordering Behaviors (FIFO/LVQ)">Section&#160;1.2.1.2, &#8220;
            Changing the Queue ordering Behaviors (FIFO/LVQ)
          &#8221;</a>
                  </p></li><li class="listitem"><p>
                    <a class="xref" href="#CheatSheetforconfiguringQueueOptions-Settingadditionalbehaviors" title="1.2.1.3.&#160; Setting additional behaviors">Section&#160;1.2.1.3, &#8220;
            Setting additional behaviors
          &#8221;</a>
                  </p></li><li class="listitem"><p>
                    </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>
                        <a class="xref" href="#CheatSheetforconfiguringQueueOptions-PersistLastNode" title="Persist Last Node">the section called &#8220;
            Persist
            Last Node
          &#8221;</a>
                      </p></li><li class="listitem"><p>
                        <a class="xref" href="#CheatSheetforconfiguringQueueOptions-Queueeventgeneration" title="Queue event generation">the section called &#8220;
            Queue
            event generation
          &#8221;</a>
                      </p></li></ul></div><p>
                  </p></li><li class="listitem"><p>
                    <a class="xref" href="#CheatSheetforconfiguringQueueOptions-OtherClients" title="1.2.1.4.&#160; Other Clients">Section&#160;1.2.1.4, &#8220;
            Other
            Clients
          &#8221;</a>
                  </p></li></ul></div><p>
              </p></li></ul></div><p>
            The 0.10 C++ Broker supports the following additional Queue configuration options:
          </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>
              <a class="xref" href="#producer-flow-control" title="1.8.&#160; Producer Flow Control">Section&#160;1.8, &#8220;
    Producer Flow Control
  &#8221;</a>
            </p></li></ul></div><div class="section" title="1.2.1.1.&#160; Applying Queue Sizing Constraints"><div class="titlepage"><div><div><h4 class="title"><a id="CheatSheetforconfiguringQueueOptions-ApplyingQueueSizingConstraints" />1.2.1.1.&#160;
            Applying Queue Sizing Constraints
          </h4></div></div></div><p>
            This allows to specify how to size a queue and what to do when
            the sizing constraints have been reached. The queue size can be
            limited by the number messages (message depth) or byte depth on
            the queue.
          </p><p>
            Once the Queue meets/ exceeds these constraints the follow
            policies can be applied
          </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>REJECT - Reject the published message
            </p></li><li class="listitem"><p>FLOW_TO_DISK - Flow the messages to disk, to preserve memory
            </p></li><li class="listitem"><p>RING - start overwriting messages in a ring based on sizing.
            If head meets tail, advance head
            </p></li><li class="listitem"><p>RING_STRICT - start overwriting messages in a ring based on
            sizing. If head meets tail, AND the consumer has the tail message
            acquired it will reject
            </p></li></ul></div><p>
            Examples:
          </p><p>
            Create a queue an auto delete queue that will support 100 000
            bytes, and then REJECT
          </p><pre class="programlisting">
#include "qpid/client/QueueOptions.h"

    QueueOptions qo;
    qo.setSizePolicy(REJECT,100000,0);

    session.queueDeclare(arg::queue=queue, arg::autoDelete=true, arg::arguments=qo);
</pre><p>
            Create a queue that will support 1000 messages into a RING buffer
          </p><pre class="programlisting">
#include "qpid/client/QueueOptions.h"

    QueueOptions qo;
    qo.setSizePolicy(RING,0,1000);

    session.queueDeclare(arg::queue=queue, arg::arguments=qo);
</pre></div><div class="section" title="1.2.1.2.&#160; Changing the Queue ordering Behaviors (FIFO/LVQ)"><div class="titlepage"><div><div><h4 class="title"><a id="CheatSheetforconfiguringQueueOptions-ChangingtheQueueorderingBehaviors-28FIFO-2FLVQ-29" />1.2.1.2.&#160;
            Changing the Queue ordering Behaviors (FIFO/LVQ)
          </h4></div></div></div><p>
            The default ordering in a queue in Qpid is FIFO. However
            additional ordering semantics can be used namely LVQ (Last Value
            Queue). Last Value Queue is define as follows.
          </p><p>
            If I publish symbols RHT, IBM, JAVA, MSFT, and then publish RHT
            before the consumer is able to consume RHT, that message will be
            over written in the queue and the consumer will receive the last
            published value for RHT.
          </p><p>
            Example:
          </p><pre class="programlisting">
#include "qpid/client/QueueOptions.h"

    QueueOptions qo;
    qo.setOrdering(LVQ);

    session.queueDeclare(arg::queue=queue, arg::arguments=qo);

    .....
    string key;
    qo.getLVQKey(key);

    ....
    for each message, set the into application headers before transfer
    message.getHeaders().setString(key,"RHT");
    
</pre><p>
            Notes:
          </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Messages that are dequeued and the re-queued will have the
            following exceptions. a.) if a new message has been queued with
            the same key, the re-queue from the consumer, will combine these
            two messages. b.) If an update happens for a message of the same
            key, after the re-queue, it will not update the re-queued
            message. This is done to protect a client from being able to
            adversely manipulate the queue.
            </p></li><li class="listitem"><p>Acquire: When a message is acquired from the queue, no matter
            it's position, it will behave the same as a dequeue
            </p></li><li class="listitem"><p>LVQ does not support durable messages. If the queue or
            messages are declared durable on an LVQ, the durability will be
            ignored.
            </p></li></ul></div><p>
            A fully worked <a class="xref" href="#LVQ-Example" title="1.6.3.&#160;LVQ Example">Section&#160;1.6.3, &#8220;LVQ Example&#8221;</a> can be found here
          </p></div><div class="section" title="1.2.1.3.&#160; Setting additional behaviors"><div class="titlepage"><div><div><h4 class="title"><a id="CheatSheetforconfiguringQueueOptions-Settingadditionalbehaviors" />1.2.1.3.&#160;
            Setting additional behaviors
          </h4></div></div></div><div class="section" title="Persist Last Node"><div class="titlepage"><div><div><h5 class="title"><a id="CheatSheetforconfiguringQueueOptions-PersistLastNode" />
            Persist
            Last Node
          </h5></div></div></div><p>
            This option is used in conjunction with clustering. It allows for
            a queue configured with this option to persist transient messages
            if the cluster fails down to the last node. If additional nodes
            in the cluster are restored it will stop persisting transient
            messages.
          </p><p>
            Note
          </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>if a cluster is started with only one active node, this mode
            will not be triggered. It is only triggered the first time the
            cluster fails down to 1 node.
            </p></li><li class="listitem"><p>The queue MUST be configured durable
            </p></li></ul></div><p>
            Example:
          </p><pre class="programlisting">
#include "qpid/client/QueueOptions.h"

    QueueOptions qo;
    qo.clearPersistLastNode();

    session.queueDeclare(arg::queue=queue, arg::durable=true, arg::arguments=qo);
</pre></div><div class="section" title="Queue event generation"><div class="titlepage"><div><div><h5 class="title"><a id="CheatSheetforconfiguringQueueOptions-Queueeventgeneration" />
            Queue
            event generation
          </h5></div></div></div><p>
            This option is used to determine whether enqueue/dequeue events
            representing changes made to queue state are generated. These
            events can then be processed by plugins such as that used for
            <a class="xref" href="#queue-state-replication" title="1.7.&#160; Queue State Replication">Section&#160;1.7, &#8220;
    Queue State Replication
  &#8221;</a>.
          </p><p>
            Example:
          </p><pre class="programlisting">
#include "qpid/client/QueueOptions.h"

    QueueOptions options;
    options.enableQueueEvents(1);
    session.queueDeclare(arg::queue="my-queue", arg::arguments=options);
</pre><p>
            The boolean option indicates whether only enqueue events should
            be generated. The key set by this is
            'qpid.queue_event_generation' and the value is and integer value
            of 1 (to replicate only enqueue events) or 2 (to replicate both
            enqueue and dequeue events).
          </p></div></div><div class="section" title="1.2.1.4.&#160; Other Clients"><div class="titlepage"><div><div><h4 class="title"><a id="CheatSheetforconfiguringQueueOptions-OtherClients" />1.2.1.4.&#160;
            Other
            Clients
          </h4></div></div></div><p>
            Note that these options can be set from any client. QueueOptions
            just correctly formats the arguments passed to the QueueDeclare()
            method.
          </p></div></div></div><div class="section" title="1.3.&#160; Cheat Sheet for configuring Exchange Options"><div class="titlepage"><div><div><h2 class="title"><a id="idp26745808" />1.3.&#160;
    Cheat Sheet for configuring Exchange Options
  </h2></div></div></div><div class="section" title="1.3.1.&#160; Configuring Exchange Options"><div class="titlepage"><div><div><h3 class="title"><a id="CheatSheetforconfiguringExchangeOptions-ConfiguringExchangeOptions" />1.3.1.&#160;
      Configuring Exchange Options
    </h3></div></div></div><p>
            The C++ Broker M4 or later supports the following additional
            Exchange options in addition to the standard AMQP define options
          </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Exchange Level Message sequencing
            </p></li><li class="listitem"><p>Initial Value Exchange
            </p></li></ul></div><p>
            Note that these features can be used on any exchange type, that
            has been declared with the options set.
          </p><p>
            It also supports an additional option to the bind operation on a
            direct exchange
          </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Exclusive binding for key
            </p></li></ul></div><div class="section" title="1.3.1.1.&#160; Exchange Level Message sequencing"><div class="titlepage"><div><div><h4 class="title"><a id="CheatSheetforconfiguringExchangeOptions-ExchangeLevelMessagesequencing" />1.3.1.1.&#160;
            Exchange Level Message sequencing
          </h4></div></div></div><p>
            This feature can be used to place a sequence number into each
            message's headers, based on the order they pass through an
            exchange. The sequencing starts at 0 and then wraps in an AMQP
            int64 type.
          </p><p>
            The field name used is "qpid.msg_sequence"
          </p><p>
            To use this feature an exchange needs to be declared specifying
            this option in the declare
          </p><pre class="programlisting">
....
    FieldTable args;
    args.setInt("qpid.msg_sequence",1);

...
    // now declare the exchange
    session.exchangeDeclare(arg::exchange="direct", arg::arguments=args);
</pre><p>
            Then each message passing through that exchange will be numbers
            in the application headers.
          </p><pre class="programlisting">
    unit64_t seqNo;
    //after message transfer
    seqNo = message.getHeaders().getAsInt64("qpid.msg_sequence");
</pre></div><div class="section" title="1.3.1.2.&#160; Initial Value Exchange"><div class="titlepage"><div><div><h4 class="title"><a id="CheatSheetforconfiguringExchangeOptions-InitialValueExchange" />1.3.1.2.&#160;
            Initial
            Value Exchange
          </h4></div></div></div><p>
            This feature caches a last message sent to an exchange. When a
            new binding is created onto the exchange it will then attempt to
            route this cached messaged to the queue, based on the binding.
            This allows for topics or the creation of configurations where a
            new consumer can receive the last message sent to the broker,
            with matching routing.
          </p><p>
            To use this feature an exchange needs to be declared specifying
            this option in the declare
          </p><pre class="programlisting">
....
    FieldTable args;
    args.setInt("qpid.ive",1);

...
    // now declare the exchange
    session.exchangeDeclare(arg::exchange="direct", arg::arguments=args);
</pre><p>
            now use the exchange in the same way you would use any other
            exchange.
          </p></div><div class="section" title="1.3.1.3.&#160; Exclusive binding for key"><div class="titlepage"><div><div><h4 class="title"><a id="CheatSheetforconfiguringExchangeOptions-Exclusivebindingforkey" />1.3.1.3.&#160;
            Exclusive
            binding for key
          </h4></div></div></div><p>
            Direct exchanges in qpidd support a qpid.exclusive-binding option
            on the bind operation that causes the binding specified to be the
            only one for the given key. I.e. if there is already a binding at
            this exchange with this key it will be atomically updated to bind
            the new queue. This means that the binding can be changed
            concurrently with an incoming stream of messages and each message
            will be routed to exactly one queue.
          </p><pre class="programlisting">
....
    FieldTable args;
    args.setInt("qpid.exclusive-binding",1);

    //the following will cause the only binding from amq.direct with 'my-key' 
    //to be the one to 'my-queue'; if there were any previous bindings for that
    //key they will be removed. This is atomic w.r.t message routing through the
    //exchange.
    session.exchangeBind(arg::exchange="amq.direct", arg::queue="my-queue",
                         arg::bindingKey="my-key", arg::arguments=args);

...
</pre></div></div></div><div class="section" title="1.4.&#160;Broker Federation"><div class="titlepage"><div><div><h2 class="title"><a id="chap-Messaging_User_Guide-Broker_Federation" />1.4.&#160;Broker Federation</h2></div></div></div><p>
		<em class="firstterm">Broker Federation</em> allows messaging networks to be defined by creating <em class="firstterm">message routes</em>, in which messages in one broker (the <em class="firstterm">source broker</em>) are automatically routed to another broker (the <em class="firstterm">destination broker</em>). These routes may be defined between exchanges in the two brokers (the <em class="firstterm">source exchange</em> and the <em class="firstterm">destination exchange</em>), or from a queue in the source broker (the <em class="firstterm">source queue</em>) to an exchange in the destination broker. Message routes are unidirectional; when bidirectional flow is needed, one route is created in each direction. Routes can be durable or transient. A durable route survives broker restarts, restoring a route as soon as both the source broker and the destination are available. If the connection to a destination is lost, messages associated with a durable route continue to accumulate on the source, so they can be retrieved when the connection is reestablished.
	</p><p>
		Broker Federation can be used to build large messaging networks, with many brokers, one route at a time. If network connectivity permits, an entire distributed messaging network can be configured from a single location. The rules used for routing can be changed dynamically as servers change, responsibilities change, at different times of day, or to reflect other changing conditions.
	</p><p>
		Broker Federation is useful in a wide variety of scenarios. Some of these have to do with functional organization; for instance, brokers may be organized by geography, service type, or priority. Here are some use cases for federation: 
		</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>
					Geography: Customer requests may be routed to a processing location close to the customer.
				</p></li><li class="listitem"><p>
					Service Type: High value customers may be routed to more responsive servers.
				</p></li><li class="listitem"><p>
					Load balancing: Routing among brokers may be changed dynamically to account for changes in actual or anticipated load.
				</p></li><li class="listitem"><p>
					High Availability: Routing may be changed to a new broker if an existing broker becomes unavailable.
				</p></li><li class="listitem"><p>
					WAN Connectivity: Federated routes may connect disparate locations across a wide area network, while clients connect to brokers on their own local area network. Each broker can provide persistent queues that can hold messages even if there are gaps in WAN connectivity.
				</p></li><li class="listitem"><p>
					Functional Organization: The flow of messages among software subsystems can be configured to mirror the logical structure of a distributed application.
				</p></li><li class="listitem"><p>
					Replicated Exchanges: High-function exchanges like the XML exchange can be replicated to scale performance.
				</p></li><li class="listitem"><p>
					Interdepartmental Workflow: The flow of messages among brokers can be configured to mirror interdepartmental workflow at an organization.
				</p></li></ul></div><p>

	</p><div class="section" title="1.4.1.&#160;Message Routes"><div class="titlepage"><div><div><h3 class="title"><a id="sect-Messaging_User_Guide-Broker_Federation-Message_Routes" />1.4.1.&#160;Message Routes</h3></div></div></div><p>
			Broker Federation is done by creating message routes. The destination for a route is always an exchange on the destination broker. By default, a message route is created by configuring the destination broker, which then contacts the source broker to subscribe to the source queue. This is called a <em class="firstterm">pull route</em>. It is also possible to create a route by configuring the source broker, which then contacts the destination broker in order to send messages. This is called a <em class="firstterm">push route</em>, and is particularly useful when the destination broker may not be available at the time the messaging route is configured, or when a large number of routes are created with the same destination exchange.
		</p><p>
			The source for a route can be either an exchange or a queue on the source broker. If a route is between two exchanges, the routing criteria can be given explicitly, or the bindings of the destination exchange can be used to determine the routing criteria. To support this functionality, there are three kinds of message routes: queue routes, exchange routes, and dynamic exchange routes.
		</p><div class="section" title="1.4.1.1.&#160;Queue Routes"><div class="titlepage"><div><div><h4 class="title"><a id="sect-Messaging_User_Guide-Message_Routes-Queue_Routes" />1.4.1.1.&#160;Queue Routes</h4></div></div></div><p>
				<em class="firstterm">Queue Routes</em> route all messages from a source queue to a destination exchange. If message acknowledgement is enabled, messages are removed from the queue when they have been received by the destination exchange; if message acknowledgement is off, messages are removed from the queue when sent.
			</p></div><div class="section" title="1.4.1.2.&#160;Exchange Routes"><div class="titlepage"><div><div><h4 class="title"><a id="sect-Messaging_User_Guide-Message_Routes-Exchange_Routes" />1.4.1.2.&#160;Exchange Routes</h4></div></div></div><p>
				<em class="firstterm">Exchange routes</em> route messages from a source exchange to a destination exchange, using a binding key (which is optional for a fanout exchange).
			</p><p>
				Internally, creating an exchange route creates a private queue (auto-delete, exclusive) on the source broker to hold messages that are to be routed to the destination broker, binds this private queue to the source broker exchange, and subscribes the destination broker to the queue.
			</p></div><div class="section" title="1.4.1.3.&#160;Dynamic Exchange Routes"><div class="titlepage"><div><div><h4 class="title"><a id="sect-Messaging_User_Guide-Message_Routes-Dynamic_Exchange_Routes" />1.4.1.3.&#160;Dynamic Exchange Routes</h4></div></div></div><p>
				Dynamic exchange routes allow a client to create bindings to an exchange on one broker, and receive messages that satisfy the conditions of these bindings not only from the exchange to which the client created the binding, but also from other exchanges that are connected to it using dynamic exchange routes. If the client modifies the bindings for a given exchange, they are also modified for dynamic exchange routes associated with that exchange.
			</p><p>
				<em class="firstterm">Dynamic exchange routes</em> apply all the bindings of a destination exchange to a source exchange, so that any message that would match one of these bindings is routed to the destination exchange. If bindings are added or removed from the destination exchange, these changes are reflected in the dynamic exchange route -- when the destination broker creates a binding with a given binding key, this is reflected in the route, and when the destination broker drops a binding with a binding key, the route no longer incurs the overhead of transferring messages that match the binding key among brokers. If two exchanges have dynamic exchange routes to each other, then all bindings in each exchange are reflected in the dynamic exchange route of the other. In a dynamic exchange route, the source and destination exchanges must have the same exchange type, and they must have the same name; for instance, if the source exchange is a direct exchange, the destination exchange must also be a direct exchange, and the names must match.
			</p><p>
				Internally, dynamic exchange routes are implemented in the same way as exchange routes, except that the bindings used to implement dynamic exchange routes are modified if the bindings in the destination exchange change.
			</p><p>
				A dynamic exchange route is always a pull route. It can never be a push route.
			</p></div></div><div class="section" title="1.4.2.&#160;Federation Topologies"><div class="titlepage"><div><div><h3 class="title"><a id="sect-Messaging_User_Guide-Broker_Federation-Federation_Topologies" />1.4.2.&#160;Federation Topologies</h3></div></div></div><p>
			A federated network is generally a tree, star, or line, using bidirectional links (implemented as a pair of unidirectional links) between any two brokers. A ring topology is also possible, if only unidirectional links are used.
		</p><p>
			Every message transfer takes time. For better performance, you should minimize the number of brokers between the message origin and final destination. In most cases, tree or star topologies do this best.
		</p><p>
			For any pair of nodes A,B in a federated network, there should be only one path from A to B. If there is more than one path, message loops can cause duplicate message transmission and flood the federated network. The topologies discussed above do not have message loops. A ring topology with bidirectional links is one example of a topology that does cause this problem, because a given broker can receive the same message from two different brokers. Mesh topologies can also cause this problem.
		</p></div><div class="section" title="1.4.3.&#160;Federation among High Availability Message Clusters"><div class="titlepage"><div><div><h3 class="title"><a id="sect-Messaging_User_Guide-Broker_Federation-Federation_among_High_Availability_Message_Clusters" />1.4.3.&#160;Federation among High Availability Message Clusters</h3></div></div></div><p>
			Federation is generally used together with High Availability Message Clusters, using clusters to provide high availability on each LAN, and federation to route messages among the clusters. Because message state is replicated within a cluster, it makes little sense to define message routes between brokers in the same cluster.
		</p><p>
			To create a message route between two clusters, simply create a route between any one broker in the first cluster and any one broker in the second cluster. Each broker in a given cluster can use message routes defined for another broker in the same cluster. If the broker for which a message route is defined should fail, another broker in the same cluster can restore the message route.
		</p></div><div class="section" title="1.4.4.&#160;The qpid-route Utility"><div class="titlepage"><div><div><h3 class="title"><a id="sect-Messaging_User_Guide-Broker_Federation-The_qpid_route_Utility" />1.4.4.&#160;The qpid-route Utility</h3></div></div></div><p>
			<span class="command"><strong>qpid-route</strong></span> is a command line utility used to configure federated networks of brokers and to view the status and topology of networks. It can be used to configure routes among any brokers that <span class="command"><strong>qpid-route</strong></span> can connect to.
		</p><p>
			The syntax of <span class="command"><strong>qpid-route</strong></span> is as follows:
		</p><pre class="screen">
qpid-route [OPTIONS] dynamic add &lt;dest-broker&gt; &lt;src-broker&gt; &lt;exchange&gt; 
qpid-route [OPTIONS] dynamic del &lt;dest-broker&gt; &lt;src-broker&gt; &lt;exchange&gt;

qpid-route [OPTIONS] route add &lt;dest-broker&gt; &lt;src-broker&gt; &lt;exchange&gt; &lt;routing-key&gt; 
qpid-route [OPTIONS] route del &lt;dest-broker&gt; &lt;src-broker&gt; &lt;exchange&gt; &lt;routing-key&gt;

qpid-route [OPTIONS] queue add &lt;dest-broker&gt; &lt;src-broker&gt; &lt;dest-exchange&gt;  &lt;src-queue&gt;
qpid-route [OPTIONS] queue del &lt;dest-broker&gt; &lt;src-broker&gt; &lt;dest-exchange&gt;  &lt;src-queue&gt;

qpid-route [OPTIONS] list  [&lt;broker&gt;]
qpid-route [OPTIONS] flush [&lt;broker&gt;]    
qpid-route [OPTIONS] map   [&lt;broker&gt;]


qpid-route [OPTIONS] list connections [&lt;broker&gt;]
</pre><p>
			The syntax for <span class="command"><strong>broker</strong></span>, <span class="command"><strong>dest-broker</strong></span>, and <span class="command"><strong>src-broker</strong></span> is as follows:
		</p><pre class="screen">
[username/password@] hostname | ip-address [:&lt;port&gt;]
</pre><p>
			The following are all valid examples of the above syntax: <span class="command"><strong>localhost</strong></span>, <span class="command"><strong>10.1.1.7:10000</strong></span>, <span class="command"><strong>broker-host:10000</strong></span>, <span class="command"><strong>guest/guest@localhost</strong></span>.
		</p><p>
			These are the options for <span class="command"><strong>qpid-route</strong></span>:
		</p><div class="table"><a id="tabl-Messaging_User_Guide-The_qpid_route_Utility-qpid_route_options" /><p class="title"><strong>Table&#160;1.2.&#160;<span class="command">qpid-route</span> options</strong></p><div class="table-contents"><table border="1" summary="qpid-route options"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /></colgroup><tbody><tr><td align="left">
							<span class="command"><strong>-v</strong></span>
						</td><td align="left">
							Verbose output.
						</td></tr><tr><td align="left">
							<span class="command"><strong>-q</strong></span>
						</td><td align="left">
							Quiet output, will not print duplicate warnings.
						</td></tr><tr><td align="left">
							<span class="command"><strong>-d</strong></span>
						</td><td align="left">
							Make the route durable.
						</td></tr><tr><td align="left">
							<span class="command"><strong> --timeout N</strong></span>
						</td><td align="left">
							Maximum time to wait when qpid-route connects to a broker, in seconds. Default is 10 seconds.
						</td></tr><tr><td align="left">
							<span class="command"><strong>--ack N</strong></span>
						</td><td align="left">
							Acknowledge transfers of routed messages in batches of N. Default is 0 (no acknowledgements). Setting to 1 or greater enables acknowledgements; when using acknowledgements, values of N greater than 1 can significnantly improve performance, especially if there is significant network latency between the two brokers.
						</td></tr><tr><td align="left">
							<span class="command"><strong>-s [ --src-local ]</strong></span>
						</td><td align="left">
							Configure the route in the source broker (create a push route).
						</td></tr><tr><td align="left">
							<span class="command"><strong>-t &lt;transport&gt; [ --transport &lt;transport&gt;]</strong></span>
						</td><td align="left">
							Transport protocol to be used for the route. 
							<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>
										tcp (default)
									</p></li><li class="listitem"><p>
										ssl
									</p></li><li class="listitem"><p>
										rdma
									</p></li></ul></div>

						</td></tr></tbody></table></div></div><br class="table-break" /><div class="section" title="1.4.4.1.&#160;Creating and Deleting Queue Routes"><div class="titlepage"><div><div><h4 class="title"><a id="sect-Messaging_User_Guide-The_qpid_route_Utility-Creating_and_Deleting_Queue_Routes" />1.4.4.1.&#160;Creating and Deleting Queue Routes</h4></div></div></div><p>
				The syntax for creating and deleting queue routes is as follows:
			</p><pre class="screen">
qpid-route [OPTIONS] queue add &lt;dest-broker&gt; &lt;src-broker&gt; &lt;dest-exchange&gt; &lt;src-queue&gt;
qpid-route [OPTIONS] queue del &lt;dest-broker&gt; &lt;src-broker&gt; &lt;dest-exchange&gt; &lt;src-queue&gt;
</pre><p>
				For instance, the following creates a queue route that routes all messages from the queue named <span class="command"><strong>public</strong></span> on the source broker <span class="command"><strong>localhost:10002</strong></span> to the <span class="command"><strong>amq.fanout</strong></span> exchange on the destination broker <span class="command"><strong>localhost:10001</strong></span>:
			</p><pre class="screen">
$ qpid-route queue add localhost:10001 localhost:10002 amq.fanout public
</pre><p>
				If the <span class="command"><strong>-d</strong></span> option is specified, this queue route is persistent, and will be restored if one or both of the brokers is restarted:
			</p><pre class="screen">
$ qpid-route -d queue add localhost:10001 localhost:10002 amq.fanout public
</pre><p>
				The <span class="command"><strong>del</strong></span> command takes the same arguments as the <span class="command"><strong>add</strong></span> command. The following command deletes the queue route described above:
			</p><pre class="screen">
$ qpid-route queue del localhost:10001 localhost:10002 amq.fanout public
</pre></div><div class="section" title="1.4.4.2.&#160;Creating and Deleting Exchange Routes"><div class="titlepage"><div><div><h4 class="title"><a id="sect-Messaging_User_Guide-The_qpid_route_Utility-Creating_and_Deleting_Exchange_Routes" />1.4.4.2.&#160;Creating and Deleting Exchange Routes</h4></div></div></div><p>
				The syntax for creating and deleting exchange routes is as follows:
			</p><pre class="screen">
qpid-route [OPTIONS] route add &lt;dest-broker&gt; &lt;src-broker&gt; &lt;exchange&gt; &lt;routing-key&gt; 
qpid-route [OPTIONS] route del &lt;dest-broker&gt; &lt;src-broker&gt; &lt;exchange&gt; &lt;routing-key&gt;
qpid-route [OPTIONS] flush [&lt;broker&gt;]
</pre><p>
				For instance, the following creates an exchange route that routes messages that match the binding key <span class="command"><strong>global.#</strong></span> from the <span class="command"><strong>amq.topic</strong></span> exchange on the source broker <span class="command"><strong>localhost:10002</strong></span> to the <span class="command"><strong>amq.topic</strong></span> exchange on the destination broker <span class="command"><strong>localhost:10001</strong></span>:
			</p><pre class="screen">
$ qpid-route route add localhost:10001 localhost:10002 amq.topic global.#
</pre><p>
				In many applications, messages published to the destination exchange should also be routed to the source exchange. This is accomplished by creating a second exchange route, reversing the roles of the two exchanges:
			</p><pre class="screen">
$ qpid-route route add localhost:10002 localhost:10001 amq.topic global.#
</pre><p>
				If the <span class="command"><strong>-d</strong></span> option is specified, the exchange route is persistent, and will be restored if one or both of the brokers is restarted:
			</p><pre class="screen">
$ qpid-route -d route add localhost:10001 localhost:10002 amq.fanout public
</pre><p>
				The <span class="command"><strong>del</strong></span> command takes the same arguments as the <span class="command"><strong>add</strong></span> command. The following command deletes the first exchange route described above:
			</p><pre class="screen">
$ qpid-route route del localhost:10001 localhost:10002 amq.topic global.#
</pre></div><div class="section" title="1.4.4.3.&#160;Deleting all routes for a broker"><div class="titlepage"><div><div><h4 class="title"><a id="sect-Messaging_User_Guide-The_qpid_route_Utility-Deleting_all_routes_for_a_broker" />1.4.4.3.&#160;Deleting all routes for a broker</h4></div></div></div><p>
				Use the <span class="command"><strong>flush</strong></span> command to delete all routes for a given broker:
			</p><pre class="screen">
qpid-route [OPTIONS] flush [&lt;broker&gt;]
</pre><p>
				For instance, the following command deletes all routes for the broker <span class="command"><strong>localhost:10001</strong></span>:
			</p><pre class="screen">
$ qpid-route flush localhost:10001
</pre></div><div class="section" title="1.4.4.4.&#160;Creating and Deleting Dynamic Exchange Routes"><div class="titlepage"><div><div><h4 class="title"><a id="sect-Messaging_User_Guide-The_qpid_route_Utility-Creating_and_Deleting_Dynamic_Exchange_Routes" />1.4.4.4.&#160;Creating and Deleting Dynamic Exchange Routes</h4></div></div></div><p>
				The syntax for creating and deleting dynamic exchange routes is as follows:
			</p><pre class="screen">
qpid-route [OPTIONS] dynamic add &lt;dest-broker&gt; &lt;src-broker&gt; &lt;exchange&gt; 
qpid-route [OPTIONS] dynamic del &lt;dest-broker&gt; &lt;src-broker&gt; &lt;exchange&gt;
</pre><p>
				In the following examples, we will route messages from a topic exchange. We will create a new topic exchange and federate it so that we are not affected by other all clients that use the built-in <span class="command"><strong>amq.topic</strong></span> exchange. The following commands create a new topic exchange on each of two brokers:
			</p><pre class="screen">
$ qpid-config -a localhost:10003 add exchange topic fed.topic
$ qpid-config -a localhost:10004 add exchange topic fed.topic
</pre><p>
				Now let's create a dynamic exchange route that routes messages from the <span class="command"><strong>fed.topic</strong></span> exchange on the source broker <span class="command"><strong>localhost:10004</strong></span> to the <span class="command"><strong>fed.topic</strong></span> exchange on the destination broker <span class="command"><strong>localhost:10003</strong></span> if they match any binding on the destination broker's <span class="command"><strong>fed.topic</strong></span> exchange:
			</p><pre class="screen">
$ qpid-route dynamic add localhost:10003 localhost:10004 fed.topic
</pre><p>
				Internally, this creates a private autodelete queue on the source broker, and binds that queue to the <span class="command"><strong>fed.topic</strong></span> exchange on the source broker, using each binding associated with the <span class="command"><strong>fed.topic</strong></span> exchange on the destination broker.
			</p><p>
				In many applications, messages published to the destination exchange should also be routed to the source exchange. This is accomplished by creating a second dynamic exchange route, reversing the roles of the two exchanges:
			</p><pre class="screen">
$ qpid-route dynamic add localhost:10004 localhost:10003 fed.topic
</pre><p>
				If the <span class="command"><strong>-d</strong></span> option is specified, the exchange route is persistent, and will be restored if one or both of the brokers is restarted:
			</p><pre class="screen">
$ qpid-route -d dynamic add localhost:10004 localhost:10003 fed.topic
</pre><p>
				When an exchange route is durable, the private queue used to store messages for the route on the source exchange is also durable. If the connection between the brokers is lost, messages for the destination exchange continue to accumulate until it can be restored.
			</p><p>
				The <span class="command"><strong>del</strong></span> command takes the same arguments as the <span class="command"><strong>add</strong></span> command. The following command deletes the first exchange route described above:
			</p><pre class="screen">
$ qpid-route dynamic del localhost:10004 localhost:10003 fed.topic
</pre><p>
				Internally, this deletes the bindings on the source exchange for the the private queues associated with the message route.
			</p></div><div class="section" title="1.4.4.5.&#160;Viewing Routes"><div class="titlepage"><div><div><h4 class="title"><a id="sect-Messaging_User_Guide-The_qpid_route_Utility-Viewing_Routes" />1.4.4.5.&#160;Viewing Routes</h4></div></div></div><p>
				The <span class="command"><strong>route list</strong></span> command shows the routes associated with an individual broker. For instance, suppose we have created the following two routes:
			</p><pre class="screen">
$ qpid-route dynamic add localhost:10003 localhost:10004 fed.topic
$ qpid-route dynamic add localhost:10004 localhost:10003 fed.topic
</pre><p>
				We can now use <span class="command"><strong>route list</strong></span> to show all routes for the broker <span class="command"><strong>localhost:10003</strong></span>:
			</p><pre class="screen">
$ qpid-route route list localhost:10003
localhost:10003 localhost:10004 fed.topic &lt;dynamic&gt;
</pre><p>
				Note that this shows only one of the two routes we created, the route for which <span class="command"><strong>localhost:10003</strong></span> is a destination. If we want to see the route for which <span class="command"><strong>localhost:10004</strong></span> is a destination, we need to do another route list:
			</p><pre class="screen">
$ qpid-route route list localhost:10004
localhost:10004 localhost:10003 fed.topic &lt;dynamic&gt;
</pre><p>
				The <span class="command"><strong>route map</strong></span> command shows all routes associated with a broker, and recursively displays all routes for brokers involved in federation relationships with the given broker. For instance, here is the output for the two brokers configured above:
			</p><pre class="screen">
$ qpid-route route map localhost:10003

Finding Linked Brokers:
    localhost:10003... Ok
    localhost:10004... Ok

Dynamic Routes:

  Exchange fed.topic:
    localhost:10004 &lt;=&gt; localhost:10003

Static Routes:
  none found
</pre><p>
				Note that the two dynamic exchange links are displayed as though they were one bidirectional link. The <span class="command"><strong>route map</strong></span> command is particularly helpful for larger, more complex networks. Let's configure a somewhat more complex network with 16 dynamic exchange routes:
			</p><pre class="screen">
qpid-route dynamic add localhost:10001 localhost:10002 fed.topic
qpid-route dynamic add localhost:10002 localhost:10001 fed.topic

qpid-route dynamic add localhost:10003 localhost:10002 fed.topic
qpid-route dynamic add localhost:10002 localhost:10003 fed.topic

qpid-route dynamic add localhost:10004 localhost:10002 fed.topic
qpid-route dynamic add localhost:10002 localhost:10004 fed.topic

qpid-route dynamic add localhost:10002 localhost:10005 fed.topic
qpid-route dynamic add localhost:10005 localhost:10002 fed.topic

qpid-route dynamic add localhost:10005 localhost:10006 fed.topic
qpid-route dynamic add localhost:10006 localhost:10005 fed.topic

qpid-route dynamic add localhost:10006 localhost:10007 fed.topic
qpid-route dynamic add localhost:10007 localhost:10006 fed.topic

qpid-route dynamic add localhost:10006 localhost:10008 fed.topic
qpid-route dynamic add localhost:10008 localhost:10006 fed.topic
</pre><p>
				Now we can use <span class="command"><strong>route map</strong></span> starting with any one broker, and see the entire network:
			</p><pre class="screen">
$ ./qpid-route route map localhost:10001

Finding Linked Brokers:
    localhost:10001... Ok
    localhost:10002... Ok
    localhost:10003... Ok
    localhost:10004... Ok
    localhost:10005... Ok
    localhost:10006... Ok
    localhost:10007... Ok
    localhost:10008... Ok

Dynamic Routes:

  Exchange fed.topic:
    localhost:10002 &lt;=&gt; localhost:10001
    localhost:10003 &lt;=&gt; localhost:10002
    localhost:10004 &lt;=&gt; localhost:10002
    localhost:10005 &lt;=&gt; localhost:10002
    localhost:10006 &lt;=&gt; localhost:10005
    localhost:10007 &lt;=&gt; localhost:10006
    localhost:10008 &lt;=&gt; localhost:10006

Static Routes:
  none found
</pre></div><div class="section" title="1.4.4.6.&#160;Resilient Connections"><div class="titlepage"><div><div><h4 class="title"><a id="sect-Messaging_User_Guide-The_qpid_route_Utility-Resilient_Connections" />1.4.4.6.&#160;Resilient Connections</h4></div></div></div><p>
				When a broker route is created, or when a durable broker route is restored after broker restart, a connection is created between the source broker and the destination broker. The connections used between brokers are called <em class="firstterm">resilient connections</em>; if the connection fails due to a communication error, it attempts to reconnect. The retry interval begins at 2 seconds and, as more attempts are made, grows to 64 seconds, and continues to retry every 64 seconds thereafter. If the connection fails due to an authentication problem, it will not continue to retry.
			</p><p>
				The command <span class="command"><strong>list connections</strong></span> can be used to show the resilient connections for a broker:
			</p><pre class="screen">
$ qpid-route list connections localhost:10001

Host            Port    Transport Durable  State             Last Error
=============================================================================
localhost       10002   tcp          N     Operational       
localhost       10003   tcp          N     Operational       
localhost       10009   tcp          N     Waiting           Connection refused
</pre><p>
				In the above output, <span class="command"><strong>Last Error</strong></span> contains the string representation of the last connection error received for the connection. <span class="command"><strong>State</strong></span> represents the state of the connection, and may be one of the following values:
			</p><div class="table"><a id="tabl-Messaging_User_Guide-Resilient_Connections-State_values_in_qpid_route_list_connections" /><p class="title"><strong>Table&#160;1.3.&#160;State values in <span class="command">$ qpid-route list connections</span></strong></p><div class="table-contents"><table border="1" summary="State values in $ qpid-route list connections"><colgroup><col /><col /></colgroup><tbody><tr><td align="left">
								Waiting
							</td><td align="left">
								Waiting before attempting to reconnect.
							</td></tr><tr><td align="left">
								Connecting
							</td><td align="left">
								Attempting to establish the connection.
							</td></tr><tr><td align="left">
								Operational
							</td><td align="left">
								The connection has been established and can be used.
							</td></tr><tr><td align="left">
								Failed
							</td><td align="left">
								The connection failed and will not retry (usually because authentication failed).
							</td></tr><tr><td align="left">
								Closed
							</td><td align="left">
								The connection has been closed and will soon be deleted.
							</td></tr><tr><td align="left">
								Passive
							</td><td align="left">
								If a cluster is federated to another cluster, only one of the nodes has an actual connection to remote node. Other nodes in the cluster have a passive connection.
							</td></tr></tbody></table></div></div><br class="table-break" /></div></div></div><div class="section" title="1.5.&#160;Security"><div class="titlepage"><div><div><h2 class="title"><a id="chap-Messaging_User_Guide-Security" />1.5.&#160;Security</h2></div></div></div><p>
		This chapter describes how authentication, rule-based authorization, encryption, and digital signing can be accomplished using Qpid. Authentication is the process of verifying the identity of a user; in Qpid, this is done using the SASL framework. Rule-based authorization is a mechanism for specifying the actions that each user is allowed to perform; in Qpid, this is done using an Access Control List (ACL) that is part of the Qpid broker. Encryption is used to ensure that data is not transferred in a plain-text format that could be intercepted and read. Digital signatures provide proof that a given message was sent by a known sender. Encryption and signing are done using SSL (they can also be done using SASL, but SSL provides stronger encryption).
	</p><div class="section" title="1.5.1.&#160;User Authentication"><div class="titlepage"><div><div><h3 class="title"><a id="sect-Messaging_User_Guide-Security-User_Authentication" />1.5.1.&#160;User Authentication</h3></div></div></div><p>
			AMQP uses Simple Authentication and Security Layer (SASL) to authenticate client connections to the broker. SASL is a framework that supports a variety of authentication methods. For secure applications, we suggest <span class="command"><strong>CRAM-MD5</strong></span>, <span class="command"><strong>DIGEST-MD5</strong></span>, or <span class="command"><strong>GSSAPI</strong></span>. The <span class="command"><strong>ANONYMOUS</strong></span> method is not secure. The <span class="command"><strong>PLAIN</strong></span> method is secure only when used together with SSL.
		</p><p>
			Both the Qpid broker and Qpid clients use the <a class="ulink" href="http://cyrusimap.web.cmu.edu/" target="_top">Cyrus SASL library</a>, a full-featured authentication framework, which offers many configuration options. This section shows how to configure users for authentication with SASL, which is sufficient when using <span class="command"><strong>SASL PLAIN</strong></span>. If you are not using SSL, you should configure SASL to use <span class="command"><strong>CRAM-MD5</strong></span>, <span class="command"><strong>DIGEST-MD5</strong></span>, or <span class="command"><strong>GSSAPI</strong></span> (which provides Kerberos authentication). For information on configuring these and other options in SASL, see the Cyrus SASL documentation.
		</p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;" title="Important"><h3 class="title">Important</h3><p>
				The <span class="command"><strong>SASL PLAIN</strong></span> method sends passwords in cleartext, and is vulnerable to man-in-the-middle attacks unless SSL (Secure Socket Layer) is also used (see <a class="xref" href="#sect-Messaging_User_Guide-Security-Encryption_using_SSL" title="1.5.4.&#160;Encryption using SSL">Section&#160;1.5.4, &#8220;Encryption using SSL&#8221;</a>).
			</p><p>
				If you are not using SSL, we recommend that you disable <span class="command"><strong>PLAIN</strong></span> authentication in the broker.
			</p></div><p>
			The Qpid broker uses the <span class="command"><strong>auth yes|no</strong></span> option to determine whether to use SASL authentication. Turn on authentication by setting <span class="command"><strong>auth</strong></span> to <span class="command"><strong>yes</strong></span> in <code class="filename">/etc/qpidd.conf</code>:
		</p><pre class="programlisting">
# /etc/qpidd.conf
#
# Set auth to 'yes' or 'no'

auth=yes
</pre><div class="section" title="1.5.1.1.&#160;Configuring SASL"><div class="titlepage"><div><div><h4 class="title"><a id="sect-Messaging_User_Guide-User_Authentication-Configuring_SASL" />1.5.1.1.&#160;Configuring SASL</h4></div></div></div><p>
				On Linux systems, the SASL configuration file is generally found in <code class="filename">/etc/sasl2/qpidd.conf</code> or <code class="filename">/usr/lib/sasl2/qpidd.conf</code>.
			</p><p>
				The SASL database contains user names and passwords for SASL. In SASL, a user may be associated with a <em class="firstterm">realm</em>. The Qpid broker authenticates users in the <span class="command"><strong>QPID</strong></span> realm by default, but it can be set to a different realm using the <span class="command"><strong>realm</strong></span> option:
			</p><pre class="programlisting">
# /etc/qpidd.conf
#
# Set the SASL realm using 'realm='

auth=yes
realm=QPID
</pre><p>
				The SASL database is installed at <code class="filename">/var/lib/qpidd/qpidd.sasldb</code>; initially, it has one user named <span class="command"><strong>guest</strong></span> in the <span class="command"><strong>QPID</strong></span> realm, and the password for this user is <span class="command"><strong>guest</strong></span>.
			</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;" title="Note"><h3 class="title">Note</h3><p>
					The user database is readable only by the <code class="systemitem">qpidd</code> user. When run as a daemon, Qpid always runs as the <code class="systemitem">qpidd</code> user. If you start the broker from a user other than the <code class="systemitem">qpidd</code> user, you will need to either reconfigure SASL or turn authentication off.
				</p></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;" title="Important"><h3 class="title">Important</h3><p>
					The SASL database stores user names and passwords in plain text. If it is compromised so are all of the passwords that it stores. This is the reason that the <code class="systemitem">qpidd</code> user is the only user that can read the database. If you modify permissions, be careful not to expose the SASL database.
				</p></div><p>
				Add new users to the database by using the <span class="command"><strong>saslpasswd2</strong></span> command, which specifies a realm and a user ID. A user ID takes the form <span class="command"><strong><em class="replaceable"><code>user-id</code></em>@<em class="replaceable"><code>domain</code></em>.</strong></span>.
			</p><pre class="screen"># saslpasswd2 -f /var/lib/qpidd/qpidd.sasldb -u <em class="replaceable"><code>realm</code></em> <em class="replaceable"><code>new_user_name</code></em></pre><p>
				To list the users in the SASL database, use <span class="command"><strong>sasldblistusers2</strong></span>:
			</p><pre class="screen"># sasldblistusers2 -f /var/lib/qpidd/qpidd.sasldb
</pre><p>
				If you are using <span class="command"><strong>PLAIN</strong></span> authentication, users who are in the database can now connect with their user name and password. This is secure only if you are using SSL. If you are using a more secure form of authentication, please consult your SASL documentation for information on configuring the options you need.
			</p></div><div class="section" title="1.5.1.2.&#160;Kerberos"><div class="titlepage"><div><div><h4 class="title"><a id="sect-Messaging_User_Guide-User_Authentication-Kerberos" />1.5.1.2.&#160;Kerberos</h4></div></div></div><p>
				Both the Qpid broker and Qpid users are 'principals' of the Kerberos server, which means that they are both clients of the Kerberos authentication services.
			</p><p>
				To use Kerberos, both the Qpid broker and each Qpid user must be authenticated on the Kerberos server:
			</p><div class="procedure"><ol class="procedure" type="1"><li class="step" title="Step 1"><p>
						Install the Kerberos workstation software and Cyrus SASL GSSAPI on each machine that runs a qpidd broker or a qpidd messaging client:
					</p><pre class="screen">$ sudo yum install cyrus-sasl-gssapi krb5-workstation</pre></li><li class="step" title="Step 2"><p>
						Make sure that the Qpid broker is registered in the Kerberos database.
					</p><p>
						Traditionally, a Kerberos principal is divided into three parts: the primary, the instance, and the realm. A typical Kerberos V5 has the format <code class="literal">primary/instance@REALM</code>. For a Qpid broker, the primary is <code class="literal">qpidd</code>, the instance is the fully qualified domain name, which you can obtain using <span class="command"><strong>hostname --fqdn</strong></span>, and the REALM is the Kerberos domain realm. By default, this realm is <code class="literal">QPID</code>, but a different realm can be specified in qpid.conf, e.g.:
</p><pre class="screen">realm=EXAMPLE.COM</pre><p>

					</p><p>
						For instance, if the fully qualified domain name is <code class="literal">dublduck.example.com</code> and the Kerberos domain realm is <code class="literal">EXAMPLE.COM</code>, then the principal name is <code class="literal">qpidd/dublduck.example.com@EXAMPLE.COM</code>.
					</p><p>
						The following script creates a principal for qpidd:
					</p><pre class="programlisting">
FDQN=`hostname --fqdn`
REALM="EXAMPLE.COM"
kadmin -r $REALM  -q "addprinc -randkey -clearpolicy qpidd/$FQDN"
</pre><p>
						Now create a Kerberos keytab file for the Qpid broker. The Qpid broker must have read access to the keytab file. The following script creates a keytab file and allows the broker read access:
					</p><pre class="programlisting">
QPIDD_GROUP="qpidd"
kadmin -r $REALM  -q "ktadd -k /etc/qpidd.keytab qpidd/$FQDN@$REALM"
chmod g+r /etc/qpidd.keytab
chgrp $QPIDD_GROUP /etc/qpidd.keytab
</pre><p>
						The default location for the keytab file is <code class="filename">/etc/krb5.keytab</code>. If a different keytab file is used, the KRB5_KTNAME environment variable must contain the name of the file, e.g.:
					</p><pre class="programlisting">
export KRB5_KTNAME=/etc/qpidd.keytab
</pre><p>
						If this is correctly configured, you can now enable kerberos support on the Qpid broker by setting the <code class="varname">auth</code> and <code class="varname">realm</code> options in <code class="filename">/etc/qpidd.conf</code>:
					</p><pre class="programlisting">
# /etc/qpidd.conf
auth=yes
realm=EXAMPLE.COM
</pre><p>
						Restart the broker to activate these settings.
					</p></li><li class="step" title="Step 3"><p>
						Make sure that each Qpid user is registered in the Kerberos database, and that Kerberos is correctly configured on the client machine. The Qpid user is the account from which a Qpid messaging client is run. If it is correctly configured, the following command should succeed:
					</p><pre class="screen">$ kinit user@REALM.COM</pre></li></ol></div><p>
				Java JMS clients require a few additional steps.
			</p><div class="procedure"><ol class="procedure" type="1"><li class="step" title="Step 1"><p>
						The Java JVM must be run with the following arguments:
					</p><div class="variablelist"><dl><dt><span class="term">-Djavax.security.auth.useSubjectCredsOnly=false</span></dt><dd><p>
									Forces the SASL GASSPI client to obtain the kerberos credentials explicitly instead of obtaining from the "subject" that owns the current thread.
								</p></dd><dt><span class="term">-Djava.security.auth.login.config=myjas.conf</span></dt><dd><p>
									Specifies the jass configuration file. Here is a sample JASS configuration file:
								</p><pre class="programlisting">
com.sun.security.jgss.initiate {
    com.sun.security.auth.module.Krb5LoginModule required useTicketCache=true;
};
</pre></dd><dt><span class="term">-Dsun.security.krb5.debug=true</span></dt><dd><p>
									Enables detailed debug info for troubleshooting
								</p></dd></dl></div></li><li class="step" title="Step 2"><p>
						The client's Connection URL must specify the following Kerberos-specific broker properties:
					</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>
								<code class="varname">sasl_mechs</code> must be set to <code class="literal">GSSAPI</code>.
							</p></li><li class="listitem"><p>
								<code class="varname">sasl_protocol</code> must be set to the principal for the qpidd broker, e.g. <code class="literal">qpidd</code>/
							</p></li><li class="listitem"><p>
								<code class="varname">sasl_server</code> must be set to the host for the SASL server, e.g. <code class="literal">sasl.com</code>.
							</p></li></ul></div><p>
						Here is a sample connection URL for a Kerberos connection:
					</p><pre class="screen">amqp://guest@clientid/testpath?brokerlist='tcp://localhost:5672?sasl_mechs='GSSAPI'&amp;sasl_protocol='qpidd'&amp;sasl_server='&lt;server-host-name&gt;''</pre></li></ol></div></div></div><div class="section" title="1.5.2.&#160;Authorization"><div class="titlepage"><div><div><h3 class="title"><a id="sect-Messaging_User_Guide-Security-Authorization" />1.5.2.&#160;Authorization</h3></div></div></div><p>
		   In Qpid, Authorization specifies which actions can be performed by each authenticated user using an Access Control List (ACL). 
		 </p><p>
		   Use the <span class="command"><strong>--acl-file</strong></span> command to load the access control list. The filename should have a <code class="filename">.acl</code> extension:
		</p><pre class="screen">
    $ qpidd --acl-file <em class="replaceable"><code>./aclfilename.acl</code></em></pre><p>
			Each line in an ACL file grants or denies specific rights to a user. If the last line in an ACL file is <code class="literal">acl deny all all</code>, the ACL uses <em class="firstterm">deny mode</em>, and only those rights that are explicitly allowed are granted:
		</p><pre class="programlisting">
    acl allow rajith@QPID all all
    acl deny all all
</pre><p>
			On this server, <code class="literal">rajith@QPID</code> can perform any action, but nobody else can. Deny mode is the default, so the previous example is equivalent to the following ACL file:
		</p><pre class="programlisting">
    acl allow rajith@QPID all all
</pre><p>
		   Alternatively the ACL file may use <em class="firstterm">allow mode</em> by placing:
		</p><pre class="programlisting">
    acl allow all all
</pre><p>
			as the final line in the ACL file. In <span class="emphasis"><em>allow mode</em></span> all actions by all users are allowed unless otherwise denied by specific ACL rules.
			The ACL rule which selects <span class="emphasis"><em>deny mode</em></span> or <span class="emphasis"><em>allow mode</em></span> must be the last line in the ACL rule file.
		</p><p>
			ACL syntax allows fine-grained access rights for specific actions:
		</p><pre class="programlisting">
    acl allow carlt@QPID create exchange name=carl.*
    acl allow fred@QPID create all
    acl allow all consume queue
    acl allow all bind exchange
    acl deny all all
</pre><p>
			An ACL file can define user groups, and assign permissions to them:
		</p><pre class="programlisting">
    group admin ted@QPID martin@QPID
    acl allow admin create all
    acl deny all all
</pre><p>
			An ACL file can define per user connection and queue quotas:
		</p><pre class="programlisting">
    group admin ted@QPID martin@QPID
    group blacklist usera@qpid userb@qpid
    quota connections 10 admin
    quota connections  5 all
    quota connections  0 blacklist
    quota queues      50 admin
    quota queues       5 all
    quota queues       1 test@qpid
</pre><p>
			Performance Note: Most ACL queries are performed infrequently. The overhead associated with 
			ACL passing an allow or deny decision on the creation of a queue is negligible
			compared to actually creating and using the queue. One notable exception is the <span class="command"><strong>publish exchange</strong></span>
			query. ACL files with no <span class="emphasis"><em>publish exchange</em></span> rules are noted and the broker short circuits the logic 
			associated with the per-messsage <span class="emphasis"><em>publish exchange</em></span> ACL query. 
			However, if an ACL file has any <span class="emphasis"><em>publish exchange</em></span> rules
			then the broker is required to perform a <span class="emphasis"><em>publish exchange</em></span> query for each message published.
			Users with performance critical applications are encouraged to structure exchanges, queues, and bindings so that
			the <span class="emphasis"><em>publish exchange</em></span> ACL rules are unnecessary.
		</p><div class="section" title="1.5.2.1.&#160;ACL Syntax"><div class="titlepage"><div><div><h4 class="title"><a id="sect-Messaging_User_Guide-Authorization-ACL_Syntax" />1.5.2.1.&#160;ACL Syntax</h4></div></div></div><p>
				ACL rules must be on a single line and follow this syntax:
</p><pre class="programlisting">
    user = username[/domain[@realm]]
    user-list = user1 user2 user3 ...
    group-name-list = group1 group2 group3 ...
    
    group &lt;group-name&gt; = [user-list] [group-name-list]
    
    permission = [allow | allow-log | deny | deny-log]
    action = [consume | publish | create | access | 
              bind | unbind | delete | purge | update]
    object = [queue | exchange | broker | link | method]
    property = [name | durable | owner | routingkey | 
                autodelete | exclusive |type | 
		alternate | queuename | 
		schemapackage | schemaclass | 
		queuemaxsizelowerlimit  | 
		queuemaxsizeupperlimit  |
                queuemaxcountlowerlimit | 
		queuemaxcountupperlimit |
                filemaxsizelowerlimit   | 
		filemaxsizeupperlimit   |
                filemaxcountlowerlimit  | 
		filemaxcountupperlimit ]
    
    acl permission {&lt;group-name&gt;|&lt;user-name&gt;|"all"} {action|"all"} [object|"all" 
                [property=&lt;property-value&gt; ...]]

    quota-spec = [connections | queues]
    quota quota-spec N {&lt;group-name&gt;|&lt;user-name&gt;|"all"}
                [{&lt;group-name&gt;|&lt;user-name&gt;|"all"}]
</pre><p>

				 ACL rules can also include a single object name (or the keyword <em class="parameter"><code>all</code></em>) and one or more property name value pairs in the form <span class="command"><strong>property=value</strong></span>
			</p><p>
				The following tables show the possible values for <span class="command"><strong>permission</strong></span>, <span class="command"><strong>action</strong></span>, <span class="command"><strong>object</strong></span>, and <span class="command"><strong>property</strong></span> in an ACL rules file.
			</p><div class="table"><a id="tabl-Messaging_User_Guide-ACL_Syntax-ACL_Rules_permission" /><p class="title"><strong>Table&#160;1.4.&#160;ACL Rules: permission</strong></p><div class="table-contents"><table border="1" summary="ACL Rules: permission"><colgroup><col /><col /></colgroup><tbody><tr><td>
								<span class="command"><strong>allow</strong></span>
							</td><td>
								<p>
									Allow the action 
								</p>

							</td></tr><tr><td>
								<span class="command"><strong>allow-log</strong></span>
							</td><td>
								<p>
									Allow the action and log the action in the event log
								</p>

							</td></tr><tr><td>
								<span class="command"><strong>deny</strong></span>
							</td><td>
								<p>
									Deny the action
								</p>

							</td></tr><tr><td>
								<span class="command"><strong>deny-log</strong></span>
							</td><td>
								<p>
									Deny the action and log the action in the event log
								</p>

							</td></tr></tbody></table></div></div><br class="table-break" /><div class="table"><a id="tabl-Messaging_User_Guide-ACL_Syntax-ACL_Rulesaction" /><p class="title"><strong>Table&#160;1.5.&#160;ACL Rules:action</strong></p><div class="table-contents"><table border="1" summary="ACL Rules:action"><colgroup><col /><col /></colgroup><tbody><tr><td>
								<span class="command"><strong>consume</strong></span>
							</td><td>
								<p>
									Applied when subscriptions are created
								</p>

							</td></tr><tr><td>
								<span class="command"><strong>publish</strong></span>
							</td><td>
								<p>
									Applied on a per message basis
									to verify that the user has rights to publish to the given
									exchange with the given routingkey. 
								</p>

							</td></tr><tr><td>
								<span class="command"><strong>create</strong></span>
							</td><td>
								<p>
									Applied when an object is created, such as bindings, queues, exchanges, links
								</p>

							</td></tr><tr><td>
								<span class="command"><strong>access</strong></span>
							</td><td>
								<p>
									Applied when an object is read or accessed
								</p>

							</td></tr><tr><td>
								<span class="command"><strong>bind</strong></span>
							</td><td>
								<p>
									Applied when objects are bound together
								</p>

							</td></tr><tr><td>
								<span class="command"><strong>unbind</strong></span>
							</td><td>
								<p>
									Applied when objects are unbound
								</p>

							</td></tr><tr><td>
								<span class="command"><strong>delete</strong></span>
							</td><td>
								<p>
									Applied when objects are deleted
								</p>

							</td></tr><tr><td>
								<span class="command"><strong>purge</strong></span>
							</td><td>
								<p>
									Similar to delete but the action is performed on more than one object
								</p>

							</td></tr><tr><td>
								<span class="command"><strong>update</strong></span>
							</td><td>
								<p>
									Applied when an object is updated
								</p>

							</td></tr></tbody></table></div></div><br class="table-break" /><div class="table"><a id="tabl-Messaging_User_Guide-ACL_Syntax-ACL_Rulesobject" /><p class="title"><strong>Table&#160;1.6.&#160;ACL Rules:object</strong></p><div class="table-contents"><table border="1" summary="ACL Rules:object"><colgroup><col /><col /></colgroup><tbody><tr><td>
								<span class="command"><strong>queue</strong></span>
							</td><td>
								<p>
									A queue
								</p>

							</td></tr><tr><td>
								<span class="command"><strong>exchange</strong></span>
							</td><td>
								<p>
									An exchange
								</p>

							</td></tr><tr><td>
								<span class="command"><strong>broker</strong></span>
							</td><td>
								<p>
									The broker
								</p>

							</td></tr><tr><td>
								<span class="command"><strong>link</strong></span>
							</td><td>
								<p>
									A federation or inter-broker link
								</p>

							</td></tr><tr><td>
								<span class="command"><strong>method</strong></span>
							</td><td>
								<p>
									Management or agent or broker method
								</p>

							</td></tr></tbody></table></div></div><br class="table-break" /><div class="table"><a id="tabl-Messaging_User_Guide-ACL_Syntax-ACL_Rulesproperty" /><p class="title"><strong>Table&#160;1.7.&#160;ACL Rules:property</strong></p><div class="table-contents"><table border="1" summary="ACL Rules:property"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>Property</th><th>Type</th><th>Description</th><th>Usage</th></tr></thead><tbody><tr><td> <span class="command"><strong>name</strong></span> </td><td>String</td><td>Object name, such as a queue name or exchange name.</td><td>&#160;</td></tr><tr><td> <span class="command"><strong>durable</strong></span> </td><td>Boolean</td><td>Indicates the object is durable</td><td>CREATE QUEUE, CREATE EXCHANGE, ACCESS QUEUE, ACCESS EXCHANGE</td></tr><tr><td> <span class="command"><strong>routingkey</strong></span> </td><td>String</td><td>Specifies routing key</td><td>BIND EXCHANGE, UNBIND EXCHANGE, ACCESS EXCHANGE, PUBLISH EXCHANGE</td></tr><tr><td> <span class="command"><strong>autodelete</strong></span> </td><td>Boolean</td><td>Indicates whether or not the object gets deleted when the connection is closed</td><td>CREATE QUEUE, ACCESS QUEUE</td></tr><tr><td> <span class="command"><strong>exclusive</strong></span> </td><td>Boolean</td><td>Indicates the presence of an <em class="parameter"><code>exclusive</code></em> flag</td><td>CREATE QUEUE, ACCESS QUEUE</td></tr><tr><td> <span class="command"><strong>type</strong></span> </td><td>String</td><td>Type of exchange, such as topic, fanout, or xml</td><td>CREATE EXCHANGE, ACCESS EXCHANGE</td></tr><tr><td> <span class="command"><strong>alternate</strong></span> </td><td>String</td><td>Name of the alternate exchange</td><td>CREATE EXCHANGE, CREATE QUEUE, ACCESS EXCHANGE, ACCESS QUEUE</td></tr><tr><td> <span class="command"><strong>queuename</strong></span> </td><td>String</td><td>Name of the queue</td><td>ACCESS EXCHANGE, BIND EXCHANGE, UNBIND EXCHANGE</td></tr><tr><td> <span class="command"><strong>schemapackage</strong></span> </td><td>String</td><td>QMF schema package name</td><td>ACCESS METHOD</td></tr><tr><td> <span class="command"><strong>schemaclass</strong></span> </td><td>String</td><td>QMF schema class name</td><td>ACCESS METHOD</td></tr><tr><td> <span class="command"><strong>queuemaxsizelowerlimit</strong></span> </td><td>Integer</td><td>Minimum value for queue.max_size (memory bytes)</td><td>CREATE QUEUE, ACCESS QUEUE</td></tr><tr><td> <span class="command"><strong>queuemaxsizeupperlimit</strong></span> </td><td>Integer</td><td>Maximum value for queue.max_size (memory bytes)</td><td>CREATE QUEUE, ACCESS QUEUE</td></tr><tr><td> <span class="command"><strong>queuemaxcountlowerlimit</strong></span> </td><td>Integer</td><td>Minimum value for queue.max_count (messages)</td><td>CREATE QUEUE, ACCESS QUEUE</td></tr><tr><td> <span class="command"><strong>queuemaxcountupperlimit</strong></span> </td><td>Integer</td><td>Maximum value for queue.max_count (messages)</td><td>CREATE QUEUE, ACCESS QUEUE</td></tr><tr><td> <span class="command"><strong>filemaxsizelowerlimit</strong></span> </td><td>Integer</td><td>Minimum value for file.max_size (64kb pages)</td><td>CREATE QUEUE, ACCESS QUEUE</td></tr><tr><td> <span class="command"><strong>filemaxsizeupperlimit</strong></span> </td><td>Integer</td><td>Maximum value for file.max_size (64kb pages)</td><td>CREATE QUEUE, ACCESS QUEUE</td></tr><tr><td> <span class="command"><strong>filemaxcountlowerlimit</strong></span> </td><td>Integer</td><td>Minimum value for file.max_count (files)</td><td>CREATE QUEUE, ACCESS QUEUE</td></tr><tr><td> <span class="command"><strong>filemaxcountupperlimit</strong></span> </td><td>Integer</td><td>Maximum value for file.max_count (files)</td><td>CREATE QUEUE, ACCESS QUEUE</td></tr></tbody></table></div></div><br class="table-break" /><div class="section" title="ACL Action-Object-Property Tuples"><div class="titlepage"><div><div><h5 class="title"><a id="sect-Messaging_User_Guide-Authorization-ACL_ActionObjectPropertyTuples" />ACL Action-Object-Property Tuples</h5></div></div></div><p>
			    Not every ACL action is applicable to every ACL object. Furthermore, not every property may be
			    specified for every action-object pair.
			    The following table enumerates which action and object pairs are allowed.
			    The table also lists which optional ACL properties are allowed to qualify 
			    action-object pairs.
			  </p><p>
			    The <span class="emphasis"><em>access</em></span> action is called with different argument 
			    lists for the <span class="emphasis"><em>exchange</em></span> and <span class="emphasis"><em>queue</em></span> objects.
			    A separate column shows the AMQP 0.10 method that the Access ACL rule is satisfying. 
			    Write separate rules with the additional arguments for the <span class="emphasis"><em>declare</em></span>
			    and <span class="emphasis"><em>bind</em></span> methods and include these rules in the ACL file
			    before the rules for the <span class="emphasis"><em>query</em></span> method.
			    
			  </p><div class="table"><a id="tabl-Messaging_User_Guide-ACL_Syntax-ACL_ActionObject_properties" /><p class="title"><strong>Table&#160;1.8.&#160;ACL Properties Allowed for each Action and Object</strong></p><div class="table-contents"><table border="1" summary="ACL Properties Allowed for each Action and Object"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>Action</th><th>Object</th><th>Properties</th><th>Method</th></tr></thead><tbody><tr><td>access</td><td>broker</td><td>&#160;</td><td class="auto-generated">&#160;</td></tr><tr><td>access</td><td>exchange</td><td>name type alternate durable</td><td>declare</td></tr><tr><td>access</td><td>exchange</td><td>name queuename routingkey</td><td>bound</td></tr><tr><td>access</td><td>exchange</td><td>name</td><td>query</td></tr><tr><td>access</td><td>method</td><td>name schemapackage schemaclass</td><td>&#160;</td></tr><tr><td>access</td><td>queue</td><td>name alternate durable exclusive autodelete policy queuemaxsizelowerlimit queuemaxsizeupperlimit queuemaxcountlowerlimit queuemaxcountupperlimit filemaxsizelowerlimit filemaxsizeupperlimit filemaxcountlowerlimit filemaxcountupperlimit</td><td>declare</td></tr><tr><td>access</td><td>queue</td><td>name</td><td>query</td></tr><tr><td>bind</td><td>exchange</td><td>name queuename routingkey</td><td>&#160;</td></tr><tr><td>consume</td><td>queue</td><td>name</td><td>&#160;</td></tr><tr><td>create</td><td>exchange</td><td>name type alternate durable</td><td>&#160;</td></tr><tr><td>create</td><td>link</td><td>name</td><td>&#160;</td></tr><tr><td>create</td><td>queue</td><td>name alternate durable exclusive autodelete policy queuemaxsizelowerlimit queuemaxsizeupperlimit queuemaxcountlowerlimit queuemaxcountupperlimit filemaxsizelowerlimit filemaxsizeupperlimit filemaxcountlowerlimit filemaxcountupperlimit</td><td>&#160;</td></tr><tr><td>delete</td><td>exchange</td><td>name</td><td>&#160;</td></tr><tr><td>delete</td><td>queue</td><td>name</td><td>&#160;</td></tr><tr><td>publish</td><td>exchange</td><td>name routingkey</td><td>&#160;</td></tr><tr><td>purge</td><td>queue</td><td>name</td><td>&#160;</td></tr><tr><td>unbind</td><td>exchange</td><td>name queuename routingkey</td><td>&#160;</td></tr><tr><td>update</td><td>broker</td><td>&#160;</td><td>&#160;</td></tr></tbody></table></div></div><br class="table-break" /><p>

			  </p></div></div><div class="section" title="1.5.2.2.&#160;ACL Syntactic Conventions"><div class="titlepage"><div><div><h4 class="title"><a id="sect-Messaging_User_Guide-Authorization-ACL_Syntactic_Conventions" />1.5.2.2.&#160;ACL Syntactic Conventions</h4></div></div></div><div class="section" title="Comments"><div class="titlepage"><div><div><h5 class="title"><a id="sect-Messaging_User_Guide-Authorization-ACL_Syntactic_Conventions-comments" />Comments</h5></div></div></div><p>
			    </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>
				  A line starting with the <span class="command"><strong>#</strong></span> character is considered a comment and is ignored.
				</p></li><li class="listitem"><p>
				  Embedded comments and trailing comments are not allowed. The <span class="command"><strong>#</strong></span> is commonly found in routing keys and other AMQP literals which occur naturally in ACL rule specifications. 
				</p></li></ul></div><p>
			  </p></div><div class="section" title="White Space"><div class="titlepage"><div><div><h5 class="title"><a id="sect-Messaging_User_Guide-Authorization-ACL_Syntactic_Conventions-whitespace" />White Space</h5></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>
				Empty lines and lines that contain only whitespace (' ', '\f', '\n', '\r', '\t', '\v') are ignored.
			      </p></li><li class="listitem"><p>
				Additional whitespace between and after tokens is allowed.
			      </p></li><li class="listitem"><p>
				Group and Acl definitions must start with <span class="command"><strong>group</strong></span> and <span class="command"><strong>acl</strong></span> respectively and with no preceding whitespace.
			      </p></li></ul></div></div><div class="section" title="Character Set"><div class="titlepage"><div><div><h5 class="title"><a id="sect-Messaging_User_Guide-Authorization-ACL_Syntactic_Conventions-characterset" />Character Set</h5></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>
				ACL files use 7-bit ASCII characters only
			      </p></li><li class="listitem"><p>
				Group names may contain only
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="command"><strong>[a-z]</strong></span></li><li class="listitem"><span class="command"><strong>[A-Z]</strong></span></li><li class="listitem"><span class="command"><strong>[0-9]</strong></span></li><li class="listitem"><span class="command"><strong>'-'</strong></span> hyphen</li><li class="listitem"><span class="command"><strong>'_'</strong></span> underscore</li></ul></div><p>
			      </p></li><li class="listitem"><p>
				Individual user names may contain only
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="command"><strong>[a-z]</strong></span></li><li class="listitem"><span class="command"><strong>[A-Z]</strong></span></li><li class="listitem"><span class="command"><strong>[0-9]</strong></span></li><li class="listitem"><span class="command"><strong>'-'</strong></span> hyphen</li><li class="listitem"><span class="command"><strong>'_'</strong></span> underscore</li><li class="listitem"><span class="command"><strong>'.'</strong></span> period</li><li class="listitem"><span class="command"><strong>'@'</strong></span> ampersand</li><li class="listitem"><span class="command"><strong>'/'</strong></span> slash</li></ul></div><p>
			      </p></li></ul></div></div><div class="section" title="Case Sensitivity"><div class="titlepage"><div><div><h5 class="title"><a id="sect-Messaging_User_Guide-Authorization-ACL_Syntactic_Conventions-casesensitivity" />Case Sensitivity</h5></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>
				All tokens are case sensitive. <em class="parameter"><code>name1</code></em> is not the same as <em class="parameter"><code>Name1</code></em> and <em class="parameter"><code>create</code></em> is not the same as <em class="parameter"><code>CREATE</code></em>.
			      </p></li></ul></div></div><div class="section" title="Line Continuation"><div class="titlepage"><div><div><h5 class="title"><a id="sect-Messaging_User_Guide-Authorization-ACL_Syntactic_Conventions-linecontinuation" />Line Continuation</h5></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>
				Group lists can be extended to the following line by terminating the line with the <span class="command"><strong>'\'</strong></span> character. No other ACL file lines may be continued.
			      </p></li><li class="listitem"><p>
				Group specification lines may be continued only after the group name or any of the user names included in the group. See example below.
			      </p></li><li class="listitem"><p>
				Lines consisting solely of a <span class="command"><strong>'\'</strong></span> character are not permitted.
			      </p></li><li class="listitem"><p>
				The <span class="command"><strong>'\'</strong></span> continuation character is recognized only if it is the last character in the line. Any characters after the <span class="command"><strong>'\'</strong></span> are not permitted.
			      </p></li></ul></div><pre class="programlisting">
    #
    # Examples of extending group lists using a trailing '\' character
    #
    group group1 name1 name2 \
    name3 name4 \
    name5

    group group2 \
                 group1 \
                 name6
    #
    # The following are illegal:
    #
    # '\' must be after group name
    #
    group \
          group3 name7 name8
    #
    # No empty extension line
    #
    group group4 name9 \
                       \
                 name10
</pre></div><div class="section" title="Line Length"><div class="titlepage"><div><div><h5 class="title"><a id="sect-Messaging_User_Guide-Authorization-ACL_Syntactic_Conventions-linelength" />Line Length</h5></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>
				ACL file lines are limited to 1024 characters.
			      </p></li></ul></div></div><div class="section" title="ACL File Keywords"><div class="titlepage"><div><div><h5 class="title"><a id="sect-Messaging_User_Guide-Authorization-ACL_Syntactic_Conventions-keywords" />ACL File Keywords</h5></div></div></div>
			  ACL reserves several words for convenience and for context sensitive substitution.
			  
			  <div class="section" title="The all Keyword"><div class="titlepage"><div><div><h6 class="title"><a id="sect-Messaging_User_Guide-Authorization-ACL_Syntactic_Conventions-keywords-all" />The <span class="command"><strong>all</strong></span> Keyword</h6></div></div></div>
			    The keyword <span class="command"><strong>all</strong></span> is reserved. It may be used in ACL rules to match all individuals and groups, all actions, or all objects.
			    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">acl allow all create queue</li><li class="listitem">acl allow bob@QPID all queue</li><li class="listitem">acl allow bob@QPID create all</li></ul></div></div><div class="section" title="User Name and Domain Name Keywords"><div class="titlepage"><div><div><h6 class="title"><a id="sect-Messaging_User_Guide-Authorization-ACL_Syntactic_Conventions-keywords-userdomain" />User Name and Domain Name Keywords</h6></div></div></div><p>
			      In the C++ Broker 0.20 a simple set of user name and domain name substitution variable keyword tokens is defined. This provides administrators with an easy way to describe private or shared resources.
			    </p><p>
			      Symbol substitution is allowed in the ACL file anywhere that text is supplied for a property value.
			    </p><p>
			      In the following table an authenticated user named bob.user@QPID.COM has his substitution keywords expanded.
			      
			      </p><div class="table"><a id="tabl-Messaging_User_Guide-ACL_Syntax-ACL_UsernameSubstitution" /><p class="title"><strong>Table&#160;1.9.&#160;ACL User Name and Domain Name Substitution Keywords</strong></p><div class="table-contents"><table border="1" summary="ACL User Name and Domain Name Substitution Keywords"><colgroup><col /><col /></colgroup><thead><tr><th>Keyword</th><th>Expansion</th></tr></thead><tbody><tr><td> <span class="command"><strong>${userdomain}</strong></span> </td><td>bob_user_QPID_COM</td></tr><tr><td> <span class="command"><strong>${user}</strong></span> </td><td>bob_user</td></tr><tr><td> <span class="command"><strong>${domain}</strong></span> </td><td>QPID_COM</td></tr></tbody></table></div></div><p><br class="table-break" />
			    </p><p>
			      </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
				  The original user name has the period &#8220;.&#8221; and ampersand &#8220;@&#8221; characters translated into underscore &#8220;_&#8221;. This allows substitution to work when the substitution keyword is used in a routingkey in the Acl file.
				</li><li class="listitem">
				  The Acl processing matches ${userdomain} before matching either ${user} or ${domain}. Rules that specify the combination ${user}_${domain} will never match.
				</li></ul></div><p>
			    </p><pre class="programlisting">
  # Example:
  # 
  # Administrators can set up Acl rule files that allow every user to create a
  # private exchange, a private queue, and a private binding between them. 
  # In this example the users are also allowed to create private backup exchanges, 
  # queues and bindings. This effectively provides limits to user's exchange, 
  # queue, and binding creation and guarantees that each user gets exclusive 
  # access to these resources.
  # 
  #
  # Create primary queue and exchange:
  #
  acl allow all create  queue    name=$\{user}-work alternate=$\{user}-work2
  acl deny  all create  queue    name=$\{user}-work alternate=*
  acl allow all create  queue    name=$\{user}-work
  acl allow all create  exchange name=$\{user}-work alternate=$\{user}-work2
  acl deny  all create  exchange name=$\{user}-work alternate=*
  acl allow all create  exchange name=$\{user}-work
  #
  # Create backup queue and exchange
  #
  acl deny  all create  queue    name=$\{user}-work2 alternate=*
  acl allow all create  queue    name=$\{user}-work2
  acl deny  all create  exchange name=$\{user}-work2 alternate=*
  acl allow all create  exchange name=$\{user}-work2
  #
  # Bind/unbind primary exchange
  #
  acl allow all bind   exchange name=$\{user}-work routingkey=$\{user} queuename=$\{user}-work
  acl allow all unbind exchange name=$\{user}-work routingkey=$\{user} queuename=$\{user}-work
  #
  # Bind/unbind backup exchange
  #
  acl allow all bind   exchange name=$\{user}-work2 routingkey=$\{user} queuename=$\{user}-work2
  acl allow all unbind exchange name=$\{user}-work2 routingkey=$\{user} queuename=$\{user}-work2
  #
  # Access primary exchange
  #
  acl allow all access exchange name=$\{user}-work routingkey=$\{user} queuename=$\{user}-work
  #
  # Access backup exchange
  #
  acl allow all access exchange name=$\{user}-work2 routingkey=$\{user} queuename=$\{user}-work2
  #
  # Publish primary exchange
  #
  acl allow all publish exchange name=$\{user}-work routingkey=$\{user}
  #
  # Publish backup exchange
  #
  acl allow all publish exchange name=$\{user}-work2 routingkey=$\{user}
  #
  # deny mode
  #
  acl deny all all
</pre></div></div><div class="section" title="Wildcards"><div class="titlepage"><div><div><h5 class="title"><a id="sect-Messaging_User_Guide-Authorization-ACL_Syntatic_Conventions-wildcards" />Wildcards</h5></div></div></div>
			  ACL privides two types of wildcard matching to provide flexibility in writing rules.

			  <div class="section" title="Property Value Wildcard"><div class="titlepage"><div><div><h6 class="title"><a id="sect-Messaging_User_Guide-Authorization-ACL_Syntatic_Conventions-wildcards-asterisk" />Property Value Wildcard</h6></div></div></div><p>
			      Text specifying a property value may end with a single trailing <span class="command"><strong>*</strong></span> character.
			      This is a simple wildcard match indicating that strings which match up to that point are matches for the ACL property rule.
			      An ACL rule such as
			    </p><p>
			      </p><pre class="programlisting">    acl allow bob@QPID create queue name=bob*</pre><p>
			    </p><p>
			      allow user bob@QPID to create queues named bob1, bob2, bobQueue3, and so on.
			    </p></div><div class="section" title="Topic Routing Key Wildcard"><div class="titlepage"><div><div><h6 class="title"><a id="sect-Messaging_User_Guide-Authorization-ACL_Syntatic_Conventions-wildcards-topickey" />Topic Routing Key Wildcard</h6></div></div></div><p>
			      In the C++ Broker 0.20 the logic governing the ACL Match has changed for each ACL rule that contains a routingkey property.
			      The routingkey property is matched according to Topic Exchange match logic the broker uses when it distributes messages published to a topic exchange.
			    </p><p>
			      Routing keys are hierarchical where each level is separated by a period:
			      </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">weather.usa</li><li class="listitem">weather.europe.germany</li><li class="listitem">weather.europe.germany.berlin</li><li class="listitem">company.engineering.repository</li></ul></div><p>
			    </p><p>
			      Within the routing key hierarchy two wildcard characters are defined.
			      </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="command"><strong>*</strong></span> matches one field</li><li class="listitem"><span class="command"><strong>#</strong></span> matches zero or more fields</li></ul></div><p>
			    </p><p>
			      Suppose an ACL rule file is:
			    </p><p>
			      </p><pre class="programlisting">
    acl allow-log uHash1@COMPANY publish exchange name=X routingkey=a.#.b
    acl deny all all
			      </pre><p>
			    </p><p>
			      When user uHash1@COMPANY attempts to publish to exchange X the ACL will return these results:

			      </p><div class="table"><a id="tabl-Messaging_User_Guide-ACL_Syntax-ACL_TopicExchangeMatch" /><p class="title"><strong>Table&#160;1.10.&#160;Topic Exchange Wildcard Match Examples</strong></p><div class="table-contents"><table border="1" summary="Topic Exchange Wildcard Match Examples"><colgroup><col /><col /></colgroup><thead><tr><th>routingkey in publish to exchange X</th><th>result</th></tr></thead><tbody><tr><td> <span class="command"><strong>a.b</strong></span> </td><td>allow-log</td></tr><tr><td> <span class="command"><strong>a.x.b</strong></span> </td><td>allow-log</td></tr><tr><td> <span class="command"><strong>a.x.y.zz.b</strong></span> </td><td>allow-log</td></tr><tr><td> <span class="command"><strong>a.b.</strong></span> </td><td>deny</td></tr><tr><td> <span class="command"><strong>q.x.b</strong></span> </td><td>deny</td></tr></tbody></table></div></div><p><br class="table-break" />

			    </p></div></div></div><div class="section" title="1.5.2.3.&#160;ACL Rule Matching"><div class="titlepage"><div><div><h4 class="title"><a id="sect-Messaging_User_Guide-Authorization-ACL_Rule_Matching" />1.5.2.3.&#160;ACL Rule Matching</h4></div></div></div><p>
			   The minimum matching criteria for ACL rules are:
			   </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">An actor (individually named or group member)</li><li class="listitem">An action</li><li class="listitem">An object</li></ul></div><p>
			 </p><p>
			   If a rule does not match the minimum criteria then that rule does not control the ACL allow or deny decision.
			 </p><p>
			   ACL rules optionally specify object names and property name=value pairs. If an ACL rule specifies an object name or property values than all of them must match to cause the rule to match.
			 </p><p>
			   The following illustration shows how ACL rules are processed to find matching rules.
</p><pre class="programlisting">
    # Example of rule matching
    #
    # Using this ACL file content:
    
    (1)  acl deny bob create exchange name=test durable=true passive=true
    (2)  acl deny bob create exchange name=myEx type=direct
    (3)  acl allow all all
    
    #
    # Lookup 1. id:bob action:create objectType:exchange name=test 
    #           {durable=false passive=false type=direct alternate=}
    #
    # ACL Match Processing:
    #  1. Rule 1 passes minimum criteria with user bob, action create, 
    #     and object exchange.
    #  2. Rule 1 matches name=test.
    #  3. Rule 1 does not match the rule's durable=true with the requested 
    #     lookup of durable=false.
    #  4. Rule 1 does not control the decision and processing continues 
    #     to Rule 2.
    #  5. Rule 2 passes minimum criteria with user bob, action create, 
    #     and object exchange.
    #  6. Rule 2 does not match the rule's name=myEx with the requested 
    #     lookup of name=test.
    #  7. Rule 2 does not control the decision and processing continues 
    #     to Rule 3.
    #  8. Rule 3 matches everything and the decision is 'allow'.
    #
    # Lookup 2. id:bob action:create objectType:exchange name=myEx 
    #           {durable=true passive=true type=direct alternate=}
    #
    # ACL Match Processing:
    #  1. Rule 1 passes minimum criteria with user bob, action create, 
    #     and object exchange.
    #  2. Rule 1 does not match the rule's name=test with the requested 
    #     lookup of name=myEx.
    #  3. Rule 1 does not control the decision and processing continues
    #     to Rule 2.
    #  4. Rule 2 passes minimum criteria with user bob, action create, 
    #     and object exchange.
    #  5. Rule 2 matches name=myEx.
    #  6. Rule 2 matches the rule's type=direct with the requested 
    #     lookup of type=direct.
    #  7. Rule 2 is the matching rule and the decision is 'deny'.
    #
</pre><p>
			 </p></div><div class="section" title="1.5.2.4.&#160;Specifying ACL Permissions"><div class="titlepage"><div><div><h4 class="title"><a id="sect-Messaging_User_Guide-Authorization-Specifying_ACL_Permissions" />1.5.2.4.&#160;Specifying ACL Permissions</h4></div></div></div><p>
			   Now that we have seen the ACL syntax, we will provide representative examples and guidelines for ACL files.
			</p><p>
				Most ACL files begin by defining groups:
			</p><pre class="programlisting">
    group admin ted@QPID martin@QPID
    group user-consume martin@QPID ted@QPID
    group group2 kim@QPID user-consume rob@QPID
    group publisher group2 \
    tom@QPID andrew@QPID debbie@QPID
</pre><p>
				Rules in an ACL file grant or deny specific permissions to users or groups:
			</p><pre class="programlisting">
    acl allow carlt@QPID create exchange name=carl.*
    acl allow rob@QPID create queue
    acl allow guest@QPID bind exchange name=amq.topic routingkey=stocks.rht.#
    acl allow user-consume create queue name=tmp.*

    acl allow publisher publish all durable=false
    acl allow publisher create queue name=RequestQueue
    acl allow consumer consume queue durable=true
    acl allow fred@QPID create all
    acl allow bob@QPID all queue
    acl allow admin all
    acl allow all consume queue
    acl allow all bind exchange
    acl deny all all
</pre><p>
				In the previous example, the last line, <code class="literal">acl deny all all</code>, denies all authorizations that have not been specifically granted. This is the default, but it is useful to include it explicitly on the last line for the sake of clarity. If you want to grant all rights by default, you can specify <code class="literal">acl allow all all</code> in the last line.
			</p><p>
			  ACL allows specification of conflicting rules. Be sure to specify the most specific rules first followed by more general rules. Here is an example:
			</p><p>
</p><pre class="programlisting">
    group users alice@QPID bob@QPID charlie@QPID
    acl deny  charlie@QPID create queue
    acl allow users        create queue
    acl deny all all
</pre><p>
			</p><p>
			  In this example users alice and bob would be able to create queues due to their membership in the users group. However, user charlie is denied from creating a queue despite his membership in the users group because a deny rule for him is stated before the allow rule for the users group.
			</p><p>
				Do not allow <em class="parameter"><code>guest</code></em> to access and log QMF management methods that could cause security breaches:
			</p><pre class="programlisting">
    group allUsers guest@QPID
    ...
    acl deny-log allUsers create link
    acl deny-log allUsers access method name=connect
    acl deny-log allUsers access method name=echo
    acl allow all all
</pre></div></div><div class="section" title="1.5.3.&#160;User Connection and Queue Quotas"><div class="titlepage"><div><div><h3 class="title"><a id="sect-Messaging_User_Guide-Authorization-Specifying_ACL_Quotas" />1.5.3.&#160;User Connection and Queue Quotas</h3></div></div></div>
		The ACL module enforces various quotas and thereby limits user activity.
		
		<div class="section" title="1.5.3.1.&#160;Connection Limits"><div class="titlepage"><div><div><h4 class="title"><a id="sect-Messaging_User_Guide-Authorization-Specifying_ACL_Connection_Limits" />1.5.3.1.&#160;Connection Limits</h4></div></div></div><p>
		    The ACL module creates broker command line switches that set limits on the number of concurrent connections allowed per user or per client host address. These settings are not specified in the ACL file.
		  </p><p>
		    </p><pre class="programlisting">
    --max-connections           N
    --connection-limit-per-user N
    --connection-limit-per-ip   N
		    </pre><p>
		  </p><p>
		    <span class="command"><strong>--max-connections</strong></span> specifies an upper limit for all user connections.
		  </p><p>
		    <span class="command"><strong>--connection-limit-per-user</strong></span> specifies an upper limit for each user based on the authenticated user name. This limit is enforced regardless of the client IP address from which the connection originates.
		  </p><p>
		    <span class="command"><strong>--connection-limit-per-ip</strong></span> specifies an upper limit for connections for all users based on the originating client IP address. This limit is enforced regardless of the user credentials presented with the connection.
		    </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
			Note that addresses using different transports are counted separately even though the originating host is actually the same physical machine. In the setting illustrated above a host would allow N_IP connections from [::1] IPv6 transport localhost and another N_IP connections from [127.0.0.1] IPv4 transport localhost.
		      </li><li class="listitem">
			The connection-limit-per-ip and connection-limit-per-user counts are active simultaneously. From a given client system users may be denied access to the broker by either connection limit.
		      </li></ul></div><p>
		  </p><p>
		    The 0.22 C++ Broker ACL module accepts fine grained per-user connection limits through quota rules in the ACL file.
		  </p><p>
		    </p><pre class="programlisting">
    quota connections 10 admins userX@QPID
		    </pre><p>
		  </p><p>
		    </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
			User <code class="literal">all</code> receives the value passed by the command line switch <code class="literal">--connection-limit-per-user</code>.
		      </li><li class="listitem">
			Values specified in the ACL rule for user <code class="literal">all</code> overwrite the value specified on the command line if any.
		      </li><li class="listitem">
			Connection quotas values are determined by first searching for the authenticated user name. If that user name is not specified then the value for user <code class="literal">all</code>
			is used. If user <code class="literal">all</code> is not specified then the connection is denied.
		      </li><li class="listitem">
			The connection quota values range from 0..65530 inclusive. A value of zero disables connections from that user.
		      </li><li class="listitem">
			A user's quota may be specified many times in the ACL rule file. Only the last value specified is retained and enforced.
		      </li><li class="listitem">
			Per-user connection quotas are disabled when two conditions are true: 1) No --connection-limit-per-user command line switch and 2) No <code class="literal">quota connections</code>
			rules in the ACL file. Per-user connections are always counted even if connection quotas are not enforced. This supports ACL file reloading that may subsequently
			enable per-user connection quotas.
		      </li><li class="listitem">
			An ACL file reload may lower a user's connection quota value to a number lower than the user's current connection count. In that case the active connections
			remain unaffected. New connections are denied until that user closes enough of his connections so that his count falls below the configured limit.
		      </li></ul></div><p>
		  </p></div><div class="section" title="1.5.3.2.&#160;Queue Limits"><div class="titlepage"><div><div><h4 class="title"><a id="sect-Messaging_User_Guide-Authorization-Specifying_ACL_Queue_Limits" />1.5.3.2.&#160;Queue Limits</h4></div></div></div><p>
		    The ACL module creates a broker command line switch that set limits on the number of queues each user is allowed to create. This settings is not specified in the ACL file.
		  </p><p>
		    </p><pre class="programlisting">
    --max-queues-per-user N
		    </pre><p>
		  </p><p>
		    The queue limit is set for all users on the broker.
		  </p><p>
		    The 0.22 C++ Broker ACL module accepts fine grained per-user queue limits through quota rules in the ACL file.
		  </p><p>
		    </p><pre class="programlisting">
    quota queues 10 admins userX@QPID
		    </pre><p>
		  </p><p>
		    </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
			User <code class="literal">all</code> receives the value passed by the command line switch <code class="literal">--max-queues-per-user</code>.
		      </li><li class="listitem">
			Values specified in the ACL rule for user <code class="literal">all</code> overwrite the value specified on the command line if any.
		      </li><li class="listitem">
			Queue quotas values are determined by first searching for the authenticated user name. If that user name is not specified then the value for user <code class="literal">all</code>
			is used. If user <code class="literal">all</code> is not specified then the queue creation is denied.
		      </li><li class="listitem">
			The queue quota values range from 0..65530 inclusive. A value of zero disables queue creation by that user.
		      </li><li class="listitem">
			A user's quota may be specified many times in the ACL rule file. Only the last value specified is retained and enforced.
		      </li><li class="listitem">
			Per-user queue quotas are disabled when two conditions are true: 1) No --queue-limit-per-user command line switch and 2) No <code class="literal">quota queues</code>
			rules in the ACL file. Per-user queue creations are always counted even if queue quotas are not enforced. This supports ACL file reloading that may subsequently
			enable per-user queue quotas.
		      </li><li class="listitem">
			An ACL file reload may lower a user's queue quota value to a number lower than the user's current queue count. In that case the active queues
			remain unaffected. New queues are denied until that user closes enough of his queues so that his count falls below the configured limit.
		      </li></ul></div><p>
		  </p></div></div><div class="section" title="1.5.4.&#160;Encryption using SSL"><div class="titlepage"><div><div><h3 class="title"><a id="sect-Messaging_User_Guide-Security-Encryption_using_SSL" />1.5.4.&#160;Encryption using SSL</h3></div></div></div><p>
			Encryption and certificate management for <span class="command"><strong>qpidd</strong></span> is provided by Mozilla's Network Security Services Library (NSS).
		</p><div class="orderedlist" title="Enabling SSL for the Qpid broker"><a id="orde-Messaging_User_Guide-Encryption_using_SSL-Enabling_SSL_for_the_RHM_broker" /><p class="title"><strong>Enabling SSL for the Qpid broker</strong></p><ol class="orderedlist" type="1"><li class="listitem"><p>
					You will need a certificate that has been signed by a Certification Authority (CA). This certificate will also need to be trusted by your client. If you require client authentication in addition to server authentication, the client's certificate will also need to be signed by a CA and trusted by the broker.
				</p><p>
					In the broker, SSL is provided through the <span class="command"><strong>ssl.so</strong></span> module. This module is installed and loaded by default in Qpid. To enable the module, you need to specify the location of the database containing the certificate and key to use. This is done using the <span class="command"><strong>ssl-cert-db</strong></span> option.
				</p><p>
					The certificate database is created and managed by the Mozilla Network Security Services (NSS) <span class="command"><strong>certutil</strong></span> tool. Information on this utility can be found on the <a class="ulink" href="http://www.mozilla.org/projects/security/pki/nss/tools/certutil.html" target="_top">Mozilla website</a>, including tutorials on setting up and testing SSL connections. The certificate database will generally be password protected. The safest way to specify the password is to place it in a protected file, use the password file when creating the database, and specify the password file with the <span class="command"><strong>ssl-cert-password-file</strong></span> option when starting the broker.
				</p><p>
					The following script shows how to create a certificate database using certutil:
				</p><pre class="programlisting">
mkdir ${CERT_DIR}
certutil -N -d ${CERT_DIR} -f ${CERT_PW_FILE}
certutil -S -d ${CERT_DIR} -n ${NICKNAME} -s "CN=${NICKNAME}" -t "CT,," -x -f ${CERT_PW_FILE} -z /usr/bin/certutil
</pre><p>
					When starting the broker, set <span class="command"><strong>ssl-cert-password-file</strong></span> to the value of <span class="command"><strong>${CERT_PW_FILE}</strong></span>, set <span class="command"><strong>ssl-cert-db</strong></span> to the value of <span class="command"><strong>${CERT_DIR}</strong></span>, and set <span class="command"><strong>ssl-cert-name</strong></span> to the value of <span class="command"><strong>${NICKNAME}</strong></span>.
				</p></li><li class="listitem"><p>
					The following SSL options can be used when starting the broker:
					</p><div class="variablelist"><dl><dt><span class="term"><span class="command"><strong>--ssl-use-export-policy</strong></span></span></dt><dd><p>
									Use NSS export policy
								</p></dd><dt><span class="term"><span class="command"><strong>--ssl-cert-password-file <em class="replaceable"><code>PATH</code></em></strong></span></span></dt><dd><p>
									Required. Plain-text file containing password to use for accessing certificate database.
								</p></dd><dt><span class="term"><span class="command"><strong>--ssl-cert-db <em class="replaceable"><code>PATH</code></em></strong></span></span></dt><dd><p>
									Required. Path to directory containing certificate database.
								</p></dd><dt><span class="term"><span class="command"><strong>--ssl-cert-name <em class="replaceable"><code>NAME</code></em></strong></span></span></dt><dd><p>
									Name of the certificate to use. Default is <code class="literal">localhost.localdomain</code>.
								</p></dd><dt><span class="term"><span class="command"><strong>--ssl-port <em class="replaceable"><code>NUMBER</code></em></strong></span></span></dt><dd><p>
									Port on which to listen for SSL connections. If no port is specified, port 5671 is used.
								</p></dd><dt><span class="term"><span class="command"><strong>--ssl-require-client-authentication</strong></span></span></dt><dd><p>
									Require SSL client authentication (i.e. verification of a client certificate) during the SSL handshake. This occurs before SASL authentication, and is independent of SASL.
								</p><p>
									This option enables the <code class="literal">EXTERNAL</code> SASL mechanism for SSL connections. If the client chooses the <code class="literal">EXTERNAL</code> mechanism, the client's identity is taken from the validated SSL certificate, using the <code class="literal">CN</code>literal&gt;, and appending any <code class="literal">DC</code>literal&gt;s to create the domain. For instance, if the certificate contains the properties <code class="literal">CN=bob</code>, <code class="literal">DC=acme</code>, <code class="literal">DC=com</code>, the client's identity is <code class="literal">bob@acme.com</code>.
								</p><p>
									If the client chooses a different SASL mechanism, the identity take from the client certificate will be replaced by that negotiated during the SASL handshake.
								</p></dd><dt><span class="term"><span class="command"><strong>--ssl-sasl-no-dict</strong></span></span></dt><dd><p>
									Do not accept SASL mechanisms that can be compromised by dictionary attacks. This prevents a weaker mechanism being selected instead of <code class="literal">EXTERNAL</code>, which is not vulnerable to dictionary attacks.
								</p></dd></dl></div><p>
					 Also relevant is the <span class="command"><strong>--require-encryption</strong></span> broker option. This will cause <span class="command"><strong>qpidd</strong></span> to only accept encrypted connections.
				</p></li></ol></div><div class="variablelist" title="Enabling SSL in Clients"><a id="vari-Messaging_User_Guide-Encryption_using_SSL-Enabling_SSL_in_Clients" /><p class="title"><strong>Enabling SSL in Clients</strong></p><dl><dt><span class="term">C++ clients:</span></dt><dd><p>
						</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
									In C++ clients, SSL is implemented in the <span class="command"><strong>sslconnector.so</strong></span> module. This module is installed and loaded by default in Qpid.
								</p><p>
									The following options can be specified for C++ clients using environment variables:
								</p><div class="table"><a id="tabl-Messaging_User_Guide-Enabling_SSL_in_Clients-SSL_Client_Environment_Variables_for_C_clients" /><p class="title"><strong>Table&#160;1.11.&#160;SSL Client Environment Variables for C++ clients</strong></p><div class="table-contents"><table border="1" summary="SSL Client Environment Variables for C++ clients"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /></colgroup><thead><tr><th align="center" colspan="2">
													SSL Client Options for C++ clients
												</th></tr></thead><tbody><tr><td align="left">
													<span class="command"><strong>QPID_SSL_USE_EXPORT_POLICY</strong></span>
												</td><td align="left">
													Use NSS export policy
												</td></tr><tr><td align="left">
													<span class="command"><strong>QPID_SSL_CERT_PASSWORD_FILE <em class="replaceable"><code>PATH</code></em></strong></span>
												</td><td align="left">
													File containing password to use for accessing certificate database
												</td></tr><tr><td align="left">
													<span class="command"><strong>QPID_SSL_CERT_DB <em class="replaceable"><code>PATH</code></em></strong></span>
												</td><td align="left">
													Path to directory containing certificate database
												</td></tr><tr><td align="left">
													<span class="command"><strong>QPID_SSL_CERT_NAME <em class="replaceable"><code>NAME</code></em></strong></span>
												</td><td align="left">
													Name of the certificate to use. When SSL client authentication is enabled, a certificate name should normally be provided.
												</td></tr></tbody></table></div></div><br class="table-break" /></li><li class="listitem"><p>
									When using SSL connections, clients must specify the location of the certificate database, a directory that contains the client's certificate and the public key of the Certificate Authority. This can be done by setting the environment variable <span class="command"><strong>QPID_SSL_CERT_DB</strong></span> to the full pathname of the directory. If a connection uses SSL client authentication, the client's password is also needed&#8212;the password should be placed in a protected file, and the <span class="command"><strong>QPID_SSL_CERT_PASSWORD_FILE</strong></span> variable should be set to the location of the file containing this password.
								</p></li><li class="listitem"><p>
									To open an SSL enabled connection in the Qpid Messaging API, set the <em class="parameter"><code>protocol</code></em> connection option to <em class="parameter"><code>ssl</code></em>.
								</p></li></ol></div><p>

					</p></dd><dt><span class="term">Java clients:</span></dt><dd><p>
						</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
									For both server and client authentication, import the trusted CA to your trust store and keystore and generate keys for them. Create a certificate request using the generated keys and then create a certificate using the request. You can then import the signed certificate into your keystore. Pass the following arguments to the Java JVM when starting your client:
</p><pre class="programlisting">
-Djavax.net.ssl.keyStore=/home/bob/ssl_test/keystore.jks
-Djavax.net.ssl.keyStorePassword=password
-Djavax.net.ssl.trustStore=/home/bob/ssl_test/certstore.jks
-Djavax.net.ssl.trustStorePassword=password
</pre><p>

								</p></li><li class="listitem"><p>
									For server side authentication only, import the trusted CA to your trust store and pass the following arguments to the Java JVM when starting your client:
</p><pre class="programlisting">
-Djavax.net.ssl.trustStore=/home/bob/ssl_test/certstore.jks
-Djavax.net.ssl.trustStorePassword=password
</pre><p>

								</p></li><li class="listitem"><p>
									Java clients must use the SSL option in the connection URL to enable SSL encryption, e.g.
								</p><pre class="programlisting">amqp://username:password@clientid/test?brokerlist='tcp://localhost:5672?ssl='true''
</pre></li><li class="listitem"><p>
									If you need to debug problems in an SSL connection, enable Java's SSL debugging by passing the argument <code class="literal">-Djavax.net.debug=ssl</code> to the Java JVM when starting your client.
								</p></li></ol></div><p>

					</p></dd></dl></div></div></div><div class="section" title="1.6.&#160;LVQ - Last Value Queue"><div class="titlepage"><div><div><h2 class="title"><a id="idp29424512" />1.6.&#160;LVQ - Last Value Queue</h2></div></div></div><div class="section" title="1.6.1.&#160;Understanding LVQ"><div class="titlepage"><div><div><h3 class="title"><a id="LVQ-UnderstandingLVQ" />1.6.1.&#160;Understanding LVQ</h3></div></div></div><p>
      A Last Value Queue is configured with the name of a message header that
      is used as a key.  The queue behaves as a normal FIFO queue with the
      exception that when a message is enqueued, any other message in the
      queue with the same value in the key header is removed and discarded.
      Thus, for any given key value, the queue holds only the most recent
      message.
    </p><p>
      The following example illustrates the operation of a Last Value Queue.
      The example shows an empty queue with no consumers and a sequence of
      produced messages.  The numbers represent the key for each message.
    </p><pre class="programlisting">
           &lt;empty queue&gt;
      1 =&gt;
           1
      2 =&gt;
           1 2
      3 =&gt;
           1 2 3
      4 =&gt;
           1 2 3 4
      2 =&gt;
           1 3 4 2
      1 =&gt;
           3 4 2 1
    </pre><p>
      Note that the first four messages are enqueued normally in FIFO order.
      The fifth message has key '2' and is also enqueued on the tail of the
      queue.  However the message already in the queue with the same key is
      discarded.
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;" title="Note"><h3 class="title">Note</h3><p>
          If the set of keys used in the messages in a LVQ is constrained, the
          number of messages in the queue shall not exceed the number of
          distinct keys in use.
        </p></div><p>
    </p><div class="section" title="1.6.1.1.&#160;Common Use-Cases"><div class="titlepage"><div><div><h4 class="title"><a id="LVQ-UnderstandingLVQ-UseCases" />1.6.1.1.&#160;Common Use-Cases</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>
            LVQ with zero or one consuming subscriptions - In this case, if
            the consumer drops momentarily or is slower than the producer(s),
            it will only receive current information relative to the message
            keys.
          </p></li><li class="listitem"><p>
            LVQ with zero or more browsing subscriptions - A browsing consumer
            can subscribe to the LVQ and get an immediate dump of all of the
            "current" messages and track updates thereafter.  Any number of
            independent browsers can subscribe to the same LVQ with the same
            effect.  Since messages are never consumed, they only disappear
            when replaced with a newer message with the same key or when their
            TTL expires.
          </p></li></ul></div></div></div><div class="section" title="1.6.2.&#160;Creating a Last Value Queue"><div class="titlepage"><div><div><h3 class="title"><a id="LVQ-Creating" />1.6.2.&#160;Creating a Last Value Queue</h3></div></div></div><div class="section" title="1.6.2.1.&#160;Using Addressing Syntax"><div class="titlepage"><div><div><h4 class="title"><a id="LVQ-Creating-Address" />1.6.2.1.&#160;Using Addressing Syntax</h4></div></div></div><p>
        A LVQ may be created using directives in the API's address syntax.
        The important argument is "qpid.last_value_queue_key".  The following
        Python example shows how a producer of stock price updates can create
        a LVQ to hold the latest stock prices for each ticker symbol.  The
        message header used to hold the ticker symbol is called "ticker".
      </p><pre class="programlisting">
    conn = Connection(url)
    conn.open()
    sess = conn.session()
    tx = sess.sender("prices;{create:always, node:{type:queue, x-declare:{arguments:{'qpid.last_value_queue_key':'ticker'}}}}")
      </pre></div><div class="section" title="1.6.2.2.&#160;Using qpid-config"><div class="titlepage"><div><div><h4 class="title"><a id="LVQ-Creating-Tool" />1.6.2.2.&#160;Using qpid-config</h4></div></div></div><p>
        The same LVQ as shown in the previous example can be created using the
        qpid-config utility:
      </p><pre class="programlisting">
    $ qpid-config add queue prices --lvq-key ticker
      </pre></div></div><div class="section" title="1.6.3.&#160;LVQ Example"><div class="titlepage"><div><div><h3 class="title"><a id="LVQ-Example" />1.6.3.&#160;LVQ Example</h3></div></div></div><div class="section" title="1.6.3.1.&#160;LVQ Sender"><div class="titlepage"><div><div><h4 class="title"><a id="LVQ-Example-Sender" />1.6.3.1.&#160;LVQ Sender</h4></div></div></div><pre class="programlisting">
    from qpid.messaging import Connection, Message

    def send(sender, key, message):
      message.properties["ticker"] = key
      sender.send(message)

    conn = Connection("localhost")
    conn.open()
    sess = conn.session()
    tx = sess.sender("prices;{create:always, node:{type:queue,x-declare:{arguments:{'qpid.last_value_queue_key':ticker}}}}")

    msg = Message("Content")
    send(tx, "key1", msg);
    send(tx, "key2", msg);
    send(tx, "key3", msg);
    send(tx, "key4", msg);
    send(tx, "key2", msg);
    send(tx, "key1", msg);

    conn.close()
      </pre></div><div class="section" title="1.6.3.2.&#160;LVQ Browsing Receiver"><div class="titlepage"><div><div><h4 class="title"><a id="LVQ-Example-Receiver" />1.6.3.2.&#160;LVQ Browsing Receiver</h4></div></div></div><pre class="programlisting">
    from qpid.messaging import Connection, Message

    conn = Connection("localhost")
    conn.open()
    sess = conn.session()
    rx = sess.receiver("prices;{mode:browse}")

    while True:
      msg = rx.fetch()
      sess.acknowledge()
      print msg
      </pre></div></div><div class="section" title="1.6.4.&#160;Deprecated LVQ Modes"><div class="titlepage"><div><div><h3 class="title"><a id="LVQ-Deprecated" />1.6.4.&#160;Deprecated LVQ Modes</h3></div></div></div><p>
      There are two legacy modes (still implemented as of Qpid 0.14)
      controlled by the qpid.last_value_queue and
      qpid.last_value_queue_no_browse argument values.  These modes are
      deprecated and should not be used.
    </p></div></div><div class="section" title="1.7.&#160; Queue State Replication"><div class="titlepage"><div><div><h2 class="title"><a id="queue-state-replication" />1.7.&#160;
    Queue State Replication
  </h2></div></div></div><div class="section" title="1.7.1.&#160; Asynchronous Replication of Queue State"><div class="titlepage"><div><div><h3 class="title"><a id="queuestatereplication-AsynchronousReplicationofQueueState" />1.7.1.&#160;
      Asynchronous
      Replication of Queue State
    </h3></div></div></div><div class="section" title="1.7.1.1.&#160; Overview"><div class="titlepage"><div><div><h4 class="title"><a id="queuestatereplication-Overview" />1.7.1.1.&#160;
	Overview
      </h4></div></div></div><p>
	There is support in qpidd for selective asynchronous replication
	of queue state. This is achieved by:
      </p><p>
	(a) enabling event generation for the queues in question
      </p><p>
	(b) loading a plugin on the 'source' broker to encode those
	events as messages on a replication queue (this plugin is
	called
	replicating_listener.so)
      </p><p>
	(c) loading a custom exchange plugin on the 'backup' broker (this
	plugin is called replication_exchange.so)
      </p><p>
	(d) creating an instance of the replication exchange type on the
	backup broker
      </p><p>
	(e) establishing a federation bridge between the replication
	queue on the source broker and the replication exchange on the
	backup broker
      </p><p>
	The bridge established between the source and backup brokers for
	replication (step (e) above) should have acknowledgements turned
	on (this may be done through the --ack N option to qpid-route).
	This ensures that replication events are not lost if the bridge
	fails.
      </p><p>
	The replication protocol will also eliminate duplicates to ensure
	reliably replicated state. Note though that only one bridge per
	replication exchange is supported. If clients try to publish to
	the replication exchange or if more than a the single required
	bridge from the replication queue on the source broker is
	created, replication will be corrupted. (Access control may be
	used to restrict access and help prevent this).
      </p><p>
	The replicating event listener plugin (step (b) above) has the
	following options:
      </p><pre class="programlisting">
Queue Replication Options:
  --replication-queue QUEUE                      Queue on which events for
                                                 other queues are recorded
  --replication-listener-name NAME (replicator)  name by which to register the
                                                 replicating event listener
  --create-replication-queue                     if set, the replication will
                                                 be created if it does not
                                                 exist
      </pre><p>
	The name of the queue is required. It can either point to a
	durable queue whose definition has been previously recorded, or
	the --create-replication-queue option can be specified in which
	case the queue will be created a simple non-durable queue if it
	does not already exist.
      </p></div><div class="section" title="1.7.1.2.&#160; Use with Clustering"><div class="titlepage"><div><div><h4 class="title"><a id="queuestatereplication-UsewithClustering" />1.7.1.2.&#160;
	Use with
	Clustering
      </h4></div></div></div><p>
	The source and/or backup brokers may also be clustered brokers.
	In this case the federated bridge will be re-established between
	replicas should either of the originally connected nodes fail.
	There are however the following limitations at present:
      </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The backup site does not process membership updates after it
	  establishes the first connection. In order for newly added
	  members on a source cluster to be eligible as failover targets,
	  the bridge must be recreated after those members have been added
	  to the source cluster.
	  </p></li></ul></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>New members added to a backup cluster will not receive
	  information about currently established bridges. Therefore in
	  order to allow the bridge to be re-established from these members
	  in the event of failure of older nodes, the bridge must be
	  recreated after the new members have joined.
	  </p></li></ul></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Only a single URL can be passed to create the initial link
	  from backup site to the primary site. this means that at the time
	  of creating the initial connection the initial node in the
	  primary site to which the connection is made needs to be running.
	  Once connected the backup site will receive a membership update
	  of all the nodes in the primary site, and if the initial
	  connection node in the primary fails, the link will be
	  re-established on the next node that was started (time) on the
	  primary site.
	  </p></li></ul></div><p>
	Due to the acknowledged transfer of events over the bridge (see
	note above) manual recreation of the bridge and automatic
	re-establishment of te bridge after connection failure (including
	failover where either or both ends are clustered brokers) will
	not result in event loss.
      </p></div><div class="section" title="1.7.1.3.&#160; Operations on Backup Queues"><div class="titlepage"><div><div><h4 class="title"><a id="queuestatereplication-OperationsonBackupQueues" />1.7.1.3.&#160;
	Operations
	on Backup Queues
      </h4></div></div></div><p>
	When replicating the state of a queue to a backup broker it is
	important to recognise that any other operations performed
	directly on the backup queue may break the replication.
      </p><p>
	If the backup queue is to be an active (i.e. accessed by clients
	while replication is on) only enqueues should be selected
	for
	replication. In this mode, any message enqueued on the source
	brokers copy of the queue will also be enqueued on the backup
	brokers copy. However not attempt will be made to remove messages
	from the backup queue in response to removal of messages from the
	source queue.
      </p></div><div class="section" title="1.7.1.4.&#160; Selecting Queues for Replication"><div class="titlepage"><div><div><h4 class="title"><a id="queuestatereplication-SelectingQueuesforReplication" />1.7.1.4.&#160;
	Selecting
	Queues for Replication
      </h4></div></div></div><p>
	Queues are selected for replication by specifying the types of
	events they should generate (it is from these events that the
	replicating plugin constructs messages which are then pulled and
	processed by the backup site). This is done through options
	passed to the initial queue-declare command that creates the
	queue and may be done either through qpid-config or similar
	tools, or by the application.
      </p><p>
	With qpid-config, the --generate-queue-events options is used:
      </p><pre class="programlisting">
    --generate-queue-events N
                         If set to 1, every enqueue will generate an event that can be processed by
                         registered listeners (e.g. for replication). If set to 2, events will be
                         generated for enqueues and dequeues
      </pre><p>
	From an application, the arguments field of the queue-declare
	AMQP command is used to convey this information. An entry should
	be added to the map with key 'qpid.queue_event_generation' and an
	integer value of 1 (to replicate only enqueue events) or 2 (to
	replicate both enqueue and dequeue events).
      </p><p>
	Applications written using the c++ client API may fine the
	qpid::client::QueueOptions class convenient. This has a
	enableQueueEvents() method on it that can be used to set the
	option (the instance of QueueOptions is then passed as the value
	of the arguments field in the queue-declare command. The boolean
	option to that method should be set to true if only enequeue
	events should be replicated; by default it is false meaning that
	both enqueues and dequeues will be replicated. E.g.
      </p><pre class="programlisting">
    QueueOptions options;
    options.enableQueueEvents(false);
    session.queueDeclare(arg::queue="my-queue", arg::arguments=options);
      </pre></div><div class="section" title="1.7.1.5.&#160; Example"><div class="titlepage"><div><div><h4 class="title"><a id="queuestatereplication-Example" />1.7.1.5.&#160;
	Example
      </h4></div></div></div><p>
	Lets assume we will run the primary broker on host1 and the
	backup on host2, have installed qpidd on both and have the
	replicating_listener and replication_exchange plugins in qpidd's
	module directory(*1).
      </p><p>
	On host1 we start the source broker and specifcy that a queue
	called 'replication' should be used for storing the events until
	consumed by the backup. We also request that this queue be
	created (as transient) if not already specified:
      </p><pre class="programlisting">
    qpidd --replication-queue replication-queue --create-replication-queue true --log-enable info+
      </pre><p>
	On host2 we start up the backup broker ensuring that the
	replication exchange module is loaded:
      </p><pre class="programlisting">
    qpidd
      </pre><p>
	We can then create the instance of that replication exchange that
	we will use to process the events:
      </p><pre class="programlisting">
    qpid-config -a host2 add exchange replication replication-exchange
      </pre><p>
	If this fails with the message "Exchange type not implemented:
	replication", it means the replication exchange module was
	not
	loaded. Check that the module is installed on your system and if
	necessary provide the full path to the library.
      </p><p>
	We then connect the replication queue on the source broker with
	the replication exchange on the backup broker using the
	qpid-route command:
      </p><pre class="programlisting">
    qpid-route --ack 50 queue add host2 host1 replication-exchange replication-queue
</pre><p>
            The example above configures the bridge to acknowledge messages
            in batches of 50.
          </p><p>
            Now create two queues (on both source and backup brokers), one
            replicating both enqueues and dequeues (queue-a) and the
            other
            replicating only dequeues (queue-b):
          </p><pre class="programlisting">
    qpid-config -a host1 add queue queue-a --generate-queue-events 2
    qpid-config -a host1 add queue queue-b --generate-queue-events 1

    qpid-config -a host2 add queue queue-a
    qpid-config -a host2 add queue queue-b
	    </pre><p>
	      We are now ready to use the queues and see the replication.
	    </p><p>
	      Any message enqueued on queue-a will be replicated to the backup
	      broker. When the message is acknowledged by a client connected to
	      host1 (and thus dequeued), that message will be removed from the
	      copy of the queue on host2. The state of queue-a on host2 will
	      thus mirror that of the equivalent queue on host1, albeit with a
	      small lag. (Note
	      however that we must not have clients connected to host2 publish
	      to-or consume from- queue-a or the state will fail to replicate
	      correctly due to conflicts).
	    </p><p>
	      Any message enqueued on queue-b on host1 will also be enqueued on
	      the equivalent queue on host2. However the acknowledgement and
	      consequent dequeuing of messages from queue-b on host1 will have
	      no effect on the state of queue-b on host2.
	    </p><p>
	      (*1) If not the paths in the above may need to be modified. E.g.
	      if using modules built from a qpid svn checkout, the following
	      would be added to the command line used to start qpidd on host1:
	    </p><pre class="programlisting">
    --load-module &lt;path-to-qpid-dir&gt;/src/.libs/replicating_listener.so
	    </pre><p>
	      and the following for the equivalent command line on host2:
	    </p><pre class="programlisting">
    --load-module &lt;path-to-qpid-dir&gt;/src/.libs/replication_exchange.so
	    </pre></div></div></div><div class="section" title="1.8.&#160; Producer Flow Control"><div class="titlepage"><div><div><h2 class="title"><a id="producer-flow-control" />1.8.&#160;
    Producer Flow Control
  </h2></div></div></div><div class="section" title="1.8.1.&#160; Overview"><div class="titlepage"><div><div><h3 class="title"><a id="producerflowcontrol-Overview" />1.8.1.&#160;
      Overview
    </h3></div></div></div><p>
	As of release 0.10, the C++ broker supports the use of flow control to
	throttle back message producers that are at risk of overflowing a
	destination queue.
      </p><p>
        Each queue in the C++ broker has two threshold values associated with it:
      </p><p>
        Flow Stop Threshold: this is the level of queue resource
        utilization above which flow control will be enabled.  Once this
        threshold is crossed, the queue is considered in danger of overflow.
      </p><p>
        Flow Resume Threshold - this is the level of queue resource utilization
        below which flow control will be disabled.  Once this threshold is
        crossed, the queue is no longer considered in danger of overflow.
      </p><p>
        In the above description, queue resource utilization may be
        defined as the total count of messages currently enqueued, or the total
        sum of all message content in bytes.
      </p><p>
        The value for a queue's Flow Stop Threshold must be greater than or
        equal to the value of the queue's Flow Resume Threshold.
      </p><div class="section" title="1.8.1.1.&#160; Example"><div class="titlepage"><div><div><h4 class="title"><a id="producerflowcontrol-QueueThresholdsExample" />1.8.1.1.&#160;
	Example
      </h4></div></div></div><p>
        Let's consider a queue with a maximum limit set on the total number of
        messages that may be enqueued to that queue.  Assume this maximum
        message limit is 1000 messages.  Assume also that the user configures a
        Flow Stop Threshold of 900 messages, and a Flow Resume Threshold of 500
        messages.  Then the following holds:
      </p><p>
        The queue's initial flow control state is "OFF".
      </p><p>
        While the total number of enqueued messages is less than or equal to
        900, the queue's flow control state remains "OFF".
      </p><p>
        When the total number of enqueued messages is greater than 900, the
        queue's flow control state transitions to "ON".
      </p><p>
        When the queue's flow control state is "ON", it remains "ON" until the
        total number of enqueued messages is less than 500.  At that point, the queue's
        flow control state transitions to "OFF".
      </p><p>
        A similar example using total enqueued content bytes as the threshold
        units are permitted.
      </p></div><p>
      Thresholds may be set using both total message counts and total byte
      counts.  In this case, the following rules apply:
    </p><p>
      1) Flow control is "ON" when either stop threshold value is crossed.
    </p><p>
      2) Flow control remains "ON" until both resume thresholds are satisfied.
    </p><div class="section" title="1.8.1.2.&#160; Example"><div class="titlepage"><div><div><h4 class="title"><a id="producerflowcontro-MultiThresholdExample" />1.8.1.2.&#160;
	Example
      </h4></div></div></div><p>
      Let's consider a queue with a maximum size limit of 10K bytes, and 5000
      messages.  A user may assign a Flow Stop Threshold based on a total
      message count of 4000 messages.  They may also assigne a Flow Stop
      Threshold of 8K bytes.  The queue's flow control state transitions to
      "ON" if either threshold is crossed: (total-msgs greater-than 4000 OR total-bytes
      greater-than 8K).
    </p><p>
      Assume the user has assigned Flow Resume threshold's of 3000 messages and
      6K bytes.  Then the queue's flow control will remain active until both
      thresholds are satified: (total-msg less-than 3000 AND total-bytes less-than 6K).
    </p></div><p>
      The Broker enforces flow control by delaying the completion of the
      Message.Transfer command that causes a message to be delivered to a queue
      with active flow control.  The completion of the Message.Transfer command
      is held off until flow control state transitions to "OFF" for all queues
      that are a destination for that command.
    </p><p>
      A message producing client is permitted to have a finite number of
      commands pending completion.  When the total number of these outstanding
      commands reaches the limit, the client must not issue further commands
      until one or more of the outstanding commands have completed.  This
      window of outstanding commands is considered the sender's "capacity".
      This allows any given producer to have a "capacity's" worth of messages
      blocked due to flow control before the sender must stop sending further
      messages.
      </p><p>
        This capacity window must be considered when determining a suitable
        flow stop threshold for a given queue, as a producer may send its
        capacity worth of messages _after_ a queue has reached the flow stop
        threshold.  Therefore, a flow stop threshould should be set such that
        the queue can accomodate more messages without overflowing.
      </p><p>
        For example, assume two clients, C1 and C2, are producing messages to
        one particular destination queue.  Assume client C1 has a configured
        capacity of 50 messages, and client C2's capacity is 15 messages.  In
        this example, assume C1 and C2 are the only clients queuing messages to
        a given queue.  If this queue has a Flow Stop Threshold of 100
        messages, then, worst-case, the queue may receive up to 165 messages
        before clients C1 and C2 are blocked from sending further messages.
        This is due to the fact that the queue will enable flow control on
        receipt of its 101'st message - preventing the completion of the
        Message.Transfer command that carried the 101'st message.  However, C1
        and C2 are allowed to have a total of 65 (50 for C1 and 15 for C2)
        messages pending completion of Message.Transfer before they will stop
        producing messages.  Thus, up to 65 messages may be enqueued beyond the
        flow stop threshold before the producers will be blocked.
      </p></div><div class="section" title="1.8.2.&#160; User Interface"><div class="titlepage"><div><div><h3 class="title"><a id="producerflowcontrol-UserInterface" />1.8.2.&#160;
        User Interface
      </h3></div></div></div><p>
        By default, the C++ broker assigns a queue's flow stop and flow resume
        thresholds when the queue is created.  The C++ broker also allows the
        user to manually specify the flow control thresholds on a per queue
        basis.
      </p><p>
        However, queues that have been configured with a Limit Policy of type
        RING or RING-STRICT do NOT have queue flow thresholds enabled by
        default.  The nature of a RING queue defines its behavior when its
        capacity is reach: replace the oldest message.
      </p><p>
        The flow control state of a queue can be determined by the "flowState"
        boolean in the queue's QMF management object.  The queue's management
        object also contains a counter that increments each time flow control
        becomes active for the queue.
      </p><p>
        The broker applies a threshold ratio to compute a queue's default flow
        control configuration.  These thresholds are expressed as a percentage
        of a queue's maximum capacity.  There is one value for determining the
        stop threshold, and another for determining the resume threshold.  The
        user may configure these percentages using the following broker
        configuration options:
      </p><pre class="programlisting">
        --default-flow-stop-threshold ("Queue capacity level at which flow control is activated.")
        --default-flow-resume-threshold ("Queue capacity level at which flow control is de-activated.")
      </pre><p>
        For example:
      </p><pre class="programlisting">
        qpidd --default-flow-stop-threshold=90 --default-flow-resume-threshold=75
      </pre><p>
        Sets the default flow stop threshold to 90% of a queue's maximum
        capacity and the flow resume threshold to 75% of the maximum capacity.
        If a queue is created with a default-queue-limit of 10000 bytes, then
        the default flow stop threshold would be 90% of 10000 = 9000 bytes and
        the flow resume threshold would be 75% of 10000 = 7500.  The same
        computation is performed should a queue be created with a maximum size
        expressed as a message count instead of a byte count.
      </p><p>
        If not overridden by the user, the value of the
        default-flow-stop-threshold is 80% and the value of the
        default-flow-resume-threshold is 70%.
      </p><p>
        The user may disable default queue flow control broker-wide by
        specifying the value 0 for both of these configuration options.  Note
        that flow control may still be applied manually on a per-queue basis in
        this case.
      </p><p>
        The user may manually set the flow thresholds when creating a queue.
        The following options may be provided when adding a queue using the
        <span class="command"><strong>qpid-config</strong></span> command line tool:
      </p><pre class="programlisting">
        --flow-stop-size=<em class="replaceable"><code>N</code></em>  Sets the queue's flow stop threshold to <em class="replaceable"><code>N</code></em> total bytes.
        --flow-resume-size=<em class="replaceable"><code>N</code></em>  Sets the queue's flow resume threshold to <em class="replaceable"><code>N</code></em> total bytes.
        --flow-stop-count=<em class="replaceable"><code>N</code></em> Sets the queue's flow stop threshold to <em class="replaceable"><code>N</code></em> total messages.
        --flow-resume-count=<em class="replaceable"><code>N</code></em> Sets the queue's flow resume threshold to <em class="replaceable"><code>N</code></em> total messages.
      </pre><p>
        Flow thresholds may also be specified in the
        <span class="command"><strong>queue.declare</strong></span> method, via the
        <span class="command"><strong>arguments</strong></span> parameter map.  The following keys can be
        provided in the arguments map for setting flow thresholds:
      </p><div class="table"><a id="idp31134576" /><p class="title"><strong>Table&#160;1.12.&#160;Queue Declare Method Flow Control Arguments</strong></p><div class="table-contents"><table border="1" summary="Queue Declare Method Flow Control Arguments"><colgroup><col /><col /></colgroup><thead><tr><th>Key</th><th>Value</th></tr></thead><tbody><tr><td>qpid.flow_stop_size</td><td>integer - queue's flow stop threshold value in bytes</td></tr><tr><td>qpid.flow_resume_size</td><td>integer - queue's flow resume threshold value in bytes</td></tr><tr><td>qpid.flow_stop_count</td><td>integer - queue's flow stop threshold value as a message count</td></tr><tr><td>qpid.flow_resume_count</td><td>integer - queue's flow resume threshold value as a message count</td></tr></tbody></table></div></div><br class="table-break" /><p>
        The user may disable flow control on a per queue basis by setting
        the flow-stop-size and flow-stop-count to zero for the queue.
      </p><p>
        The current state of flow control for a given queue can be
        determined by the "flowStopped" statistic.  This statistic is
        available in the queue's QMF management object. The value of
        flowStopped is True when the queue's capacity has exceeded the
        flow stop threshold.  The value of flowStopped is False when the
        queue is no longer blocking due to flow control.
      </p><p>
        A queue will also track the number of times flow control has been
        activated.  The "flowStoppedCount" statistic is incremented each time
        the queue's capacity exceeds a flow stop threshold.  This statistic can
        be used to monitor the activity of flow control for any given queue
        over time.
      </p><div class="table"><a id="idp32099808" /><p class="title"><strong>Table&#160;1.13.&#160;Flow Control Statistics available in Queue's QMF Class</strong></p><div class="table-contents"><table border="1" summary="Flow Control Statistics available in Queue's QMF Class"><colgroup><col /><col /><col /></colgroup><thead><tr><th>Statistic Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>flowStopped</td><td>Boolean</td><td>If true, producers are blocked by flow control.</td></tr><tr><td>flowStoppedCount</td><td>count32</td><td>Number of times flow control was activated for this queue</td></tr></tbody></table></div></div><br class="table-break" /></div></div><div class="section" title="1.9.&#160; AMQP compatibility"><div class="titlepage"><div><div><h2 class="title"><a id="AMQP-Compatibility" />1.9.&#160;
      AMQP compatibility
    </h2></div></div></div><p>
            Qpid provides the most complete and compatible implementation
            of AMQP. And is the most aggressive in implementing the latest
            version of the specification.
          </p><p>
            There are two brokers:
          </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>C++ with support for AMQP 0-10</p></li><li class="listitem"><p>Java with support for AMQP 0-8 and 0-9 (0-10 planned)</p></li></ul></div><p>
            There are client libraries for C++, Java (JMS), .Net (written in
            C#), python and ruby.
          </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>All clients support 0-10 and interoperate with the C++
            broker.
            </p></li></ul></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The JMS client supports 0-8, 0-9 and 0-10 and interoperates
            with both brokers.
            </p></li></ul></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The python and ruby clients will also support all versions,
            but the API is dynamically driven by the specification used and
            so differs between versions. To work with the Java broker you
            must use 0-8 or 0-9, to work with the C++ broker you must use
            0-10.
            </p></li></ul></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>There are two separate C# clients, one for 0-8 that
            interoperates with the Java broker, one for 0-10 that
            inteoperates with the C++ broker.
            </p></li></ul></div><p>
            QMF Management is supported in Ruby, Python, C++, and via QMan
            for Java JMX &amp; WS-DM.
          </p><div class="section" title="1.9.1.&#160; AMQP Compatibility of Qpid releases:"><div class="titlepage"><div><div><h3 class="title"><a id="AMQPcompatibility-AMQPCompatibilityofQpidreleases-3A" />1.9.1.&#160;
            AMQP
            Compatibility of Qpid releases:
          </h3></div></div></div><p>
            Qpid implements the AMQP Specification, and as the specification
            has progressed Qpid is keeping up with the updates. This means
            that different Qpid versions support different versions of AMQP.
            Here is a simple guide on what use.
          </p><p>
            Here is a matrix that describes the different versions supported
            by each release. The status symbols are interpreted as follows:
          </p><div class="variablelist"><dl><dt><span class="term">Y</span></dt><dd><p>supported</p></dd><dt><span class="term">N</span></dt><dd><p>unsupported</p></dd><dt><span class="term">IP</span></dt><dd><p>in progress</p></dd><dt><span class="term">P</span></dt><dd><p>planned</p></dd></dl></div><div class="table"><a id="idp27396656" /><p class="title"><strong>Table&#160;1.14.&#160;AMQP Version Support by Qpid Release</strong></p><div class="table-contents"><table border="1" summary="AMQP Version Support by Qpid Release"><colgroup><col /><col /><col /><col /><col /><col /></colgroup><tbody><tr><td>
                  Component
                </td><td>
                  Spec
                </td><td>
                  &#160;
                </td><td>
                  &#160;
                </td><td>
                  &#160;
                </td><td>
                  &#160;
                </td></tr><tr><td>
                  &#160;
                </td><td>
                  &#160;
                </td><td>
                  M2.1
                </td><td>
                  M3
                </td><td>
                  M4
                </td><td>
                  0.5
                </td></tr><tr><td>
                  java client
                </td><td>
                  0-10
                </td><td>
                  &#160;
                </td><td>
                  Y
                </td><td>
                  Y
                </td><td>
                  Y
                </td></tr><tr><td>
                  &#160;
                </td><td>
                  0-9
                </td><td>
                  Y
                </td><td>
                  Y
                </td><td>
                  Y
                </td><td>
                  Y
                </td></tr><tr><td>
                  &#160;
                </td><td>
                  0-8
                </td><td>
                  Y
                </td><td>
                  Y
                </td><td>
                  Y
                </td><td>
                  Y
                </td></tr><tr><td>
                  java broker
                </td><td>
                  0-10
                </td><td>
                  &#160;
                </td><td>
                  &#160;
                </td><td>
                  &#160;
                </td><td>
                  P
                </td></tr><tr><td>
                  &#160;
                </td><td>
                  0-9
                </td><td>
                  Y
                </td><td>
                  Y
                </td><td>
                  Y
                </td><td>
                  Y
                </td></tr><tr><td>
                  &#160;
                </td><td>
                  0-8
                </td><td>
                  Y
                </td><td>
                  Y
                </td><td>
                  Y
                </td><td>
                  Y
                </td></tr><tr><td>
                  c++ client/broker
                </td><td>
                  0-10
                </td><td>
                  &#160;
                </td><td>
                  Y
                </td><td>
                  Y
                </td><td>
                  Y
                </td></tr><tr><td>
                  &#160;
                </td><td>
                  0-9
                </td><td>
                  Y
                </td><td>
                  &#160;
                </td><td>
                  &#160;
                </td><td>
                  &#160;
                </td></tr><tr><td>
                  python client
                </td><td>
                  0-10
                </td><td>
                  &#160;
                </td><td>
                  Y
                </td><td>
                  Y
                </td><td>
                  Y
                </td></tr><tr><td>
                  &#160;
                </td><td>
                  0-9
                </td><td>
                  Y
                </td><td>
                  Y
                </td><td>
                  Y
                </td><td>
                  Y
                </td></tr><tr><td>
                  &#160;
                </td><td>
                  0-8
                </td><td>
                  Y
                </td><td>
                  Y
                </td><td>
                  Y
                </td><td>
                  Y
                </td></tr><tr><td>
                  ruby client
                </td><td>
                  0-10
                </td><td>
                  &#160;
                </td><td>
                  &#160;
                </td><td>
                  Y
                </td><td>
                  Y
                </td></tr><tr><td>
                  &#160;
                </td><td>
                  0-8
                </td><td>
                  Y
                </td><td>
                  Y
                </td><td>
                  Y
                </td><td>
                  Y
                </td></tr><tr><td>
                  C# client
                </td><td>
                  0-10
                </td><td>
                  &#160;
                </td><td>
                  &#160;
                </td><td>
                  Y
                </td><td>
                  Y
                </td></tr><tr><td>
                  &#160;
                </td><td>
                  0-8
                </td><td>
                  Y
                </td><td>
                  Y
                </td><td>
                  Y
                </td><td>
                  Y
                </td></tr></tbody></table></div></div><br class="table-break" /></div><div class="section" title="1.9.2.&#160; Interop table by AMQP specification version"><div class="titlepage"><div><div><h3 class="title"><a id="AMQPcompatibility-InteroptablebyAMQPspecificationversion" />1.9.2.&#160;
            Interop
            table by AMQP specification version
          </h3></div></div></div><p>
            Above table represented in another format.
          </p><div class="table"><a id="idp30294160" /><p class="title"><strong>Table&#160;1.15.&#160;AMQP Version Support - alternate format</strong></p><div class="table-contents"><table border="1" summary="AMQP Version Support - alternate format"><colgroup><col /><col /><col /><col /><col /></colgroup><tbody><tr><td>
                  &#160;
                </td><td>
                  release
                </td><td>
                  0-8
                </td><td>
                  0-9
                </td><td>
                  0-10
                </td></tr><tr><td>
                  java client
                </td><td>
                  M3 M4 0.5
                </td><td>
                  Y
                </td><td>
                  Y
                </td><td>
                  Y
                </td></tr><tr><td>
                  java client
                </td><td>
                  M2.1
                </td><td>
                  Y
                </td><td>
                  Y
                </td><td>
                  N
                </td></tr><tr><td>
                  java broker
                </td><td>
                  M3 M4 0.5
                </td><td>
                  Y
                </td><td>
                  Y
                </td><td>
                  N
                </td></tr><tr><td>
                  java broker
                </td><td>
                  trunk
                </td><td>
                  Y
                </td><td>
                  Y
                </td><td>
                  P
                </td></tr><tr><td>
                  java broker
                </td><td>
                  M2.1
                </td><td>
                  Y
                </td><td>
                  Y
                </td><td>
                  N
                </td></tr><tr><td>
                  c++ client/broker
                </td><td>
                  M3 M4 0.5
                </td><td>
                  N
                </td><td>
                  N
                </td><td>
                  Y
                </td></tr><tr><td>
                  c++ client/broker
                </td><td>
                  M2.1
                </td><td>
                  N
                </td><td>
                  Y
                </td><td>
                  N
                </td></tr><tr><td>
                  python client
                </td><td>
                  M3 M4 0.5
                </td><td>
                  Y
                </td><td>
                  Y
                </td><td>
                  Y
                </td></tr><tr><td>
                  python client
                </td><td>
                  M2.1
                </td><td>
                  Y
                </td><td>
                  Y
                </td><td>
                  N
                </td></tr><tr><td>
                  ruby client
                </td><td>
                  M3 M4 0.5
                </td><td>
                  Y
                </td><td>
                  Y
                </td><td>
                  N
                </td></tr><tr><td>
                  ruby client
                </td><td>
                  trunk
                </td><td>
                  Y
                </td><td>
                  Y
                </td><td>
                  P
                </td></tr><tr><td>
                  C# client
                </td><td>
                  M3 M4 0.5
                </td><td>
                  Y
                </td><td>
                  N
                </td><td>
                  N
                </td></tr><tr><td>
                  C# client
                </td><td>
                  trunk
                </td><td>
                  Y
                </td><td>
                  N
                </td><td>
                  Y
                </td></tr></tbody></table></div></div><br class="table-break" /></div></div><div class="section" title="1.10.&#160;Qpid Interoperability Documentation"><div class="titlepage"><div><div><h2 class="title"><a id="QpidInteroperabilityDocumentation-QpidInteroperabilityDocumentation" />1.10.&#160;Qpid Interoperability Documentation</h2></div></div></div><p>
            This page documents the various interoperable features of the
            Qpid clients.
          </p><div class="section" title="1.10.1.&#160; SASL"><div class="titlepage"><div><div><h3 class="title"><a id="QpidInteroperabilityDocumentation-SASL" />1.10.1.&#160;
            SASL
          </h3></div></div></div><p>
            
          </p><div class="section" title="1.10.1.1.&#160; Standard Mechanisms"><div class="titlepage"><div><div><h4 class="title"><a id="QpidInteroperabilityDocumentation-StandardMechanisms" />1.10.1.1.&#160;
            Standard
            Mechanisms
          </h4></div></div></div><p>
            <a class="ulink" href="http://en.wikipedia.org/wiki/Simple_Authentication_and_Security_Layer#SASL_mechanisms" target="_top">http://en.wikipedia.org/wiki/Simple_Authentication_and_Security_Layer#SASL_mechanisms</a>
          </p><p>
            This table list the various SASL mechanisms that each component
            supports. The version listed shows when this
            functionality was added to the product.
          </p><div class="table"><a id="idp27690240" /><p class="title"><strong>Table&#160;1.16.&#160;SASL Mechanism Support</strong></p><div class="table-contents"><table border="1" summary="SASL Mechanism Support"><colgroup><col /><col /><col /><col /><col /><col /><col /></colgroup><tbody><tr><td>
                  Component
                </td><td>
                  ANONYMOUS
                </td><td>
                  CRAM-MD5
                </td><td>
                  DIGEST-MD5
                </td><td>
                  EXTERNAL
                </td><td>
                  GSSAPI/Kerberos
                </td><td>
                  PLAIN
                </td></tr><tr><td>
                  C++ Broker
                </td><td>
                  M3[<a class="xref" href="#QpidInteroperabilityDocumentation-1">Section&#160;1.10.1.1, &#8220;
            Standard
            Mechanisms
          &#8221;</a>]
                </td><td>
                  M3[<a class="xref" href="#QpidInteroperabilityDocumentation-1">Section&#160;1.10.1.1, &#8220;
            Standard
            Mechanisms
          &#8221;</a>,<a class="xref" href="#QpidInteroperabilityDocumentation-2">Section&#160;1.10.1.1, &#8220;
            Standard
            Mechanisms
          &#8221;</a>]
                </td><td>
                  &#160;
                </td><td>
                  &#160;
                </td><td>
                  M3[<a class="xref" href="#QpidInteroperabilityDocumentation-1">Section&#160;1.10.1.1, &#8220;
            Standard
            Mechanisms
          &#8221;</a>,<a class="xref" href="#QpidInteroperabilityDocumentation-2">Section&#160;1.10.1.1, &#8220;
            Standard
            Mechanisms
          &#8221;</a>]
                </td><td>
                  M1
                </td></tr><tr><td>
                  C++ Client
                </td><td>
                  M3[<a class="xref" href="#QpidInteroperabilityDocumentation-1">Section&#160;1.10.1.1, &#8220;
            Standard
            Mechanisms
          &#8221;</a>]
                </td><td>
                  &#160;
                </td><td>
                  &#160;
                </td><td>
                  &#160;
                </td><td>
                  &#160;
                </td><td>
                  M1
                </td></tr><tr><td>
                  Java Broker
                </td><td>
                  &#160;
                </td><td>
                  M1
                </td><td>
                  &#160;
                </td><td>
                  &#160;
                </td><td>
                  &#160;
                </td><td>
                  M1
                </td></tr><tr><td>
                  Java Client
                </td><td>
                  &#160;
                </td><td>
                  M1
                </td><td>
                  &#160;
                </td><td>
                  &#160;
                </td><td>
                  &#160;
                </td><td>
                  M1
                </td></tr><tr><td>
                  .Net Client
                </td><td>
                  M2
                </td><td>
                  M2
                </td><td>
                  M2
                </td><td>
                  M2
                </td><td>
                  &#160;
                </td><td>
                  M2
                </td></tr><tr><td>
                  Python Client
                </td><td>
                  &#160;
                </td><td>
                  &#160;
                </td><td>
                  &#160;
                </td><td>
                  &#160;
                </td><td>
                  &#160;
                </td><td>
                  ?
                </td></tr><tr><td>
                  Ruby Client
                </td><td>
                  &#160;
                </td><td>
                  &#160;
                </td><td>
                  &#160;
                </td><td>
                  &#160;
                </td><td>
                  &#160;
                </td><td>
                  ?
                </td></tr></tbody></table></div></div><br class="table-break" /><p><a id="QpidInteroperabilityDocumentation-1" />        
            1: Support for these will be in M3 (currently available on
            trunk).
	  </p><p><a id="QpidInteroperabilityDocumentation-2" />2: C++ Broker uses <a class="ulink" href="http://freshmeat.net/projects/cyrussasl/" target="_top">Cyrus SASL</a> which
            supports CRAM-MD5 and GSSAPI but these have not been tested yet
          </p></div><div class="section" title="1.10.1.2.&#160; Custom Mechanisms"><div class="titlepage"><div><div><h4 class="title"><a id="QpidInteroperabilityDocumentation-CustomMechanisms" />1.10.1.2.&#160;
            Custom
            Mechanisms
          </h4></div></div></div><p>
            There have been some custom mechanisms added to our
            implementations.
          </p><div class="table"><a id="idp30531280" /><p class="title"><strong>Table&#160;1.17.&#160;SASL Custom Mechanisms</strong></p><div class="table-contents"><table border="1" summary="SASL Custom Mechanisms"><colgroup><col /><col /><col /></colgroup><tbody><tr><td>
                  Component
                </td><td>
                  AMQPLAIN
                </td><td>
                  CRAM-MD5-HASHED
                </td></tr><tr><td>
                  C++ Broker
                </td><td>
                  &#160;
                </td><td>
                  &#160;
                </td></tr><tr><td>
                  C++ Client
                </td><td>
                  &#160;
                </td><td>
                  &#160;
                </td></tr><tr><td>
                  Java Broker
                </td><td>
                  M1
                </td><td>
                  M2
                </td></tr><tr><td>
                  Java Client
                </td><td>
                  M1
                </td><td>
                  M2
                </td></tr><tr><td>
                  .Net Client
                </td><td>
                  &#160;
                </td><td>
                  &#160;
                </td></tr><tr><td>
                  Python Client
                </td><td>
                  M2
                </td><td>
                  &#160;
                </td></tr><tr><td>
                  Ruby Client
                </td><td>
                  M2
                </td><td>
                  &#160;
                </td></tr></tbody></table></div></div><br class="table-break" /><div class="section" title="AMQPLAIN"><div class="titlepage"><div><div><h5 class="title"><a id="idp28187792" />AMQPLAIN</h5></div></div></div><p /></div><div class="section" title="CRAM-MD5-HASHED"><div class="titlepage"><div><div><h5 class="title"><a id="idp27840464" />CRAM-MD5-HASHED</h5></div></div></div><p>
            The Java SASL implementations require that you have the password
            of the user to validate the incoming request. This then means
            that the user's password must be stored on disk. For this to be
            secure either the broker must encrypt the password file or the
            need for the password being stored must be removed.
          </p><p>
            The CRAM-MD5-HASHED SASL plugin removes the need for the plain
            text password to be stored on disk. The mechanism defers all
            functionality to the build in CRAM-MD5 module the only change is
            on the client side where it generates the hash of the password
            and uses that value as the password. This means that the Java
            Broker only need store the password hash on the file system.
            While a one way hash is not very secure compared to other forms
            of encryption in environments where the having the password in
            plain text is unacceptable this will provide and additional layer
            to protect the password. In particular this offers some
            protection where the same password may be shared amongst many
            systems. It offers no real extra protection against attacks on
            the broker (the secret is now the hash rather than the password).
          </p></div></div></div></div><div class="section" title="1.11.&#160; Using Message Groups"><div class="titlepage"><div><div><h2 class="title"><a id="Using-message-groups" />1.11.&#160;
    Using Message Groups
  </h2></div></div></div><div class="section" title="1.11.1.&#160; Overview"><div class="titlepage"><div><div><h3 class="title"><a id="usingmessagegroups-Overview" />1.11.1.&#160;
      Overview
    </h3></div></div></div><p>
        The broker allows messaging applications to classify a set of related messages as
        belonging to a group.  This allows a message producer to indicate to the consumer
        that a group of messages should be considered a single logical operation with
        respect to the application.
      </p><p>
        The broker can use this group identification to enforce policies controlling how
        messages from a given group can be distributed to consumers.  For instance, the
        broker can be configured to guarantee all the messages from a particular group are
        processed in order across multiple consumers.
      </p><p>
        For example, assume we have a shopping application that manages items in a virtual
        shopping cart.  A user may add an item to their shopping cart, then change their
        mind and remove it.  If the application sends an <span class="emphasis"><em>add</em></span> message to the broker,
        immediately followed by a <span class="emphasis"><em>remove</em></span> message, they will be queued in the proper
        order - <span class="emphasis"><em>add</em></span>, followed by <span class="emphasis"><em>remove</em></span>.
      </p><p>
        However, if there are multiple consumers, it is possible that once a consumer
        acquires the <span class="emphasis"><em>add</em></span> message, a different consumer may acquire the
        <span class="emphasis"><em>remove</em></span> message.  This allows both messages to be processed in parallel,
        which could result in a "race" where the <span class="emphasis"><em>remove</em></span> operation is incorrectly
        performed before the <span class="emphasis"><em>add</em></span> operation.
      </p></div><div class="section" title="1.11.2.&#160; Grouping Messages"><div class="titlepage"><div><div><h3 class="title"><a id="usingmessagegroups-GroupingMessages" />1.11.2.&#160;
        Grouping Messages
      </h3></div></div></div><p>
        In order to group messages, the application would designate a particular
        message header as containing a message's <span class="emphasis"><em>group identifier</em></span>.  The group
        identifier stored in that header field would be a string value set by the message
        producer.  Messages from the same group would have the same group identifier
        value. The key that identifies the header must also be known to the message
        consumers.  This allows the consumers to determine a message's assigned group.
      </p><p>
        The header that is used to hold the group identifier, as well as the values used
        as group identifiers, are totally under control of the application.
      </p></div><div class="section" title="1.11.3.&#160; The Role of the Broker"><div class="titlepage"><div><div><h3 class="title"><a id="usingmessagegroups-BrokerRole" />1.11.3.&#160;
        The Role of the Broker
      </h3></div></div></div><p>
        The broker will apply the following processing on each grouped message:
        </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Enqueue a received message on the destination queue.</li><li class="listitem">Determine the message's group by examining the message's group identifier header.</li><li class="listitem">Enforce <span class="emphasis"><em>consumption ordering</em></span> among messages belonging to the same group.</li></ul></div><p>
        <span class="emphasis"><em>Consumption ordering</em></span> means that the broker will not allow outstanding
        unacknowledged messages to <span class="emphasis"><em>more than one consumer for a given group</em></span>.
      </p><p>
        This means that only one consumer can be processing messages from a particular
        group at a given time.  When the consumer acknowledges all of its acquired
        messages, then the broker <span class="emphasis"><em>may</em></span> pass the next pending message
        from that group to a different consumer.
      </p><p>
        Specifically, for any given group the broker allows only the first N messages in
        the group to be delivered to a consumer.  The value of N would be determined by
        the selected consumer's configured prefetch capacity.  The broker blocks access by
        any other consumer to any remaining undelivered messages in that group.  Once the
        receiving consumer has:
        </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">acknowledged,</li><li class="listitem">released, or</li><li class="listitem">rejected</li></ul></div><p>
        all the delivered messages, the broker allows the next messages in the group to be
        delivered.  The next messages <span class="emphasis"><em>may</em></span> be delivered to a different
        consumer.
      </p><p>
        Note well that distinct message groups would not block each other from delivery.
        For example, assume a queue contains messages from two different message groups -
        say group "A" and group "B" - and they are enqueued such that "A"'s messages are
        in front of "B". If the first message of group "A" is in the process of being
        consumed by a client, then the remaining "A" messages are blocked, but the
        messages of the "B" group are available for consumption by other consumers - even
        though it is "behind" group "A" in the queue.
      </p></div><div class="section" title="1.11.4.&#160; Well Behaved Consumers"><div class="titlepage"><div><div><h3 class="title"><a id="usingmessagegroups-ConsumerGuide" />1.11.4.&#160;
        Well Behaved Consumers
      </h3></div></div></div><p>
        The broker can only enforce policy when delivering messages. To guarantee that
        strict message ordering is preserved, the consuming application must adhere to the
        following rules:
        </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">completely process the data in a received message before accepting
          that message</li><li class="listitem">acknowledge (or reject) messages in the same order as they are
          received</li><li class="listitem">avoid releasing messages (see below)</li></ul></div><p>
        The term <span class="emphasis"><em>processed</em></span> means that the consumer has finished
        updating all application state affected by the message that has been received.
        See section 2.6.2. Transfer of Responsibility, of the AMQP-0.10 specification for
        more detail.
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;" title="Be Advised"><h3 class="title">Be Advised</h3><p>
          If a consumer does not adhere to the above rules, it may affect the ordering of
          grouped messages even when the broker is enforcing consumption order.  This can
          be done by selectively acknowledging and releasing messages from the same group.
        </p><p>
          Assume a consumer has received two messages from group "A", "A-1" and "A-2", in
          that order.  If the consumer releases "A-1" then acknowledges "A-2", "A-1" will
          be put back onto the queue and "A-2" will be removed from the queue.  This
          allows another consumer to acquire and process "A-1" <span class="emphasis"><em>after</em></span>
          "A-2" has been processed.
        </p><p>
          Under some application-defined circumstances, this may be acceptable behavior.
          However, if order must be preserved, the client should either release
          <span class="emphasis"><em>all</em></span> currently held messages, or discard the target message
          using reject.
        </p></div></div><div class="section" title="1.11.5.&#160; Broker Configuration"><div class="titlepage"><div><div><h3 class="title"><a id="usingmessagegroups-BrokerConfig" />1.11.5.&#160;
        Broker Configuration
      </h3></div></div></div><p>
        In order for the broker to determine a message's group, the key for the header
        that contains the group identifier must be provided to the broker via
        configuration.  This is done on a per-queue basis, when the queue is first
        configured.
      </p><p>
        This means that message group classification is determined by the message's destination
        queue.
      </p><p>
        Specifically, the queue "holds" the header key that is used to find the message's
        group identifier.  All messages arriving at the queue are expected to use the same
        header key for holding the identifer.  Once the message is enqueued, the broker
        looks up the group identifier in the message's header, and classifies the message
        by its group.
      </p><p>
        Message group support can be enabled on a queue using the
        <span class="command"><strong>qpid-config</strong></span> command line tool.  The following options should be
        provided when adding a new queue:
        </p><div class="table"><a id="idp29354752" /><p class="title"><strong>Table&#160;1.18.&#160;qpid-config options for creating message group queues</strong></p><div class="table-contents"><table border="1" summary="qpid-config options for creating message group queues"><colgroup><col /><col /></colgroup><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td>--group-header=<em class="replaceable"><code>header-name</code></em></td><td>Enable message group support for this queue. Specify name of application header that holds the group identifier.</td></tr><tr><td>--shared-groups</td><td>Enforce ordered message group consumption across multiple consumers.</td></tr></tbody></table></div></div><p><br class="table-break" />
      </p><p>
        Message group support may also be specified in the
        <span class="command"><strong>queue.declare</strong></span> method via the <span class="command"><strong>arguments</strong></span>
        parameter map, or using the messaging address syntax.  The following keys must be
        provided in the arguments map to enable message group support on a queue:
      </p><div class="table"><a id="idp27709280" /><p class="title"><strong>Table&#160;1.19.&#160;Queue Declare/Address Syntax Message Group Configuration Arguments</strong></p><div class="table-contents"><table border="1" summary="Queue Declare/Address Syntax Message Group Configuration Arguments"><colgroup><col /><col /></colgroup><thead><tr><th>Key</th><th>Value</th></tr></thead><tbody><tr><td>qpid.group_header_key</td><td>string - key for message header that holds the group identifier value</td></tr><tr><td>qpid.shared_msg_group</td><td>1 - enforce ordering across multiple consumers</td></tr></tbody></table></div></div><br class="table-break" /><p>
        It is important to note that there is no need to provide the actual group
        identifer values that will be used. The broker learns this values as messages are
        recieved.  Also, there is no practical limit - aside from resource limitations -
        to the number of different groups that the broker can track at run time.
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;" title="Restrictions"><h3 class="title">Restrictions</h3><p>
          Message grouping is not supported on LVQ or Priority queues.
        </p></div><div class="example"><a id="idp30717904" /><p class="title"><strong>Example&#160;1.2.&#160;Creating a message group queue via qpid-config</strong></p><div class="example-contents"><p>
          This example uses the qpid-config tool to create a message group queue called
          "MyMsgQueue".  The message header that contains the group identifier will use
          the key "GROUP_KEY".
        </p><pre class="programlisting">
qpid-config add queue MyMsgQueue --group-header="GROUP_KEY" --shared-groups
        </pre></div></div><br class="example-break" /><div class="example"><a id="idp29249200" /><p class="title"><strong>Example&#160;1.3.&#160;Creating a message group queue using address syntax (C++)</strong></p><div class="example-contents"><p>
          This example uses the messaging address syntax to create a message group queue
          with the same configuration as the previous example.
        </p><pre class="programlisting">
sender = session.createSender("MyMsgQueue;"
                              " {create:always, delete:receiver,"
                              " node: {x-declare: {arguments:"
                              " {'qpid.group_header_key':'GROUP_KEY',"
                              " 'qpid.shared_msg_group':1}}}}")
        </pre></div></div><br class="example-break" /><div class="section" title="1.11.5.1.&#160; Default Group"><div class="titlepage"><div><div><h4 class="title"><a id="usingmessagegroups-DefaultGroup" />1.11.5.1.&#160;
          Default Group
        </h4></div></div></div><p>
          Should a message without a group identifier arrive at a queue configured for message grouping, the broker assigns the message to the default group.  Therefore, all such "unidentified" messages are considered by the broker as part of the same group.  The name of the default group is <span class="command"><strong>"qpid.no-group"</strong></span>.  This default can be overridden by suppling a different value to the broker configuration item <span class="command"><strong>"default-message-group"</strong></span>:
          </p><div class="example"><a id="idp31950672" /><p class="title"><strong>Example&#160;1.4.&#160;Overriding the default message group identifier for the broker</strong></p><div class="example-contents"><pre class="programlisting">
qpidd --default-msg-group "EMPTY-GROUP"
            </pre></div></div><p><br class="example-break" />
        </p></div></div></div><div class="section" title="1.12.&#160;Active-Passive Messaging Clusters"><div class="titlepage"><div><div><h2 class="title"><a id="chapter-ha" />1.12.&#160;Active-Passive Messaging Clusters</h2></div></div></div><div class="section" title="1.12.1.&#160;Overview"><div class="titlepage"><div><div><h3 class="title"><a id="ha-overview" />1.12.1.&#160;Overview</h3></div></div></div><p>

      The High Availability (HA) module provides
      <em class="firstterm">active-passive</em>, <em class="firstterm">hot-standby</em>
      messaging clusters to provide fault tolerant message delivery.
    </p><p>
      In an active-passive cluster only one broker, known as the
      <em class="firstterm">primary</em>, is active and serving clients at a time. The other
      brokers are standing by as <em class="firstterm">backups</em>. Changes on the primary
      are replicated to all the backups so they are always up-to-date or "hot". Backup
      brokers reject client connection attempts, to enforce the requirement that clients
      only connect to the primary.
    </p><p>
      If the primary fails, one of the backups is promoted to take over as the new
      primary. Clients fail-over to the new primary automatically. If there are multiple
      backups, the other backups also fail-over to become backups of the new primary.
    </p><p>
      This approach relies on an external <em class="firstterm">cluster resource manager</em>
      to detect failures, choose the new primary and handle network partitions. <a class="ulink" href="https://fedorahosted.org/cluster/wiki/RGManager" target="_top">Rgmanager</a> is supported
      initially, but others may be supported in the future.
    </p><div class="section" title="1.12.1.1.&#160;Avoiding message loss"><div class="titlepage"><div><div><h4 class="title"><a id="ha-at-least-once" />1.12.1.1.&#160;Avoiding message loss</h4></div></div></div><p>
	In order to avoid message loss, the primary broker <span class="emphasis"><em>delays
	acknowledgment</em></span> of messages received from clients until the
	message has been replicated and acknowledged by all of the back-up
	brokers, or has been consumed from the primary queue.
      </p><p>
	This ensures that all acknowledged messages are safe: they have either
	been consumed or backed up to all backup brokers.  Messages that are
	consumed <span class="emphasis"><em>before</em></span> they are replicated do not need to
	be replicated. This reduces the work load when replicating a queue with
	active consumers.
      </p><p>
	Clients keep <span class="emphasis"><em>unacknowledged</em></span> messages in a buffer
	<sup>[<a class="footnote" href="#ftn.idp27743488" id="idp27743488">1</a>]</sup>
	until they are acknowledged by the primary. If the primary fails, clients will
	fail-over to the new primary and <span class="emphasis"><em>re-send</em></span> all their
	unacknowledged messages.
	<sup>[<a class="footnote" href="#ftn.idp27699536" id="idp27699536">2</a>]</sup>
      </p><p>
	If the primary crashes, all the <span class="emphasis"><em>acknowledged</em></span>
	messages will be available on the backup that takes over as the new
	primary. The <span class="emphasis"><em>unacknowledged</em></span> messages will be
	re-sent by the clients.  Thus no messages are lost.
      </p><p>
	Note that this means it is possible for messages to be
	<span class="emphasis"><em>duplicated</em></span>. In the event of a failure it is possible for a
	message to received by the backup that becomes the new primary
	<span class="emphasis"><em>and</em></span> re-sent by the client.  The application must take steps
	to identify and eliminate duplicates.
      </p><p>
	When a new primary is promoted after a fail-over it is initially in
	"recovering" mode. In this mode, it delays acknowledgment of messages
	on behalf of all the backups that were connected to the previous
	primary. This protects those messages against a failure of the new
	primary until the backups have a chance to connect and catch up.
      </p><p>
	Not all messages need to be replicated to the back-up brokers. If a
	message is consumed and acknowledged by a regular client before it has
	been replicated to a backup, then it doesn't need to be replicated.
      </p><div class="variablelist" title="Status of a HA broker"><p class="title"><strong>Status of a HA broker</strong></p><dl><dt><span class="term">Joining</span></dt><dd><p>
	      Initial status of a new broker that has not yet connected to the primary.
	    </p></dd><dt><span class="term">Catch-up</span></dt><dd><p>
	      A backup broker that is connected to the primary and catching up
	      on queues and messages.
	    </p></dd><dt><span class="term">Ready</span></dt><dd><p>
	      A backup broker that is fully caught-up and ready to take over as
	      primary.
	    </p></dd><dt><span class="term">Recovering</span></dt><dd><p>
	      The newly-promoted primary, waiting for backups to connect and catch up.
	    </p></dd><dt><span class="term">Active</span></dt><dd><p>
	      The active primary broker with all backups connected and caught-up.
	    </p></dd></dl></div></div><div class="section" title="1.12.1.2.&#160;Limitations"><div class="titlepage"><div><div><h4 class="title"><a id="limitations" />1.12.1.2.&#160;Limitations</h4></div></div></div><p>
	There are a some known limitations in the current implementation. These
	will be fixed in future versions.
      </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>
	    Transactional changes to queue state are not replicated atomically. If
	    the primary crashes during a transaction, it is possible that the
	    backup could contain only part of the changes introduced by a
	    transaction.
	  </p></li><li class="listitem"><p>
	    Configuration changes (creating or deleting queues, exchanges and
	    bindings) are replicated asynchronously. Management tools used to
	    make changes will consider the change complete when it is complete
	    on the primary, it may not yet be replicated to all the backups.
	  </p></li><li class="listitem"><p>
	    Federation links <span class="emphasis"><em>to</em></span> the primary will fail over
	    correctly.  Federated links <span class="emphasis"><em>from</em></span> the primary
	    will be lost in fail over, they will not be re-connected to the new
	    primary. It is possible to work around this by replacing the
	    <code class="literal">qpidd-primary</code> start up script with a script that
	    re-creates federation links when the primary is promoted.
	  </p></li></ul></div></div></div><div class="section" title="1.12.2.&#160;Virtual IP Addresses"><div class="titlepage"><div><div><h3 class="title"><a id="ha-virtual-ip" />1.12.2.&#160;Virtual IP Addresses</h3></div></div></div><p>
      Some resource managers (including <span class="command"><strong>rgmanager</strong></span>) support
      <em class="firstterm">virtual IP addresses</em>. A virtual IP address is an IP
      address that can be relocated to any of the nodes in a cluster.  The
      resource manager associates this address with the primary node in the
      cluster, and relocates it to the new primary when there is a failure. This
      simplifies configuration as you can publish a single IP address rather
      than a list.
    </p><p>
      A virtual IP address can be used by clients to connect to the primary. The
      following sections will explain how to configure virtual IP addresses for
      clients or brokers.
    </p></div><div class="section" title="1.12.3.&#160;Configuring the Brokers"><div class="titlepage"><div><div><h3 class="title"><a id="ha-broker-config" />1.12.3.&#160;Configuring the Brokers</h3></div></div></div><p>
      The broker must load the <code class="filename">ha</code> module, it is loaded by
      default. The following broker options are available for the HA module.
    </p><div class="table"><a id="ha-broker-options" /><p class="title"><strong>Table&#160;1.20.&#160;Broker Options for High Availability Messaging Cluster</strong></p><div class="table-contents"><table border="1" summary="Broker Options for High Availability Messaging Cluster"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /></colgroup><thead><tr><th align="center" colspan="2">
	      Options for High Availability Messaging Cluster
	    </th></tr></thead><tbody><tr><td align="left">
	      <code class="literal">ha-cluster <em class="replaceable"><code>yes|no</code></em></code>
	    </td><td align="left">
	      Set to "yes" to have the broker join a cluster.
	    </td></tr><tr><td align="left">
	      <code class="literal">ha-queue-replication <em class="replaceable"><code>yes|no</code></em></code>
	    </td><td align="left">
	      Enable replication of specific queues without joining a cluster, see <a class="xref" href="#ha-queue-replication" title="1.12.11.&#160;Replicating specific queues">Section&#160;1.12.11, &#8220;Replicating specific queues&#8221;</a>.
	    </td></tr><tr><td align="left">
	      <code class="literal">ha-brokers-url <em class="replaceable"><code>URL</code></em></code>
	    </td><td align="left">
	      <p>
		The URL
		<sup>[<a class="footnote" href="#ftn.ha-url-grammar" id="ha-url-grammar">a</a>]</sup>
		used by cluster brokers to connect to each other. The URL should
		contain a comma separated list of the broker addresses, rather than a
		virtual IP address.
	      </p>
	    </td></tr><tr><td align="left"><code class="literal">ha-public-url <em class="replaceable"><code>URL</code></em></code> </td><td align="left">
	      <p>
		The URL <sup>[<a class="footnoteref" href="#ftn.ha-url-grammar">a</a>]</sup> is advertised to
		clients as the "known-hosts" for fail-over.  It can be a list or
		a single virtual IP address. A virtual IP address is recommended.
	      </p>
	      <p>
		Using this option you can put client and broker traffic on
		separate networks, which is recommended.
	      </p>
	      <p>
		Note: When HA clustering is enabled the broker option
		<code class="literal">known-hosts-url</code> is ignored and over-ridden by
		the <code class="literal">ha-public-url</code> setting.
	      </p>
	    </td></tr><tr><td align="left"><code class="literal">ha-replicate </code><em class="replaceable"><code>VALUE</code></em></td><td align="left">
	      <p>
		Specifies whether queues and exchanges are replicated by default.
		<em class="replaceable"><code>VALUE</code></em> is one of: <code class="literal">none</code>,
		<code class="literal">configuration</code>, <code class="literal">all</code>.
		For details see <a class="xref" href="#">???</a>.
	      </p>
	    </td></tr><tr><td align="left">
	      <p><code class="literal">ha-username <em class="replaceable"><code>USER</code></em></code></p>
	      <p><code class="literal">ha-password <em class="replaceable"><code>PASS</code></em></code></p>
	      <p><code class="literal">ha-mechanism <em class="replaceable"><code>MECHANISM</code></em></code></p>
	    </td><td align="left">
	      Authentication settings used by HA brokers to connect to each other.
	      If you are using authorization
	      (<a class="xref" href="#sect-Messaging_User_Guide-Security-Authorization" title="1.5.2.&#160;Authorization">Section&#160;1.5.2, &#8220;Authorization&#8221;</a>)
	      then this user must have all permissions.
	    </td></tr><tr><td align="left"><code class="literal">ha-backup-timeout <em class="replaceable"><code>SECONDS</code></em></code> </td><td align="left">
	      <p>
		Maximum time that a recovering primary will wait for an expected
		backup to connect and become ready.
	      </p>
	    </td></tr><tr><td align="left"><code class="literal">link-maintenance-interval <em class="replaceable"><code>SECONDS</code></em></code></td><td align="left">
	      <p>
		Interval for the broker to check link health and re-connect links if need
		be. If you want brokers to fail over quickly you can set this to a
		fraction of a second, for example: 0.1.
	      </p>
	    </td></tr><tr><td align="left"><code class="literal">link-heartbeat-interval <em class="replaceable"><code>SECONDS</code></em></code></td><td align="left">
	      <p>
		Heartbeat interval for replication links. The link will be assumed broken
		if there is no heartbeat for twice the interval.
	      </p>
	    </td></tr></tbody><tbody class="footnotes"><tr><td colspan="2"><div class="footnote"><p><sup>[<a class="para" href="#ha-url-grammar" id="ftn.ha-url-grammar">a</a>] </sup>
		  The full format of the URL is given by this grammar:
		  </p><pre class="programlisting">
url = ["amqp:"][ user ["/" password] "@" ] addr ("," addr)*
addr = tcp_addr / rmda_addr / ssl_addr / ...
tcp_addr = ["tcp:"] host [":" port]
rdma_addr = "rdma:" host [":" port]
ssl_addr = "ssl:" host [":" port]'
		  </pre><p>
		  </p></div></td></tr></tbody></table></div></div><br class="table-break" /><p>
      To configure a HA cluster you must set at least <code class="literal">ha-cluster</code> and
      <code class="literal">ha-brokers-url</code>.
    </p></div><div class="section" title="1.12.4.&#160;The Cluster Resource Manager"><div class="titlepage"><div><div><h3 class="title"><a id="ha-rm" />1.12.4.&#160;The Cluster Resource Manager</h3></div></div></div><p>
      Broker fail-over is managed by a <em class="firstterm">cluster resource
      manager</em>.  An integration with <a class="ulink" href="https://fedorahosted.org/cluster/wiki/RGManager" target="_top">rgmanager</a> is
      provided, but it is possible to integrate with other resource managers.
    </p><p>
      The resource manager is responsible for starting the <span class="command"><strong>qpidd</strong></span> broker
      on each node in the cluster. The resource manager then <em class="firstterm">promotes</em>
      one of the brokers to be the primary. The other brokers connect to the primary as
      backups, using the URL provided in the <code class="literal">ha-brokers-url</code> configuration
      option.
    </p><p>
      Once connected, the backup brokers synchronize their state with the
      primary.  When a backup is synchronized, or "hot", it is ready to take
      over if the primary fails.  Backup brokers continually receive updates
      from the primary in order to stay synchronized.
    </p><p>
      If the primary fails, backup brokers go into fail-over mode. The resource
      manager must detect the failure and promote one of the backups to be the
      new primary.  The other backups connect to the new primary and synchronize
      their state with it.
    </p><p>
      The resource manager is also responsible for protecting the cluster from
      <em class="firstterm">split-brain</em> conditions resulting from a network partition.  A
      network partition divide a cluster into two sub-groups which cannot see each other.
      Usually a <em class="firstterm">quorum</em> voting algorithm is used that disables nodes
      in the inquorate sub-group.
    </p></div><div class="section" title="1.12.5.&#160;Configuring rgmanager as resource manager"><div class="titlepage"><div><div><h3 class="title"><a id="ha-rm-config" />1.12.5.&#160;Configuring <span class="command"><strong>rgmanager</strong></span> as resource manager</h3></div></div></div><p>
      This section assumes that you are already familiar with setting up and configuring
      clustered services using <span class="command"><strong>cman</strong></span> and
      <span class="command"><strong>rgmanager</strong></span>. It will show you how to configure an active-passive,
      hot-standby <span class="command"><strong>qpidd</strong></span> HA cluster with <span class="command"><strong>rgmanager</strong></span>.
    </p><p>
      You must provide a <code class="literal">cluster.conf</code> file to configure
      <span class="command"><strong>cman</strong></span> and <span class="command"><strong>rgmanager</strong></span>.  Here is
      an example <code class="literal">cluster.conf</code> file for a cluster of 3 nodes named
      node1, node2 and node3. We will go through the configuration step-by-step.
    </p><pre class="programlisting">
      
&lt;?xml version="1.0"?&gt;
&lt;!--
This is an example of a cluster.conf file to run qpidd HA under rgmanager.
This example assumes a 3 node cluster, with nodes named node1, node2 and node3.

NOTE: fencing is not shown, you must configure fencing appropriately for your cluster.
--&gt;

&lt;cluster name="qpid-test" config_version="18"&gt;
  &lt;!-- The cluster has 3 nodes. Each has a unique nodid and one vote
       for quorum. --&gt;
  &lt;clusternodes&gt;
    &lt;clusternode name="node1.example.com" nodeid="1"/&gt;
    &lt;clusternode name="node2.example.com" nodeid="2"/&gt;
    &lt;clusternode name="node3.example.com" nodeid="3"/&gt;
  &lt;/clusternodes&gt;
  &lt;!-- Resouce Manager configuration. --&gt;
  &lt;rm&gt;
    &lt;!--
	There is a failoverdomain for each node containing just that node.
	This lets us stipulate that the qpidd service should always run on each node.
    --&gt;
    &lt;failoverdomains&gt;
      &lt;failoverdomain name="node1-domain" restricted="1"&gt;
	&lt;failoverdomainnode name="node1.example.com"/&gt;
      &lt;/failoverdomain&gt;
      &lt;failoverdomain name="node2-domain" restricted="1"&gt;
	&lt;failoverdomainnode name="node2.example.com"/&gt;
      &lt;/failoverdomain&gt;
      &lt;failoverdomain name="node3-domain" restricted="1"&gt;
	&lt;failoverdomainnode name="node3.example.com"/&gt;
      &lt;/failoverdomain&gt;
    &lt;/failoverdomains&gt;

    &lt;resources&gt;
      &lt;!-- This script starts a qpidd broker acting as a backup. --&gt;
      &lt;script file="/etc/init.d/qpidd" name="qpidd"/&gt;

      &lt;!-- This script promotes the qpidd broker on this node to primary. --&gt;
      &lt;script file="/etc/init.d/qpidd-primary" name="qpidd-primary"/&gt;

      &lt;!-- This is a virtual IP address for client traffic. --&gt;
      &lt;ip address="20.0.20.200" monitor_link="1"/&gt;
    &lt;/resources&gt;

    &lt;!-- There is a qpidd service on each node, it should be restarted if it fails. --&gt;
    &lt;service name="node1-qpidd-service" domain="node1-domain" recovery="restart"&gt;
      &lt;script ref="qpidd"/&gt;
    &lt;/service&gt;
    &lt;service name="node2-qpidd-service" domain="node2-domain" recovery="restart"&gt;
      &lt;script ref="qpidd"/&gt;
    &lt;/service&gt;
    &lt;service name="node3-qpidd-service" domain="node3-domain"  recovery="restart"&gt;
      &lt;script ref="qpidd"/&gt;
    &lt;/service&gt;

    &lt;!-- There should always be a single qpidd-primary service, it can run on any node. --&gt;
    &lt;service name="qpidd-primary-service" autostart="1" exclusive="0" recovery="relocate"&gt;
      &lt;script ref="qpidd-primary"/&gt;
      &lt;!-- The primary has the IP addresses for brokers and clients to connect. --&gt;
      &lt;ip ref="20.0.20.200"/&gt;
    &lt;/service&gt;
  &lt;/rm&gt;
&lt;/cluster&gt;
      
    </pre><p>
      There is a <code class="literal">failoverdomain</code> for each node containing just that
      one node.  This lets us stipulate that the qpidd service should always run on all
      nodes.
    </p><p>
      The <code class="literal">resources</code> section defines the <span class="command"><strong>qpidd</strong></span>
      script used to start the <span class="command"><strong>qpidd</strong></span> service. It also defines the
      <span class="command"><strong>qpid-primary</strong></span> script which does not
      actually start a new service, rather it promotes the existing
      <span class="command"><strong>qpidd</strong></span> broker to primary status.
    </p><p>
      The <code class="literal">resources</code> section also defines a pair of virtual IP
      addresses on different sub-nets. One will be used for broker-to-broker
      communication, the other for client-to-broker.
    </p><p>
      To take advantage of the virtual IP addresses, <code class="filename">qpidd.conf</code>
      should contain these  lines:
    </p><pre class="programlisting">
      ha-cluster=yes
      ha-public-url=20.0.10.200
      ha-brokers-url=20.0.20.1,20.0.20.2,20.0.20.3
    </pre><p>
      This configuration allows clients to connect to a single address:
      20.0.10.200.  The brokers connect to each other directly via the addresses
      listed in <span class="command"><strong>ha-brokers-url</strong></span>. Note the client and broker
      addresses are on separate sub-nets, this is recommended but not required.
    </p><p>
      The <code class="literal">service</code> section defines 3 <code class="literal">qpidd</code>
      services, one for each node. Each service is in a restricted fail-over
      domain containing just that node, and has the <code class="literal">restart</code>
      recovery policy. The effect of this is that rgmanager will run
      <span class="command"><strong>qpidd</strong></span> on each node, restarting if it fails.
    </p><p>
      There is a single <code class="literal">qpidd-primary-service</code> using the
      <span class="command"><strong>qpidd-primary</strong></span> script which is not restricted to a
      domain and has the <code class="literal">relocate</code> recovery policy. This means
      rgmanager will start <span class="command"><strong>qpidd-primary</strong></span> on one of the nodes
      when the cluster starts and will relocate it to another node if the
      original node fails. Running the <code class="literal">qpidd-primary</code> script
      does not start a new broker process, it promotes the existing broker to
      become the primary.
    </p></div><div class="section" title="1.12.6.&#160;Broker Administration Tools"><div class="titlepage"><div><div><h3 class="title"><a id="ha-broker-admin" />1.12.6.&#160;Broker Administration Tools</h3></div></div></div><p>
      Normally, clients are not allowed to connect to a backup broker. However
      management tools are allowed to connect to a backup brokers. If you use
      these tools you <span class="emphasis"><em>must not</em></span> add or remove messages from
      replicated queues, nor create or delete replicated queues or exchanges as
      this will disrupt the replication process and may cause message loss.
    </p><p>
      <span class="command"><strong>qpid-ha</strong></span> allows you to view and change HA configuration settings.
    </p><p>
      The tools <span class="command"><strong>qpid-config</strong></span>, <span class="command"><strong>qpid-route</strong></span> and
      <span class="command"><strong>qpid-stat</strong></span> will connect to a backup if you pass the flag <span class="command"><strong>ha-admin</strong></span> on the
      command line.
    </p></div><div class="section" title="1.12.7.&#160;Controlling replication of queues and exchanges"><div class="titlepage"><div><div><h3 class="title"><a id="ha-replicate-values" />1.12.7.&#160;Controlling replication of queues and exchanges</h3></div></div></div><p>
      By default, queues and exchanges are not replicated automatically. You can change
      the default behavior by setting the <code class="literal">ha-replicate</code> configuration
      option. It has one of the following values:
      </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>
	    <em class="firstterm">all</em>: Replicate everything automatically: queues,
	    exchanges, bindings and messages.
	  </p></li><li class="listitem"><p>
	    <em class="firstterm">configuration</em>: Replicate the existence of queues,
	    exchange and bindings but don't replicate messages.
	  </p></li><li class="listitem"><p>
	    <em class="firstterm">none</em>: Don't replicate anything, this is the default.
	  </p></li></ul></div><p>
    </p><p>
      You can over-ride the default for a particular queue or exchange by passing the
      argument <code class="literal">qpid.replicate</code> when creating the queue or exchange. It
      takes the same values as <code class="literal">ha-replicate</code>
    </p><p>
      Bindings are automatically replicated if the queue and exchange being bound both
      have replication <code class="literal">all</code> or <code class="literal">configuration</code>, they
      are not replicated otherwise.
    </p><p>
      You can create replicated queues and exchanges with the
      <span class="command"><strong>qpid-config</strong></span> management tool like this:
    </p><pre class="programlisting">
      qpid-config add queue myqueue --replicate all
    </pre><p>
      To create replicated queues and exchanges via the client API, add a
      <code class="literal">node</code> entry to the address like this:
    </p><pre class="programlisting">
      "myqueue;{create:always,node:{x-declare:{arguments:{'qpid.replicate':all}}}}"
    </pre><p>
      There are some built-in exchanges created automatically by the broker, these
      exchanges are never replicated. The built-in exchanges are the default (nameless)
      exchange, the AMQP standard exchanges (<code class="literal">amq.direct, amq.topic, amq.fanout</code> and
      <code class="literal">amq.match</code>) and the management exchanges (<code class="literal">qpid.management, qmf.default.direct</code> and
      <code class="literal">qmf.default.topic</code>)
    </p><p>
      Note that if you bind a replicated queue to one of these exchanges, the
      binding will <span class="emphasis"><em>not</em></span> be replicated, so the queue will not
      have the binding after a fail-over.
    </p></div><div class="section" title="1.12.8.&#160;Client Connection and Fail-over"><div class="titlepage"><div><div><h3 class="title"><a id="ha-failover" />1.12.8.&#160;Client Connection and Fail-over</h3></div></div></div><p>
      Clients can only connect to the primary broker. Backup brokers reject any
      connection attempt by a client. Clients rejected by a backup broker will
      automatically fail-over until they connect to the primary. if
      <code class="literal">ha-public-url</code> contains multiple addresses, the client
      will them all in rotation. If it is a virtual IP address the clients will
      retry on the same address until it is reconnected.
    </p><p>
      Clients are configured with the URL for the cluster (details below for
      each type of client). There are two possibilities
      </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>
	    The URL contains multiple addresses, one for each broker in the cluster.
	  </p></li><li class="listitem"><p>
	    The URL contains a single <em class="firstterm">virtual IP address</em>
	    that is assigned to the primary broker by the resource manager.
	    This is the recommended configuration.
	  </p></li></ul></div><p>
      In the first case, clients will repeatedly re-try each address in the URL
      until they successfully connect to the primary. In the second case the
      resource manager will assign the virtual IP address to the primary broker,
      so clients only need to re-try on a single address.
    </p><p>
      When the primary broker fails, clients re-try all known cluster addresses
      until they connect to the new primary.  The client re-sends any messages
      that were previously sent but not acknowledged by the broker at the time
      of the failure.  Similarly messages that have been sent by the broker, but
      not acknowledged by the client, are re-queued.
    </p><p>
      TCP can be slow to detect connection failures. A client can configure a
      connection to use a <em class="firstterm">heartbeat</em> to detect connection
      failure, and can specify a time interval for the heartbeat. If heartbeats
      are in use, failures will be detected no later than twice the heartbeat
      interval. The following sections explain how to enable heartbeat in each
      client.
    </p><p>
      Note: the following sections explain how to configure clients with
      multiple dresses, but if you are using a virtual IP address you only need
      to configure that one address for clients, you don't need to list all the
      addresses.
    </p><p>
      Suppose your cluster has 3 nodes: <code class="literal">node1</code>,
      <code class="literal">node2</code> and <code class="literal">node3</code> all using the
      default AMQP port, and you are not using a virtual IP address. To connect
      a client you need to specify the address(es) and set the
      <code class="literal">reconnect</code> property to <code class="literal">true</code>. The
      following sub-sections show how to connect each type of client.
    </p><div class="section" title="1.12.8.1.&#160;C++ clients"><div class="titlepage"><div><div><h4 class="title"><a id="ha-clients" />1.12.8.1.&#160;C++ clients</h4></div></div></div><p>
	With the C++ client, you specify multiple cluster addresses in a single URL
	<sup>[<a class="footnote" href="#ftn.idp32116272" id="idp32116272">3</a>]</sup>
	You also need to specify the connection option
	<code class="literal">reconnect</code> to be true.  For example:
      </p><pre class="programlisting">
	qpid::messaging::Connection c("node1,node2,node3","{reconnect:true}");
      </pre><p>
	Heartbeats are disabled by default. You can enable them by specifying a
	heartbeat interval (in seconds) for the connection via the
	<code class="literal">heartbeat</code> option. For example:
	</p><pre class="programlisting">
	  qpid::messaging::Connection c("node1,node2,node3","{reconnect:true,heartbeat:10}");
	</pre><p>
      </p></div><div class="section" title="1.12.8.2.&#160;Python clients"><div class="titlepage"><div><div><h4 class="title"><a id="ha-python-client" />1.12.8.2.&#160;Python clients</h4></div></div></div><p>
	With the python client, you specify <code class="literal">reconnect=True</code>
	and a list of <em class="replaceable"><code>host:port</code></em> addresses as
	<code class="literal">reconnect_urls</code> when calling
	<code class="literal">Connection.establish</code> or
	<code class="literal">Connection.open</code>
      </p><pre class="programlisting">
	connection = qpid.messaging.Connection.establish("node1", reconnect=True, reconnect_urls=["node1", "node2", "node3"])
      </pre><p>
	Heartbeats are disabled by default. You can
	enable them by specifying a heartbeat interval (in seconds) for the
	connection via the 'heartbeat' option. For example:
      </p><pre class="programlisting">
	connection = qpid.messaging.Connection.establish("node1", reconnect=True, reconnect_urls=["node1", "node2", "node3"], heartbeat=10)
      </pre></div><div class="section" title="1.12.8.3.&#160;Java JMS Clients"><div class="titlepage"><div><div><h4 class="title"><a id="ha-jms-client" />1.12.8.3.&#160;Java JMS Clients</h4></div></div></div><p>
	In Java JMS clients, client fail-over is handled automatically if it is
	enabled in the connection.  You can configure a connection to use
	fail-over using the <span class="command"><strong>failover</strong></span> property:
      </p><pre class="screen">
	connectionfactory.qpidConnectionfactory = amqp://guest:guest@clientid/test?brokerlist='tcp://localhost:5672'&amp;failover='failover_exchange'
      </pre><p>
	This property can take three values:
      </p><div class="variablelist" title="Fail-over Modes"><p class="title"><strong>Fail-over Modes</strong></p><dl><dt><span class="term">failover_exchange</span></dt><dd><p>
	      If the connection fails, fail over to any other broker in the cluster.
	    </p></dd><dt><span class="term">roundrobin</span></dt><dd><p>
	      If the connection fails, fail over to one of the brokers specified in the <span class="command"><strong>brokerlist</strong></span>.
	    </p></dd><dt><span class="term">singlebroker</span></dt><dd><p>
	      Fail-over is not supported; the connection is to a single broker only.
	    </p></dd></dl></div><p>
	In a Connection URL, heartbeat is set using the <span class="command"><strong>idle_timeout</strong></span> property, which is an integer corresponding to the heartbeat period in seconds. For instance, the following line from a JNDI properties file sets the heartbeat time out to 3 seconds:
      </p><pre class="screen">
	connectionfactory.qpidConnectionfactory = amqp://guest:guest@clientid/test?brokerlist='tcp://localhost:5672',idle_timeout=3
      </pre></div></div><div class="section" title="1.12.9.&#160;Security."><div class="titlepage"><div><div><h3 class="title"><a id="ha-security" />1.12.9.&#160;Security.</h3></div></div></div><p>
      You can secure your cluster using the authentication and authorization features
      described in <a class="xref" href="#chap-Messaging_User_Guide-Security" title="1.5.&#160;Security">Section&#160;1.5, &#8220;Security&#8221;</a>.
    </p><p>
      Backup brokers connect to the primary broker and subscribe for management
      events and queue contents. You can specify the identity used to connect
      to the primary with the following options:
    </p><div class="table"><a id="ha-broker-security-options" /><p class="title"><strong>Table&#160;1.21.&#160;Security options for High Availability Messaging Cluster</strong></p><div class="table-contents"><table border="1" summary="Security options for High Availability Messaging Cluster"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /></colgroup><thead><tr><th align="center" colspan="2">
	      Security options for High Availability Messaging Cluster
	    </th></tr></thead><tbody><tr><td align="left">
	      <p><code class="literal">ha-username <em class="replaceable"><code>USER</code></em></code></p>
	      <p><code class="literal">ha-password <em class="replaceable"><code>PASS</code></em></code></p>
	      <p><code class="literal">ha-mechanism <em class="replaceable"><code>MECH</code></em></code></p>
	    </td><td align="left">
	      Authentication settings used by HA brokers to connect to each other.
	      If you are using authorization
	      (<a class="xref" href="#sect-Messaging_User_Guide-Security-Authorization" title="1.5.2.&#160;Authorization">Section&#160;1.5.2, &#8220;Authorization&#8221;</a>)
	      then this user must have all permissions.
	    </td></tr></tbody></table></div></div><br class="table-break" /><p>
      This identity is also used to authorize actions taken on the backup broker to replicate
      from the primary, for example to create queues or exchanges.
    </p></div><div class="section" title="1.12.10.&#160;Integrating with other Cluster Resource Managers"><div class="titlepage"><div><div><h3 class="title"><a id="ha-other-rm" />1.12.10.&#160;Integrating with other Cluster Resource Managers</h3></div></div></div><p>
      To integrate with a different resource manager you must configure it to:
      </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Start a qpidd process on each node of the cluster.</p></li><li class="listitem"><p>Restart qpidd if it crashes.</p></li><li class="listitem"><p>Promote exactly one of the brokers to primary.</p></li><li class="listitem"><p>Detect a failure and promote a new primary.</p></li></ul></div><p>
    </p><p>
      The <span class="command"><strong>qpid-ha</strong></span> command allows you to check if a broker is primary,
      and to promote a backup to primary.
    </p><p>
      To test if a broker is the primary:
      </p><pre class="programlisting">
	qpid-ha -b <em class="replaceable"><code>broker-address</code></em> status --expect=primary
      </pre><p>
      This command will return 0 if the broker at <em class="replaceable"><code>broker-address</code></em>
      is the primary, non-0 otherwise.
    </p><p>
      To promote a broker to primary:
      </p><pre class="programlisting">
	qpid-ha -b <em class="replaceable"><code>broker-address</code></em> promote
      </pre><p>
    </p><p>
      <span class="command"><strong>qpid-ha --help</strong></span> gives information on other commands and options available.
      You can also use <span class="command"><strong>qpid-ha</strong></span> to manually examine and promote brokers. This
      can be useful for testing failover scenarios without having to set up a full resource manager,
      or to simulate a cluster on a single node. For deployment, a resource manager is required.
    </p></div><div class="section" title="1.12.11.&#160;Replicating specific queues"><div class="titlepage"><div><div><h3 class="title"><a id="ha-queue-replication" />1.12.11.&#160;Replicating specific queues</h3></div></div></div><p>
      In addition to the automatic replication performed in a cluster, you can
      set up replication for specific queues between arbitrary brokers, even if
      the brokers are not members of a cluster. The command:
    </p><pre class="programlisting">
      qpid-ha replicate <em class="replaceable"><code>QUEUE</code></em> <em class="replaceable"><code>REMOTE-BROKER</code></em>
    </pre><p>
    sets up replication of <em class="replaceable"><code>QUEUE</code></em> on <em class="replaceable"><code>REMOTE-BROKER</code></em> to <em class="replaceable"><code>QUEUE</code></em> on the current broker.
    </p><p>
      Set the configuration option
      <code class="literal">ha-queue-replication=yes</code> on both brokers to enable this
      feature on non-cluster brokers. It is automatically enabled for brokers
      that are part of a cluster.
    </p><p>
      Note that this feature does not provide automatic fail-over, for that you
      need to run a cluster.
    </p></div><div class="section" title="1.12.12.&#160;Using a message store in a cluster"><div class="titlepage"><div><div><h3 class="title"><a id="ha-store" />1.12.12.&#160;Using a message store in a cluster</h3></div></div></div><p>
      If you use a persistent store for your messages then each broker in a
      cluster will have its own store. If the entire cluster fails and is
      restarted, the *first* broker that becomes primary will recover from its
      store. All the other brokers will clear their stores and get an update
      from the primary to ensure consistency.
    </p></div><div class="footnotes"><br /><hr align="left" width="100" /><div class="footnote"><p><sup>[<a class="para" href="#idp27743488" id="ftn.idp27743488">1</a>] </sup>
	    You can control the maximum number of messages in the buffer by setting the
	    client's <code class="literal">capacity</code>. For details of how to set the capacity
	    in client code see "Using the Qpid Messaging API" in
	    <em class="citetitle">Programming in Apache Qpid</em>.
	  </p></div><div class="footnote"><p><sup>[<a class="para" href="#idp27699536" id="ftn.idp27699536">2</a>] </sup>
	  Clients must use "at-least-once" reliability to enable re-send of unacknowledged
	  messages. This is the default behavior, no options need be set to enable it. For
	  details of client addressing options see "Using the Qpid Messaging API"
	  in <em class="citetitle">Programming in Apache Qpid</em>.
	  </p></div><div class="footnote"><p><sup>[<a class="para" href="#idp32116272" id="ftn.idp32116272">3</a>] </sup>
	    The full grammar for the URL is:
	  </p><pre class="programlisting">
	    url = ["amqp:"][ user ["/" password] "@" ] addr ("," addr)*
	    addr = tcp_addr / rmda_addr / ssl_addr / ...
	    tcp_addr = ["tcp:"] host [":" port]
	    rdma_addr = "rdma:" host [":" port]
	    ssl_addr = "ssl:" host [":" port]'
	  </pre></div></div></div><div class="section" title="1.13.&#160;Queue Replication with the HA module"><div class="titlepage"><div><div><h2 class="title"><a id="idp30497168" />1.13.&#160;Queue Replication with the HA module</h2></div></div></div><p>
    As well as support for an active-passive cluster, the <code class="filename">ha</code> module
    also allows you to replicate individual queues. The <em class="firstterm">original</em>
    queue is used as normal.  The <em class="firstterm">replica</em> queue is updated
    automatically as messages are added to or removed from the original queue.
  </p><p>
    To create a replica you need the HA module to be loaded on both the orignal and replica
    brokers. Note that it is not safe to modify the replica queue other than via the
    automatic updates from the original. Adding or removing messages on the replica queue
    will make replication inconsistent and may cause message loss. The HA module does
    <span class="emphasis"><em>not</em></span> enforce restricted access to the replica queue (as it does in
    the case of a cluster) so it is up to the application to ensure the replca is not used
    until it has been disconnected from the original.
  </p><p>
    Suppose that <span class="command"><strong>myqueue</strong></span> is a queue on <span class="command"><strong>node1</strong></span> and
    we want to create a replica of <span class="command"><strong>myqueue</strong></span> on <span class="command"><strong>node2</strong></span>
    (where both brokers are using the default AMQP port.) This is accomplished by the command:
    </p><pre class="programlisting">
      qpid-config --broker=node2 add queue --start-replica node1 myqueue
    </pre><p>
  </p><p>
    If <span class="command"><strong>myqueue</strong></span> already exists on the replica broker you  can start replication from the original queue like this:
    </p><pre class="programlisting">
      qpid-ha replicate -b node2 node1 myqueue
    </pre><p>
  </p></div></div><div class="chapter" title="Chapter&#160;2.&#160; Managing the AMQP Messaging Broker"><div class="titlepage"><div><div><h2 class="title"><a id="chapter-Managing-CPP-Broker" />Chapter&#160;2.&#160;
      Managing the AMQP Messaging Broker
    </h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="section"><a href="#section-Managing-CPP-Broker">2.1.  Managing the C++ Broker </a></span></dt><dd><dl><dt><span class="section"><a href="#MgmtC-2B-2B-Usingqpidconfig">2.1.1. 
            Using qpid-config
          </a></span></dt><dt><span class="section"><a href="#MgmtC-2B-2B-Usingqpidroute">2.1.2. 
            Using qpid-route
          </a></span></dt><dt><span class="section"><a href="#MgmtC-2B-2B-Usingqpidtool">2.1.3. 
            Using qpid-tool
          </a></span></dt><dt><span class="section"><a href="#MgmtC-2B-2B-Usingqpidprintevents">2.1.4. 
            Using
            qpid-printevents
          </a></span></dt><dt><span class="section"><a href="#idp27654976">2.1.5. Using qpid-ha</a></span></dt></dl></dd><dt><span class="section"><a href="#idp29386832">2.2. 
      Qpid Management Framework
    </a></span></dt><dd><dl><dt><span class="section"><a href="#QpidManagementFramework-WhatIsQMF">2.2.1. 
            What Is QMF
          </a></span></dt><dt><span class="section"><a href="#QpidManagementFramework-GettingStartedwithQMF">2.2.2. 
            Getting
            Started with QMF
          </a></span></dt><dt><span class="section"><a href="#QpidManagementFramework-QMFConcepts">2.2.3. 
            QMF Concepts
          </a></span></dt><dt><span class="section"><a href="#QpidManagementFramework-TheQMFProtocol">2.2.4. 
            The QMF
            Protocol
          </a></span></dt><dt><span class="section"><a href="#QpidManagementFramework-HowtoWriteaQMFConsole">2.2.5. 
            How
            to Write a QMF Console
          </a></span></dt><dt><span class="section"><a href="#QpidManagementFramework-HowtoWriteaQMFAgent">2.2.6. 
            How to
            Write a QMF Agent
          </a></span></dt></dl></dd><dt><span class="section"><a href="#idp30998832">2.3. 
      QMF Python Console Tutorial
    </a></span></dt><dd><dl><dt><span class="section"><a href="#QMFPythonConsoleTutorial-PrerequisiteInstallQpidMessaging">2.3.1. 
            Prerequisite
            - Install Qpid Messaging
          </a></span></dt><dt><span class="section"><a href="#QMFPythonConsoleTutorial-SynchronousConsoleOperations">2.3.2. 
            Synchronous
            Console Operations
          </a></span></dt><dt><span class="section"><a href="#QMFPythonConsoleTutorial-AsynchronousConsoleOperations">2.3.3. 
            Asynchronous
            Console Operations
          </a></span></dt><dt><span class="section"><a href="#QMFPythonConsoleTutorial-DiscoveringwhatKindsofObjectsareAvailable">2.3.4. 
            Discovering what Kinds of Objects are Available
          </a></span></dt></dl></dd></dl></div><div class="section" title="2.1.&#160; Managing the C++ Broker"><div class="titlepage"><div><div><h2 class="title"><a id="section-Managing-CPP-Broker" />2.1.&#160; Managing the C++ Broker </h2></div></div></div><p>
            There are quite a few ways to interact with the C++ broker. The
            command line tools
            include:
          </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>qpid-route - used to configure federation (a set of federated
            brokers)
            </p></li><li class="listitem"><p>qpid-config - used to configure queues, exchanges, bindings
            and list them etc
            </p></li><li class="listitem"><p>qpid-tool - used to view management information/statistics
            and call any management actions on the broker
            </p></li><li class="listitem"><p>qpid-printevents - used to receive and print QMF events
            </p></li><li class="listitem"><p>qpid-ha - used to interact with the High Availability module
            </p></li></ul></div><div class="section" title="2.1.1.&#160; Using qpid-config"><div class="titlepage"><div><div><h3 class="title"><a id="MgmtC-2B-2B-Usingqpidconfig" />2.1.1.&#160;
            Using qpid-config
          </h3></div></div></div><p>
            This utility can be used to create queues exchanges and bindings,
            both durable and transient. Always check for latest options by
            running --help command.
          </p><pre class="programlisting">
$ qpid-config --help
Usage:  qpid-config [OPTIONS]
        qpid-config [OPTIONS] exchanges [filter-string]
        qpid-config [OPTIONS] queues    [filter-string]
        qpid-config [OPTIONS] add exchange &lt;type&gt; &lt;name&gt; [AddExchangeOptions]
        qpid-config [OPTIONS] del exchange &lt;name&gt;
        qpid-config [OPTIONS] add queue &lt;name&gt; [AddQueueOptions]
        qpid-config [OPTIONS] del queue &lt;name&gt;
        qpid-config [OPTIONS] bind   &lt;exchange-name&gt; &lt;queue-name&gt; [binding-key]
        qpid-config [OPTIONS] unbind &lt;exchange-name&gt; &lt;queue-name&gt; [binding-key]

Options:
    -b [ --bindings ]                         Show bindings in queue or exchange list
    -a [ --broker-addr ] Address (localhost)  Address of qpidd broker
         broker-addr is in the form:   [username/password@] hostname | ip-address [:&lt;port&gt;]
         ex:  localhost, 10.1.1.7:10000, broker-host:10000, guest/guest@localhost

Add Queue Options:
    --durable            Queue is durable
    --cluster-durable    Queue becomes durable if there is only one functioning cluster node
    --file-count N (8)   Number of files in queue's persistence journal
    --file-size  N (24)  File size in pages (64Kib/page)
    --max-queue-size N   Maximum in-memory queue size as bytes
    --max-queue-count N  Maximum in-memory queue size as a number of messages
    --limit-policy [none | reject | flow-to-disk | ring | ring-strict]
                         Action taken when queue limit is reached:
                             none (default) - Use broker's default policy
                             reject         - Reject enqueued messages
                             flow-to-disk   - Page messages to disk
                             ring           - Replace oldest unacquired message with new
                             ring-strict    - Replace oldest message, reject if oldest is acquired
    --order [fifo | lvq | lvq-no-browse]
                         Set queue ordering policy:
                             fifo (default) - First in, first out
                             lvq            - Last Value Queue ordering, allows queue browsing
                             lvq-no-browse  - Last Value Queue ordering, browsing clients may lose data
    --generate-queue-events N
                         If set to 1, every enqueue will generate an event that can be processed by
                         registered listeners (e.g. for replication). If set to 2, events will be
                         generated for enqueues and dequeues

Add Exchange Options:
    --durable    Exchange is durable
    --sequence   Exchange will insert a 'qpid.msg_sequence' field in the message header
                 with a value that increments for each message forwarded.
    --ive        Exchange will behave as an 'initial-value-exchange', keeping a reference
                 to the last message forwarded and enqueuing that message to newly bound
                 queues.
</pre><p>
            Get the summary page
          </p><pre class="programlisting">
$ qpid-config
Total Exchanges: 6
          topic: 2
        headers: 1
         fanout: 1
         direct: 2
   Total Queues: 7
        durable: 0
    non-durable: 7
</pre><p>
            List the queues
          </p><pre class="programlisting">
$ qpid-config queues
Queue Name                                  Attributes
=================================================================
pub_start
pub_done
sub_ready
sub_done
perftest0                                   --durable
reply-dhcp-100-18-254.bos.redhat.com.20713  auto-del excl
topic-dhcp-100-18-254.bos.redhat.com.20713  auto-del excl

</pre><p>
            List the exchanges with bindings
          </p><pre class="programlisting">
$ ./qpid-config -b exchanges
Exchange '' (direct)
    bind pub_start =&gt; pub_start
    bind pub_done =&gt; pub_done
    bind sub_ready =&gt; sub_ready
    bind sub_done =&gt; sub_done
    bind perftest0 =&gt; perftest0
    bind mgmt-3206ff16-fb29-4a30-82ea-e76f50dd7d15 =&gt; mgmt-3206ff16-fb29-4a30-82ea-e76f50dd7d15
    bind repl-3206ff16-fb29-4a30-82ea-e76f50dd7d15 =&gt; repl-3206ff16-fb29-4a30-82ea-e76f50dd7d15
Exchange 'amq.direct' (direct)
    bind repl-3206ff16-fb29-4a30-82ea-e76f50dd7d15 =&gt; repl-3206ff16-fb29-4a30-82ea-e76f50dd7d15
    bind repl-df06c7a6-4ce7-426a-9f66-da91a2a6a837 =&gt; repl-df06c7a6-4ce7-426a-9f66-da91a2a6a837
    bind repl-c55915c2-2fda-43ee-9410-b1c1cbb3e4ae =&gt; repl-c55915c2-2fda-43ee-9410-b1c1cbb3e4ae
Exchange 'amq.topic' (topic)
Exchange 'amq.fanout' (fanout)
Exchange 'amq.match' (headers)
Exchange 'qpid.management' (topic)
    bind mgmt.# =&gt; mgmt-3206ff16-fb29-4a30-82ea-e76f50dd7d15
</pre></div><div class="section" title="2.1.2.&#160; Using qpid-route"><div class="titlepage"><div><div><h3 class="title"><a id="MgmtC-2B-2B-Usingqpidroute" />2.1.2.&#160;
            Using qpid-route
          </h3></div></div></div><p>
            This utility is to create federated networks of brokers, This
            allows you for forward messages between brokers in a network.
            Messages can be routed statically (using "qpid-route route add")
            where the bindings that control message forwarding are supplied
            in the route. Message routing can also be dynamic (using
            "qpid-route dynamic add") where the messages are automatically
            forwarded to clients based on their bindings to the local broker.
          </p><pre class="programlisting">
$ qpid-route
Usage:  qpid-route [OPTIONS] dynamic add &lt;dest-broker&gt; &lt;src-broker&gt; &lt;exchange&gt; [tag] [exclude-list]
        qpid-route [OPTIONS] dynamic del &lt;dest-broker&gt; &lt;src-broker&gt; &lt;exchange&gt;

        qpid-route [OPTIONS] route add   &lt;dest-broker&gt; &lt;src-broker&gt; &lt;exchange&gt; &lt;routing-key&gt; [tag] [exclude-list]
        qpid-route [OPTIONS] route del   &lt;dest-broker&gt; &lt;src-broker&gt; &lt;exchange&gt; &lt;routing-key&gt;
        qpid-route [OPTIONS] queue add   &lt;dest-broker&gt; &lt;src-broker&gt; &lt;exchange&gt; &lt;queue&gt;
        qpid-route [OPTIONS] queue del   &lt;dest-broker&gt; &lt;src-broker&gt; &lt;exchange&gt; &lt;queue&gt;
        qpid-route [OPTIONS] route list  [&lt;dest-broker&gt;]
        qpid-route [OPTIONS] route flush [&lt;dest-broker&gt;]
        qpid-route [OPTIONS] route map   [&lt;broker&gt;]

        qpid-route [OPTIONS] link add  &lt;dest-broker&gt; &lt;src-broker&gt;
        qpid-route [OPTIONS] link del  &lt;dest-broker&gt; &lt;src-broker&gt;
        qpid-route [OPTIONS] link list [&lt;dest-broker&gt;]

Options:
    -v [ --verbose ]         Verbose output
    -q [ --quiet ]           Quiet output, don't print duplicate warnings
    -d [ --durable ]         Added configuration shall be durable
    -e [ --del-empty-link ]  Delete link after deleting last route on the link
    -s [ --src-local ]       Make connection to source broker (push route)
    -t &lt;transport&gt; [ --transport &lt;transport&gt;]
                             Specify transport to use for links, defaults to tcp

  dest-broker and src-broker are in the form:  [username/password@] hostname | ip-address [:&lt;port&gt;]
  ex:  localhost, 10.1.1.7:10000, broker-host:10000, guest/guest@localhost
</pre><p>
            A few examples:
          </p><pre class="programlisting">
qpid-route dynamic add host1 host2 fed.topic
qpid-route dynamic add host2 host1 fed.topic

qpid-route -v route add host1 host2 hub1.topic hub2.topic.stock.buy
qpid-route -v route add host1 host2 hub1.topic hub2.topic.stock.sell
qpid-route -v route add host1 host2 hub1.topic 'hub2.topic.stock.#'
qpid-route -v route add host1 host2 hub1.topic 'hub2.#'
qpid-route -v route add host1 host2 hub1.topic 'hub2.topic.#'
qpid-route -v route add host1 host2 hub1.topic 'hub2.global.#'
</pre><p>
            The link map feature can be used to display the entire federated
            network configuration by supplying a single broker as an entry
            point:
          </p><pre class="programlisting">
$ qpid-route route map localhost:10001

Finding Linked Brokers:
    localhost:10001... Ok
    localhost:10002... Ok
    localhost:10003... Ok
    localhost:10004... Ok
    localhost:10005... Ok
    localhost:10006... Ok
    localhost:10007... Ok
    localhost:10008... Ok

Dynamic Routes:

  Exchange fed.topic:
    localhost:10002 &lt;=&gt; localhost:10001
    localhost:10003 &lt;=&gt; localhost:10002
    localhost:10004 &lt;=&gt; localhost:10002
    localhost:10005 &lt;=&gt; localhost:10002
    localhost:10006 &lt;=&gt; localhost:10005
    localhost:10007 &lt;=&gt; localhost:10006
    localhost:10008 &lt;=&gt; localhost:10006

  Exchange fed.direct:
    localhost:10002  =&gt; localhost:10001
    localhost:10004  =&gt; localhost:10003
    localhost:10003  =&gt; localhost:10002
    localhost:10001  =&gt; localhost:10004

Static Routes:

  localhost:10003(ex=amq.direct) &lt;= localhost:10005(ex=amq.direct) key=rkey
  localhost:10003(ex=amq.direct) &lt;= localhost:10005(ex=amq.direct) key=rkey2
</pre></div><div class="section" title="2.1.3.&#160; Using qpid-tool"><div class="titlepage"><div><div><h3 class="title"><a id="MgmtC-2B-2B-Usingqpidtool" />2.1.3.&#160;
            Using qpid-tool
          </h3></div></div></div><p>
            This utility provided a telnet style interface to be able to
            view, list all stats and action
            all the methods. Simple capture below. Best to just play with it
            and mail the list if you have
            questions or want features added.
          </p><pre class="programlisting">
qpid:
qpid: help
Management Tool for QPID
Commands:
    list                            - Print summary of existing objects by class
    list &lt;className&gt;                - Print list of objects of the specified class
    list &lt;className&gt; all            - Print contents of all objects of specified class
    list &lt;className&gt; active         - Print contents of all non-deleted objects of specified class
    list &lt;list-of-IDs&gt;              - Print contents of one or more objects (infer className)
    list &lt;className&gt; &lt;list-of-IDs&gt;  - Print contents of one or more objects
        list is space-separated, ranges may be specified (i.e. 1004-1010)
    call &lt;ID&gt; &lt;methodName&gt; &lt;args&gt; - Invoke a method on an object
    schema                          - Print summary of object classes seen on the target
    schema &lt;className&gt;              - Print details of an object class
    set time-format short           - Select short timestamp format (default)
    set time-format long            - Select long timestamp format
    quit or ^D                      - Exit the program
qpid: list
Management Object Types:
    ObjectType     Active  Deleted
    ================================
    qpid.binding   21      0
    qpid.broker    1       0
    qpid.client    1       0
    qpid.exchange  6       0
    qpid.queue     13      0
    qpid.session   4       0
    qpid.system    1       0
    qpid.vhost     1       0
qpid: list qpid.system
Objects of type qpid.system
    ID    Created   Destroyed  Index
    ==================================
    1000  21:00:02  -          host
qpid: list 1000
Object of type qpid.system: (last sample time: 21:26:02)
    Type    Element   1000
    =======================================================
    config  sysId     host
    config  osName    Linux
    config  nodeName  localhost.localdomain
    config  release   2.6.24.4-64.fc8
    config  version   #1 SMP Sat Mar 29 09:15:49 EDT 2008
    config  machine   x86_64
qpid: schema queue
Schema for class 'qpid.queue':
    Element                Type          Unit         Access      Notes   Description
    ===================================================================================================================
    vhostRef               reference                  ReadCreate  index
    name                   short-string               ReadCreate  index
    durable                boolean                    ReadCreate
    autoDelete             boolean                    ReadCreate
    exclusive              boolean                    ReadCreate
    arguments              field-table                ReadOnly            Arguments supplied in queue.declare
    storeRef               reference                  ReadOnly            Reference to persistent queue (if durable)
    msgTotalEnqueues       uint64        message                          Total messages enqueued
    msgTotalDequeues       uint64        message                          Total messages dequeued
    msgTxnEnqueues         uint64        message                          Transactional messages enqueued
    msgTxnDequeues         uint64        message                          Transactional messages dequeued
    msgPersistEnqueues     uint64        message                          Persistent messages enqueued
    msgPersistDequeues     uint64        message                          Persistent messages dequeued
    msgDepth               uint32        message                          Current size of queue in messages
    msgDepthHigh           uint32        message                          Current size of queue in messages (High)
    msgDepthLow            uint32        message                          Current size of queue in messages (Low)
    byteTotalEnqueues      uint64        octet                            Total messages enqueued
    byteTotalDequeues      uint64        octet                            Total messages dequeued
    byteTxnEnqueues        uint64        octet                            Transactional messages enqueued
    byteTxnDequeues        uint64        octet                            Transactional messages dequeued
    bytePersistEnqueues    uint64        octet                            Persistent messages enqueued
    bytePersistDequeues    uint64        octet                            Persistent messages dequeued
    byteDepth              uint32        octet                            Current size of queue in bytes
    byteDepthHigh          uint32        octet                            Current size of queue in bytes (High)
    byteDepthLow           uint32        octet                            Current size of queue in bytes (Low)
    enqueueTxnStarts       uint64        transaction                      Total enqueue transactions started
    enqueueTxnCommits      uint64        transaction                      Total enqueue transactions committed
    enqueueTxnRejects      uint64        transaction                      Total enqueue transactions rejected
    enqueueTxnCount        uint32        transaction                      Current pending enqueue transactions
    enqueueTxnCountHigh    uint32        transaction                      Current pending enqueue transactions (High)
    enqueueTxnCountLow     uint32        transaction                      Current pending enqueue transactions (Low)
    dequeueTxnStarts       uint64        transaction                      Total dequeue transactions started
    dequeueTxnCommits      uint64        transaction                      Total dequeue transactions committed
    dequeueTxnRejects      uint64        transaction                      Total dequeue transactions rejected
    dequeueTxnCount        uint32        transaction                      Current pending dequeue transactions
    dequeueTxnCountHigh    uint32        transaction                      Current pending dequeue transactions (High)
    dequeueTxnCountLow     uint32        transaction                      Current pending dequeue transactions (Low)
    consumers              uint32        consumer                         Current consumers on queue
    consumersHigh          uint32        consumer                         Current consumers on queue (High)
    consumersLow           uint32        consumer                         Current consumers on queue (Low)
    bindings               uint32        binding                          Current bindings
    bindingsHigh           uint32        binding                          Current bindings (High)
    bindingsLow            uint32        binding                          Current bindings (Low)
    unackedMessages        uint32        message                          Messages consumed but not yet acked
    unackedMessagesHigh    uint32        message                          Messages consumed but not yet acked (High)
    unackedMessagesLow     uint32        message                          Messages consumed but not yet acked (Low)
    messageLatencySamples  delta-time    nanosecond                       Broker latency through this queue (Samples)
    messageLatencyMin      delta-time    nanosecond                       Broker latency through this queue (Min)
    messageLatencyMax      delta-time    nanosecond                       Broker latency through this queue (Max)
    messageLatencyAverage  delta-time    nanosecond                       Broker latency through this queue (Average)
Method 'purge' Discard all messages on queue
qpid: list queue
Objects of type qpid.queue
    ID    Created   Destroyed  Index
    ===========================================================================
    1012  21:08:13  -          1002.pub_start
    1014  21:08:13  -          1002.pub_done
    1016  21:08:13  -          1002.sub_ready
    1018  21:08:13  -          1002.sub_done
    1020  21:08:13  -          1002.perftest0
    1038  21:09:08  -          1002.mgmt-3206ff16-fb29-4a30-82ea-e76f50dd7d15
    1040  21:09:08  -          1002.repl-3206ff16-fb29-4a30-82ea-e76f50dd7d15
    1046  21:09:32  -          1002.mgmt-df06c7a6-4ce7-426a-9f66-da91a2a6a837
    1048  21:09:32  -          1002.repl-df06c7a6-4ce7-426a-9f66-da91a2a6a837
    1054  21:10:01  -          1002.mgmt-c55915c2-2fda-43ee-9410-b1c1cbb3e4ae
    1056  21:10:01  -          1002.repl-c55915c2-2fda-43ee-9410-b1c1cbb3e4ae
    1063  21:26:00  -          1002.mgmt-8d621997-6356-48c3-acab-76a37081d0f3
    1065  21:26:00  -          1002.repl-8d621997-6356-48c3-acab-76a37081d0f3
qpid: list 1020
Object of type qpid.queue: (last sample time: 21:26:02)
    Type    Element                1020
    ==========================================================================
    config  vhostRef               1002
    config  name                   perftest0
    config  durable                False
    config  autoDelete             False
    config  exclusive              False
    config  arguments              {'qpid.max_size': 0, 'qpid.max_count': 0}
    config  storeRef               NULL
    inst    msgTotalEnqueues       500000 messages
    inst    msgTotalDequeues       500000
    inst    msgTxnEnqueues         0
    inst    msgTxnDequeues         0
    inst    msgPersistEnqueues     0
    inst    msgPersistDequeues     0
    inst    msgDepth               0
    inst    msgDepthHigh           0
    inst    msgDepthLow            0
    inst    byteTotalEnqueues      512000000 octets
    inst    byteTotalDequeues      512000000
    inst    byteTxnEnqueues        0
    inst    byteTxnDequeues        0
    inst    bytePersistEnqueues    0
    inst    bytePersistDequeues    0
    inst    byteDepth              0
    inst    byteDepthHigh          0
    inst    byteDepthLow           0
    inst    enqueueTxnStarts       0 transactions
    inst    enqueueTxnCommits      0
    inst    enqueueTxnRejects      0
    inst    enqueueTxnCount        0
    inst    enqueueTxnCountHigh    0
    inst    enqueueTxnCountLow     0
    inst    dequeueTxnStarts       0
    inst    dequeueTxnCommits      0
    inst    dequeueTxnRejects      0
    inst    dequeueTxnCount        0
    inst    dequeueTxnCountHigh    0
    inst    dequeueTxnCountLow     0
    inst    consumers              0 consumers
    inst    consumersHigh          0
    inst    consumersLow           0
    inst    bindings               1 binding
    inst    bindingsHigh           1
    inst    bindingsLow            1
    inst    unackedMessages        0 messages
    inst    unackedMessagesHigh    0
    inst    unackedMessagesLow     0
    inst    messageLatencySamples  0
    inst    messageLatencyMin      0
    inst    messageLatencyMax      0
    inst    messageLatencyAverage  0
qpid:
</pre></div><div class="section" title="2.1.4.&#160; Using qpid-printevents"><div class="titlepage"><div><div><h3 class="title"><a id="MgmtC-2B-2B-Usingqpidprintevents" />2.1.4.&#160;
            Using
            qpid-printevents
          </h3></div></div></div><p>
            This utility connects to one or more brokers and collects events,
            printing out a line per event.
          </p><pre class="programlisting">
$ qpid-printevents --help
Usage: qpid-printevents [options] [broker-addr]...

Collect and print events from one or more Qpid message brokers.  If no broker-
addr is supplied, qpid-printevents will connect to 'localhost:5672'. broker-
addr is of the form:  [username/password@] hostname | ip-address [:&lt;port&gt;] ex:
localhost, 10.1.1.7:10000, broker-host:10000, guest/guest@localhost

Options:
  -h, --help  show this help message and exit
</pre><p>
            You get the idea... have fun!
          </p></div><div class="section" title="2.1.5.&#160;Using qpid-ha"><div class="titlepage"><div><div><h3 class="title"><a id="idp27654976" />2.1.5.&#160;Using qpid-ha</h3></div></div></div><p>This utility lets you monitor and control the activity of the clustering behavior provided by the HA module.
  </p><pre class="programlisting">
    
qpid-ha --help
usage: qpid-ha &lt;command&gt; [&lt;arguments&gt;]

Commands are:

  ready        Test if a backup broker is ready.
  query        Print HA configuration settings.
  set          Set HA configuration settings.
  promote      Promote broker from backup to primary.
  replicate    Set up replication from &lt;queue&gt; on &lt;remote-broker&gt; to &lt;queue&gt; on the current broker.

For help with a command type: qpid-ha &lt;command&gt; --help

  </pre></div></div><div class="section" title="2.2.&#160; Qpid Management Framework"><div class="titlepage"><div><div><h2 class="title"><a id="idp29386832" />2.2.&#160;
      Qpid Management Framework
    </h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>
                <a class="xref" href="#QpidManagementFramework-WhatIsQMF" title="2.2.1.&#160; What Is QMF">Section&#160;2.2.1, &#8220;
            What Is QMF
          &#8221;</a>
              </p></li><li class="listitem"><p>
                <a class="xref" href="#QpidManagementFramework-GettingStartedwithQMF" title="2.2.2.&#160; Getting Started with QMF">Section&#160;2.2.2, &#8220;
            Getting
            Started with QMF
          &#8221;</a>
              </p></li><li class="listitem"><p>
                <a class="xref" href="#QpidManagementFramework-QMFConcepts" title="2.2.3.&#160; QMF Concepts">Section&#160;2.2.3, &#8220;
            QMF Concepts
          &#8221;</a>
              </p></li><li class="listitem"><p>
                </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>
                    <a class="xref" href="#QpidManagementFramework-Console-2CAgent-2CandBroker" title="2.2.3.1.&#160; Console, Agent, and Broker">Section&#160;2.2.3.1, &#8220;
            Console,
            Agent, and Broker
          &#8221;</a>
                  </p></li><li class="listitem"><p>
                    <a class="xref" href="#QpidManagementFramework-Schema" title="2.2.3.2.&#160; Schema">Section&#160;2.2.3.2, &#8220;
            Schema
          &#8221;</a>
                  </p></li><li class="listitem"><p>
                    <a class="xref" href="#QpidManagementFramework-ClassKeysandClassVersioning" title="2.2.3.3.&#160; Class Keys and Class Versioning">Section&#160;2.2.3.3, &#8220;
            Class
            Keys and Class Versioning
          &#8221;</a>
                  </p></li></ul></div><p>
              </p></li><li class="listitem"><p>
                <a class="xref" href="#QpidManagementFramework-TheQMFProtocol" title="2.2.4.&#160; The QMF Protocol">Section&#160;2.2.4, &#8220;
            The QMF
            Protocol
          &#8221;</a>
              </p></li><li class="listitem"><p>
                <a class="xref" href="#QpidManagementFramework-HowtoWriteaQMFConsole" title="2.2.5.&#160; How to Write a QMF Console">Section&#160;2.2.5, &#8220;
            How
            to Write a QMF Console
          &#8221;</a>
              </p></li><li class="listitem"><p>
                <a class="xref" href="#QpidManagementFramework-HowtoWriteaQMFAgent" title="2.2.6.&#160; How to Write a QMF Agent">Section&#160;2.2.6, &#8220;
            How to
            Write a QMF Agent
          &#8221;</a>
              </p></li></ul></div><p>
              Please visit the <a class="xref" href="#">???</a> for information
              about the future of QMF.
            </p><div class="section" title="2.2.1.&#160; What Is QMF"><div class="titlepage"><div><div><h3 class="title"><a id="QpidManagementFramework-WhatIsQMF" />2.2.1.&#160;
            What Is QMF
          </h3></div></div></div><p>
            QMF (Qpid Management Framework) is a general-purpose management
            bus built on Qpid Messaging. It takes advantage of the
            scalability, security, and rich capabilities of Qpid to provide
            flexible and easy-to-use manageability to a large set of
            applications.
          </p></div><div class="section" title="2.2.2.&#160; Getting Started with QMF"><div class="titlepage"><div><div><h3 class="title"><a id="QpidManagementFramework-GettingStartedwithQMF" />2.2.2.&#160;
            Getting
            Started with QMF
          </h3></div></div></div><p>
            QMF is used through two primary APIs. The <span class="emphasis"><em>console</em></span> API is
            used for console applications that wish to access and manipulate
            manageable components through QMF. The <span class="emphasis"><em>agent</em></span> API is used
            for application that wish to be managed through QMF.
          </p><p>
            The fastest way to get started with QMF is to work through the
            "How To" tutorials for consoles and agents. For a deeper
            understanding of what is happening in the tutorials, it is
            recommended that you look at the <span class="emphasis"><em>Qmf Concepts</em></span> section.
          </p></div><div class="section" title="2.2.3.&#160; QMF Concepts"><div class="titlepage"><div><div><h3 class="title"><a id="QpidManagementFramework-QMFConcepts" />2.2.3.&#160;
            QMF Concepts
          </h3></div></div></div><p>
            This section introduces important concepts underlying QMF.
          </p><div class="section" title="2.2.3.1.&#160; Console, Agent, and Broker"><div class="titlepage"><div><div><h4 class="title"><a id="QpidManagementFramework-Console-2CAgent-2CandBroker" />2.2.3.1.&#160;
            Console,
            Agent, and Broker
          </h4></div></div></div><p>
            The major architectural components of QMF are the Console, the
            Agent, and the Broker. Console components are the "managing"
            components of QMF and agent components are the "managed" parts.
            The broker is a central (possibly distributed, clustered and
            fault-tolerant) component that manages name spaces and caches
            schema information.
          </p><p>
            A console application may be a command-line utility, a
            three-tiered web-based GUI, a collection and storage device, a
            specialized application that monitors and reacts to events and
            conditions, or anything else somebody wishes to develop that uses
            QMF management data.
          </p><p>
            An agent application is any application that has been enhanced to
            allow itself to be managed via QMF.
          </p><pre class="programlisting">
       +-------------+    +---------+    +---------------+    +-------------------+
       | CLI utility |    | Web app |    | Audit storage |    | Event correlation |
       +-------------+    +---------+    +---------------+    +-------------------+
              ^                ^                 ^                ^          |
              |                |                 |                |          |
              v                v                 v                v          v
    +---------------------------------------------------------------------------------+
    |                Qpid Messaging Bus (with QMF Broker capability)                  |
    +---------------------------------------------------------------------------------+
                    ^                     ^                     ^
                    |                     |                     |
                    v                     v                     v
           +----------------+    +----------------+    +----------------+
           | Manageable app |    | Manageable app |    | Manageable app |
           +----------------+    +----------------+    +----------------+
</pre><p>
            In the above diagram, the <span class="emphasis"><em>Manageable apps</em></span> are agents,
            the <span class="emphasis"><em>CLI utility</em></span>, <span class="emphasis"><em>Web app</em></span>, and <span class="emphasis"><em>Audit
            storage</em></span> are consoles, and <span class="emphasis"><em>Event correlation</em></span> is both
            a console and an agent because it can create events based on the
            aggregation of what it sees.
          </p></div><div class="section" title="2.2.3.2.&#160; Schema"><div class="titlepage"><div><div><h4 class="title"><a id="QpidManagementFramework-Schema" />2.2.3.2.&#160;
            Schema
          </h4></div></div></div><p>
            A <span class="emphasis"><em>schema</em></span> describes the structure of management data.
            Each <span class="emphasis"><em>agent</em></span> provides a schema that describes its
            management model including the object classes, methods, events,
            etc. that it provides. In the current QMF distribution, the
            agent's schema is codified in an XML document. In the near
            future, there will also be ways to programatically create QMF
            schemata.
          </p><div class="section" title="Package"><div class="titlepage"><div><div><h5 class="title"><a id="QpidManagementFramework-Package" />
            Package
          </h5></div></div></div><p>
            Each agent that exports a schema identifies itself using a
            <span class="emphasis"><em>package</em></span> name. The package provides a unique namespace
            for the classes in the agent's schema that prevent collisions
            with identically named classes in other agents' schemata.
          </p><p>
            Package names are in "reverse domain name" form with levels of
            hierarchy separated by periods. For example, the Qpid messaging
            broker uses package "org.apache.qpid.broker" and the Access
            Control List plugin for the broker uses package
            "org.apache.qpid.acl". In general, the package name should be the
            reverse of the internet domain name assigned to the organization
            that owns the agent software followed by identifiers to uniquely
            identify the agent.
          </p><p>
            The XML document for a package's schema uses an enclosing
            &lt;schema&gt; tag. For example:
          </p><pre class="programlisting">
&lt;schema package="org.apache.qpid.broker"&gt;

&lt;/schema&gt;
</pre></div><div class="section" title="Object Classes"><div class="titlepage"><div><div><h5 class="title"><a id="QpidManagementFramework-ObjectClasses" />
            Object
            Classes
          </h5></div></div></div><p>
            <span class="emphasis"><em>Object classes</em></span> define types for manageable objects. The
            agent may create and destroy objects which are instances of
            object classes in the schema. An object class is defined in the
            XML document using the &lt;class&gt; tag. An object class is
            composed of properties, statistics, and methods.
          </p><pre class="programlisting">
  &lt;class name="Exchange"&gt;
    &lt;property name="vhostRef"   type="objId" references="Vhost" access="RC" index="y" parentRef="y"/&gt;
    &lt;property name="name"       type="sstr"  access="RC" index="y"/&gt;
    &lt;property name="type"       type="sstr"  access="RO"/&gt;
    &lt;property name="durable"    type="bool"  access="RC"/&gt;
    &lt;property name="arguments"  type="map"   access="RO" desc="Arguments supplied in exchange.declare"/&gt;

    &lt;statistic name="producerCount" type="hilo32"  desc="Current producers on exchange"/&gt;
    &lt;statistic name="bindingCount"  type="hilo32"  desc="Current bindings"/&gt;
    &lt;statistic name="msgReceives"   type="count64" desc="Total messages received"/&gt;
    &lt;statistic name="msgDrops"      type="count64" desc="Total messages dropped (no matching key)"/&gt;
    &lt;statistic name="msgRoutes"     type="count64" desc="Total routed messages"/&gt;
    &lt;statistic name="byteReceives"  type="count64" desc="Total bytes received"/&gt;
    &lt;statistic name="byteDrops"     type="count64" desc="Total bytes dropped (no matching key)"/&gt;
    &lt;statistic name="byteRoutes"    type="count64" desc="Total routed bytes"/&gt;
  &lt;/class&gt;
</pre></div><div class="section" title="Properties and Statistics"><div class="titlepage"><div><div><h5 class="title"><a id="QpidManagementFramework-PropertiesandStatistics" />
            Properties
            and Statistics
          </h5></div></div></div><p>
            &lt;property&gt; and &lt;statistic&gt; tags must be placed within
            &lt;schema&gt; and &lt;/schema&gt; tags.
          </p><p>
            Properties, statistics, and methods are the building blocks of an
            object class. Properties and statistics are both object
            attributes, though they are treated differently. If an object
            attribute is defining, seldom or never changes, or is large in
            size, it should be defined as a <span class="emphasis"><em>property</em></span>. If an
            attribute is rapidly changing or is used to instrument the object
            (counters, etc.), it should be defined as a <span class="emphasis"><em>statistic</em></span>.
          </p><p>
            The XML syntax for &lt;property&gt; and &lt;statistic&gt; have
            the following XML-attributes:
          </p><div class="table"><a id="idp30994960" /><p class="title"><strong>Table&#160;2.1.&#160;XML Attributes for QMF Properties and Statistics</strong></p><div class="table-contents"><table border="1" summary="XML Attributes for QMF Properties and Statistics"><colgroup><col /><col /><col /><col /></colgroup><tbody><tr><td>
                  Attribute
                </td><td>
                  &lt;property&gt;
                </td><td>
                  &lt;statistic&gt;
                </td><td>
                  Meaning
                </td></tr><tr><td>
                  name
                </td><td>
                  Y
                </td><td>
                  Y
                </td><td>
                  The name of the attribute
                </td></tr><tr><td>
                  type
                </td><td>
                  Y
                </td><td>
                  Y
                </td><td>
                  The data type of the attribute
                </td></tr><tr><td>
                  unit
                </td><td>
                  Y
                </td><td>
                  Y
                </td><td>
                  Optional unit name - use the singular (i.e. MByte)
                </td></tr><tr><td>
                  desc
                </td><td>
                  Y
                </td><td>
                  Y
                </td><td>
                  Description to annotate the attribute
                </td></tr><tr><td>
                  references
                </td><td>
                  Y
                </td><td>
                  &#160;
                </td><td>
                  If the type is "objId", names the referenced class
                </td></tr><tr><td>
                  access
                </td><td>
                  Y
                </td><td>
                  &#160;
                </td><td>
                  Access rights (RC, RW, RO)
                </td></tr><tr><td>
                  index
                </td><td>
                  Y
                </td><td>
                  &#160;
                </td><td>
                  "y" if this property is used to uniquely identify the
                  object. There may be more than one index property in a
                  class
                </td></tr><tr><td>
                  parentRef
                </td><td>
                  Y
                </td><td>
                  &#160;
                </td><td>
                  "y" if this property references an object in which this
                  object is in a child-parent relationship.
                </td></tr><tr><td>
                  optional
                </td><td>
                  Y
                </td><td>
                  &#160;
                </td><td>
                  "y" if this property is optional (i.e. may be
                  NULL/not-present)
                </td></tr><tr><td>
                  min
                </td><td>
                  Y
                </td><td>
                  &#160;
                </td><td>
                  Minimum value of a numeric attribute
                </td></tr><tr><td>
                  max
                </td><td>
                  Y
                </td><td>
                  &#160;
                </td><td>
                  Maximum value of a numeric attribute
                </td></tr><tr><td>
                  maxLen
                </td><td>
                  Y
                </td><td>
                  &#160;
                </td><td>
                  Maximum length of a string attribute
                </td></tr></tbody></table></div></div><br class="table-break" /></div><div class="section" title="Methods"><div class="titlepage"><div><div><h5 class="title"><a id="QpidManagementFramework-Methods" />
            Methods
          </h5></div></div></div><p>
            &lt;method&gt; tags must be placed within &lt;schema&gt; and
            &lt;/schema&gt; tags.
          </p><p>
            A <span class="emphasis"><em>method</em></span> is an invokable function to be performed on
            instances of the object class (i.e. a Remote Procedure Call). A
            &lt;method&gt; tag has a name, an optional description, and
            encloses zero or more arguments. Method arguments are defined by
            the &lt;arg&gt; tag and have a name, a type, a direction, and an
            optional description. The argument direction can be "I", "O", or
            "IO" indicating input, output, and input/output respectively. An
            example:
          </p><pre class="programlisting">
   &lt;method name="echo" desc="Request a response to test the path to the management broker"&gt;
     &lt;arg name="sequence" dir="IO" type="uint32"/&gt;
     &lt;arg name="body"     dir="IO" type="lstr"/&gt;
   &lt;/method&gt;
</pre></div><div class="section" title="Event Classes"><div class="titlepage"><div><div><h5 class="title"><a id="QpidManagementFramework-EventClasses" />
            Event Classes
          </h5></div></div></div><p /></div><div class="section" title="Data Types"><div class="titlepage"><div><div><h5 class="title"><a id="QpidManagementFramework-DataTypes" />
            Data Types
          </h5></div></div></div><p>
            Object attributes, method arguments, and event arguments have
            data types. The data types are based on the rich data typing
            system provided by the AMQP messaging protocol. The following
            table describes the data types available for QMF:
          </p><div class="table"><a id="idp27876336" /><p class="title"><strong>Table&#160;2.2.&#160;QMF Datatypes</strong></p><div class="table-contents"><table border="1" summary="QMF Datatypes"><colgroup><col /><col /></colgroup><tbody><tr><td>
                  QMF Type
                </td><td>
                  Description
                </td></tr><tr><td>
                  REF
                </td><td>
                  QMF Object ID - Used to reference another QMF object.
                </td></tr><tr><td>
                  U8
                </td><td>
                  8-bit unsigned integer
                </td></tr><tr><td>
                  U16
                </td><td>
                  16-bit unsigned integer
                </td></tr><tr><td>
                  U32
                </td><td>
                  32-bit unsigned integer
                </td></tr><tr><td>
                  U64
                </td><td>
                  64-bit unsigned integer
                </td></tr><tr><td>
                  S8
                </td><td>
                  8-bit signed integer
                </td></tr><tr><td>
                  S16
                </td><td>
                  16-bit signed integer
                </td></tr><tr><td>
                  S32
                </td><td>
                  32-bit signed integer
                </td></tr><tr><td>
                  S64
                </td><td>
                  64-bit signed integer
                </td></tr><tr><td>
                  BOOL
                </td><td>
                  Boolean - True or False
                </td></tr><tr><td>
                  SSTR
                </td><td>
                  Short String - String of up to 255 bytes
                </td></tr><tr><td>
                  LSTR
                </td><td>
                  Long String - String of up to 65535 bytes
                </td></tr><tr><td>
                  ABSTIME
                </td><td>
                  Absolute time since the epoch in nanoseconds (64-bits)
                </td></tr><tr><td>
                  DELTATIME
                </td><td>
                  Delta time in nanoseconds (64-bits)
                </td></tr><tr><td>
                  FLOAT
                </td><td>
                  Single precision floating point number
                </td></tr><tr><td>
                  DOUBLE
                </td><td>
                  Double precision floating point number
                </td></tr><tr><td>
                  UUID
                </td><td>
                  UUID - 128 bits
                </td></tr><tr><td>
                  FTABLE
                </td><td>
                  Field-table - std::map in C++, dictionary in Python
                </td></tr></tbody></table></div></div><br class="table-break" /><p>
            In the XML schema definition, types go by different names and
            there are a number of special cases. This is because the XML
            schema is used in code-generation for the agent API. It provides
            options that control what kind of accessors are generated for
            attributes of different types. The following table enumerates the
            types available in the XML format, which QMF types they map to,
            and other special handling that occurs.
          </p><div class="table"><a id="idp32052304" /><p class="title"><strong>Table&#160;2.3.&#160;XML Schema Mapping for QMF Types</strong></p><div class="table-contents"><table border="1" summary="XML Schema Mapping for QMF Types"><colgroup><col /><col /><col /><col /></colgroup><tbody><tr><td>
                  XML Type
                </td><td>
                  QMF Type
                </td><td>
                  Accessor Style
                </td><td>
                  Special Characteristics
                </td></tr><tr><td>
                  objId
                </td><td>
                  REF
                </td><td>
                  Direct (get, set)
                </td><td>
                  &#160;
                </td></tr><tr><td>
                  uint8,16,32,64
                </td><td>
                  U8,16,32,64
                </td><td>
                  Direct (get, set)
                </td><td>
                  &#160;
                </td></tr><tr><td>
                  int8,16,32,64
                </td><td>
                  S8,16,32,64
                </td><td>
                  Direct (get, set)
                </td><td>
                  &#160;
                </td></tr><tr><td>
                  bool
                </td><td>
                  BOOL
                </td><td>
                  Direct (get, set)
                </td><td>
                  &#160;
                </td></tr><tr><td>
                  sstr
                </td><td>
                  SSTR
                </td><td>
                  Direct (get, set)
                </td><td>
                  &#160;
                </td></tr><tr><td>
                  lstr
                </td><td>
                  LSTR
                </td><td>
                  Direct (get, set)
                </td><td>
                  &#160;
                </td></tr><tr><td>
                  absTime
                </td><td>
                  ABSTIME
                </td><td>
                  Direct (get, set)
                </td><td>
                  &#160;
                </td></tr><tr><td>
                  deltaTime
                </td><td>
                  DELTATIME
                </td><td>
                  Direct (get, set)
                </td><td>
                  &#160;
                </td></tr><tr><td>
                  float
                </td><td>
                  FLOAT
                </td><td>
                  Direct (get, set)
                </td><td>
                  &#160;
                </td></tr><tr><td>
                  double
                </td><td>
                  DOUBLE
                </td><td>
                  Direct (get, set)
                </td><td>
                  &#160;
                </td></tr><tr><td>
                  uuid
                </td><td>
                  UUID
                </td><td>
                  Direct (get, set)
                </td><td>
                  &#160;
                </td></tr><tr><td>
                  map
                </td><td>
                  FTABLE
                </td><td>
                  Direct (get, set)
                </td><td>
                  &#160;
                </td></tr><tr><td>
                  hilo8,16,32,64
                </td><td>
                  U8,16,32,64
                </td><td>
                  Counter (inc, dec)
                </td><td>
                  Generates value, valueMin, valueMax
                </td></tr><tr><td>
                  count8,16,32,64
                </td><td>
                  U8,16,32,64
                </td><td>
                  Counter (inc, dec)
                </td><td>
                  &#160;
                </td></tr><tr><td>
                  mma32,64
                </td><td>
                  U32,64
                </td><td>
                  Direct
                </td><td>
                  Generates valueMin, valueMax, valueAverage, valueSamples
                </td></tr><tr><td>
                  mmaTime
                </td><td>
                  DELTATIME
                </td><td>
                  Direct
                </td><td>
                  Generates valueMin, valueMax, valueAverage, valueSamples
                </td></tr></tbody></table></div></div><br class="table-break" /><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;" title="Important"><h3 class="title">Important</h3><p>
                    When writing a schema using the XML format, types used in
                    &lt;property&gt; or &lt;arg&gt; must be types that have
                    <span class="emphasis"><em>Direct</em></span> accessor style. Any type may be used in
                    &lt;statistic&gt; tags.
                  </p></div></div></div><div class="section" title="2.2.3.3.&#160; Class Keys and Class Versioning"><div class="titlepage"><div><div><h4 class="title"><a id="QpidManagementFramework-ClassKeysandClassVersioning" />2.2.3.3.&#160;
            Class
            Keys and Class Versioning
          </h4></div></div></div><p /></div></div><div class="section" title="2.2.4.&#160; The QMF Protocol"><div class="titlepage"><div><div><h3 class="title"><a id="QpidManagementFramework-TheQMFProtocol" />2.2.4.&#160;
            The QMF
            Protocol
          </h3></div></div></div><p>
            The QMF protocol defines the message formats and communication
            patterns used by the different QMF components to communicate with
            one another.
          </p><p>
            A description of the current version of the QMF protocol can be
            found at <a class="xref" href="#">???</a>.
          </p><p>
            A proposal for an updated protocol based on map-messages is in
            progress and can be found at <a class="xref" href="#">???</a>.
          </p></div><div class="section" title="2.2.5.&#160; How to Write a QMF Console"><div class="titlepage"><div><div><h3 class="title"><a id="QpidManagementFramework-HowtoWriteaQMFConsole" />2.2.5.&#160;
            How
            to Write a QMF Console
          </h3></div></div></div><p>
            Please see the <a class="xref" href="#">???</a> for information about using the console API with
            Python.
          </p></div><div class="section" title="2.2.6.&#160; How to Write a QMF Agent"><div class="titlepage"><div><div><h3 class="title"><a id="QpidManagementFramework-HowtoWriteaQMFAgent" />2.2.6.&#160;
            How to
            Write a QMF Agent
          </h3></div></div></div><p /></div></div><div class="section" title="2.3.&#160; QMF Python Console Tutorial"><div class="titlepage"><div><div><h2 class="title"><a id="idp30998832" />2.3.&#160;
      QMF Python Console Tutorial
    </h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>
                <a class="xref" href="#QMFPythonConsoleTutorial-PrerequisiteInstallQpidMessaging" title="2.3.1.&#160; Prerequisite - Install Qpid Messaging">Section&#160;2.3.1, &#8220;
            Prerequisite
            - Install Qpid Messaging
          &#8221;</a>
              </p></li><li class="listitem"><p>
                <a class="xref" href="#QMFPythonConsoleTutorial-SynchronousConsoleOperations" title="2.3.2.&#160; Synchronous Console Operations">Section&#160;2.3.2, &#8220;
            Synchronous
            Console Operations
          &#8221;</a>
              </p></li><li class="listitem"><p>
                </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>
                    <a class="xref" href="#QMFPythonConsoleTutorial-CreatingaQMFConsoleSessionandAttachingtoaBroker" title="2.3.2.1.&#160; Creating a QMF Console Session and Attaching to a Broker">Section&#160;2.3.2.1, &#8220;
            Creating a QMF Console Session and Attaching to a Broker
          &#8221;</a>
                  </p></li><li class="listitem"><p>
                    <a class="xref" href="#QMFPythonConsoleTutorial-AccessingManagedObjects" title="2.3.2.2.&#160; Accessing Managed Objects">Section&#160;2.3.2.2, &#8220;
            Accessing
            Managed Objects
          &#8221;</a>
                  </p></li><li class="listitem"><p>
                    </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>
                        <a class="xref" href="#QMFPythonConsoleTutorial-ViewingPropertiesandStatisticsofanObject" title="Viewing Properties and Statistics of an Object">the section called &#8220;
            Viewing Properties and Statistics of an Object
          &#8221;</a>
                      </p></li><li class="listitem"><p>
                        <a class="xref" href="#QMFPythonConsoleTutorial-InvokingMethodsonanObject" title="Invoking Methods on an Object">the section called &#8220;
            Invoking
            Methods on an Object
          &#8221;</a>
                      </p></li></ul></div><p>
                  </p></li></ul></div><p>
              </p></li><li class="listitem"><p>
                <a class="xref" href="#QMFPythonConsoleTutorial-AsynchronousConsoleOperations" title="2.3.3.&#160; Asynchronous Console Operations">Section&#160;2.3.3, &#8220;
            Asynchronous
            Console Operations
          &#8221;</a>
              </p></li><li class="listitem"><p>
                </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>
                    <a class="xref" href="#QMFPythonConsoleTutorial-CreatingaConsoleClasstoReceiveAsynchronousData" title="2.3.3.1.&#160; Creating a Console Class to Receive Asynchronous Data">Section&#160;2.3.3.1, &#8220;
            Creating a Console Class to Receive Asynchronous Data
          &#8221;</a>
                  </p></li><li class="listitem"><p>
                    <a class="xref" href="#QMFPythonConsoleTutorial-ReceivingEvents" title="2.3.3.2.&#160; Receiving Events">Section&#160;2.3.3.2, &#8220;
            Receiving
            Events
          &#8221;</a>
                  </p></li><li class="listitem"><p>
                    <a class="xref" href="#QMFPythonConsoleTutorial-ReceivingObjects" title="2.3.3.3.&#160; Receiving Objects">Section&#160;2.3.3.3, &#8220;
            Receiving
            Objects
          &#8221;</a>
                  </p></li><li class="listitem"><p>
                    <a class="xref" href="#QMFPythonConsoleTutorial-AsynchronousMethodCallsandMethodTimeouts" title="2.3.3.4.&#160; Asynchronous Method Calls and Method Timeouts">Section&#160;2.3.3.4, &#8220;
            Asynchronous Method Calls and Method Timeouts
          &#8221;</a>
                  </p></li></ul></div><p>
              </p></li><li class="listitem"><p>
                <a class="xref" href="#QMFPythonConsoleTutorial-DiscoveringwhatKindsofObjectsareAvailable" title="2.3.4.&#160; Discovering what Kinds of Objects are Available">Section&#160;2.3.4, &#8220;
            Discovering what Kinds of Objects are Available
          &#8221;</a>
              </p></li></ul></div><div class="section" title="2.3.1.&#160; Prerequisite - Install Qpid Messaging"><div class="titlepage"><div><div><h3 class="title"><a id="QMFPythonConsoleTutorial-PrerequisiteInstallQpidMessaging" />2.3.1.&#160;
            Prerequisite
            - Install Qpid Messaging
          </h3></div></div></div><p>
            QMF uses AMQP Messaging (QPid) as its means of communication. To
            use QMF, Qpid messaging must be installed somewhere in the
            network. Qpid can be downloaded as source from Apache, is
            packaged with a number of Linux distributions, and can be
            purchased from commercial vendors that use Qpid. Please see
            <a class="ulink" href="http://qpid.apache.org" target="_top">http://qpid.apache.org</a>for
            information as to where to get Qpid Messaging.
          </p><p>
            Qpid Messaging includes a message broker (qpidd) which typically
            runs as a daemon on a system. It also includes client bindings in
            various programming languages. The Python-language client library
            includes the QMF console libraries needed for this tutorial.
          </p><p>
            Please note that Qpid Messaging has two broker implementations.
            One is implemented in C++ and the other in Java. At press time,
            QMF is supported only by the C++ broker.
          </p><p>
            If the goal is to get the tutorial examples up and running as
            quickly as possible, all of the Qpid components can be installed
            on a single system (even a laptop). For more realistic
            deployments, the broker can be deployed on a server and the
            client/QMF libraries installed on other systems.
          </p></div><div class="section" title="2.3.2.&#160; Synchronous Console Operations"><div class="titlepage"><div><div><h3 class="title"><a id="QMFPythonConsoleTutorial-SynchronousConsoleOperations" />2.3.2.&#160;
            Synchronous
            Console Operations
          </h3></div></div></div><p>
            The Python console API for QMF can be used in a synchronous
            style, an asynchronous style, or a combination of both.
            Synchronous operations are conceptually simple and are well
            suited for user-interactive tasks. All operations are performed
            in the context of a Python function call. If communication over
            the message bus is required to complete an operation, the
            function call blocks and waits for the expected result (or
            timeout failure) before returning control to the caller.
          </p><div class="section" title="2.3.2.1.&#160; Creating a QMF Console Session and Attaching to a Broker"><div class="titlepage"><div><div><h4 class="title"><a id="QMFPythonConsoleTutorial-CreatingaQMFConsoleSessionandAttachingtoaBroker" />2.3.2.1.&#160;
            Creating a QMF Console Session and Attaching to a Broker
          </h4></div></div></div><p>
            For the purposes of this tutorial, code examples will be shown as
            they are entered in an interactive python session.
          </p><pre class="programlisting">
$ python
Python 2.5.2 (r252:60911, Sep 30 2008, 15:41:38) 
[GCC 4.3.2 20080917 (Red Hat 4.3.2-4)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; 
</pre><p>
            We will begin by importing the required libraries. If the Python
            client is properly installed, these libraries will be found
            normally by the Python interpreter.
          </p><pre class="programlisting">
&gt;&gt;&gt; from qmf.console import Session
</pre><p>
            We must now create a <span class="emphasis"><em>Session</em></span> object to manage this QMF
            console session.
          </p><pre class="programlisting">
&gt;&gt;&gt; sess = Session()
</pre><p>
            If no arguments are supplied to the creation of <span class="emphasis"><em>Session</em></span>,
            it defaults to synchronous-only operation. It also defaults to
            user-management of connections. More on this in a moment.
          </p><p>
            We will now establish a connection to the messaging broker. If
            the broker daemon is running on the local host, simply use the
            following:
          </p><pre class="programlisting">
&gt;&gt;&gt; broker = sess.addBroker()
</pre><p>
            If the messaging broker is on a remote host, supply the URL to
            the broker in the <span class="emphasis"><em>addBroker</em></span> function call. Here's how to
            connect to a local broker using the URL.
          </p><pre class="programlisting">
&gt;&gt;&gt; broker = sess.addBroker("amqp://localhost")
</pre><p>
            The call to <span class="emphasis"><em>addBroker</em></span> is synchronous and will return
            only after the connection has been successfully established or
            has failed. If a failure occurs, <span class="emphasis"><em>addBroker</em></span> will raise an
            exception that can be handled by the console script.
          </p><pre class="programlisting">
&gt;&gt;&gt; try:
...   broker = sess.addBroker("amqp://localhost:1000")
... except:
...   print "Connection Failed"
... 
Connection Failed
&gt;&gt;&gt; 
</pre><p>
            This operation fails because there is no Qpid Messaging broker
            listening on port 1000 (the default port for qpidd is 5672).
          </p><p>
            If preferred, the QMF session can manage the connection for you.
            In this case, <span class="emphasis"><em>addBroker</em></span> returns immediately and the
            session attempts to establish the connection in the background.
            This will be covered in detail in the section on asynchronous
            operations.
          </p></div><div class="section" title="2.3.2.2.&#160; Accessing Managed Objects"><div class="titlepage"><div><div><h4 class="title"><a id="QMFPythonConsoleTutorial-AccessingManagedObjects" />2.3.2.2.&#160;
            Accessing
            Managed Objects
          </h4></div></div></div><p>
            The Python console API provides access to remotely managed
            objects via a <span class="emphasis"><em>proxy</em></span> model. The API gives the client an
            object that serves as a proxy representing the "real" object
            being managed on the agent application. Operations performed on
            the proxy result in the same operations on the real object.
          </p><p>
            The following examples assume prior knowledge of the kinds of
            objects that are actually available to be managed. There is a
            section later in this tutorial that describes how to discover
            what is manageable on the QMF bus.
          </p><p>
            Proxy objects are obtained by calling the
            <span class="emphasis"><em>Session.getObjects</em></span> function.
          </p><p>
            To illustrate, we'll get a list of objects representing queues in
            the message broker itself.
          </p><pre class="programlisting">
&gt;&gt;&gt; queues = sess.getObjects(_class="queue", _package="org.apache.qpid.broker")
</pre><p>
            <span class="emphasis"><em>queues</em></span> is an array of proxy objects representing real
            queues on the message broker. A proxy object can be printed to
            display a description of the object.
          </p><pre class="programlisting">
&gt;&gt;&gt; for q in queues:
...   print q
... 
org.apache.qpid.broker:queue[0-1537-1-0-58] 0-0-1-0-1152921504606846979:reply-localhost.localdomain.32004
org.apache.qpid.broker:queue[0-1537-1-0-61] 0-0-1-0-1152921504606846979:topic-localhost.localdomain.32004
&gt;&gt;&gt; 
</pre><div class="section" title="Viewing Properties and Statistics of an Object"><div class="titlepage"><div><div><h5 class="title"><a id="QMFPythonConsoleTutorial-ViewingPropertiesandStatisticsofanObject" />
            Viewing Properties and Statistics of an Object
          </h5></div></div></div><p>
            Let us now focus our attention on one of the queue objects.
          </p><pre class="programlisting">
&gt;&gt;&gt; queue = queues[0]
</pre><p>
            The attributes of an object are partitioned into
            <span class="emphasis"><em>properties</em></span> and <span class="emphasis"><em>statistics</em></span>. Though the
            distinction is somewhat arbitrary, <span class="emphasis"><em>properties</em></span> tend to
            be fairly static and may also be large and <span class="emphasis"><em>statistics</em></span>
            tend to change rapidly and are relatively small (counters, etc.).
          </p><p>
            There are two ways to view the properties of an object. An array
            of properties can be obtained using the <span class="emphasis"><em>getProperties</em></span>
            function:
          </p><pre class="programlisting">
&gt;&gt;&gt; props = queue.getProperties()
&gt;&gt;&gt; for prop in props:
...   print prop
... 
(vhostRef, 0-0-1-0-1152921504606846979)
(name, u'reply-localhost.localdomain.32004')
(durable, False)
(autoDelete, True)
(exclusive, True)
(arguments, {})
&gt;&gt;&gt; 
</pre><p>
            The <span class="emphasis"><em>getProperties</em></span> function returns an array of tuples.
            Each tuple consists of the property descriptor and the property
            value.
          </p><p>
            A more convenient way to access properties is by using the
            attribute of the proxy object directly:
          </p><pre class="programlisting">
&gt;&gt;&gt; queue.autoDelete
True
&gt;&gt;&gt; queue.name
u'reply-localhost.localdomain.32004'
&gt;&gt;&gt; 
</pre><p>
            Statistics are accessed in the same way:
          </p><pre class="programlisting">
&gt;&gt;&gt; stats = queue.getStatistics()
&gt;&gt;&gt; for stat in stats:
...   print stat
... 
(msgTotalEnqueues, 53)
(msgTotalDequeues, 53)
(msgTxnEnqueues, 0)
(msgTxnDequeues, 0)
(msgPersistEnqueues, 0)
(msgPersistDequeues, 0)
(msgDepth, 0)
(byteDepth, 0)
(byteTotalEnqueues, 19116)
(byteTotalDequeues, 19116)
(byteTxnEnqueues, 0)
(byteTxnDequeues, 0)
(bytePersistEnqueues, 0)
(bytePersistDequeues, 0)
(consumerCount, 1)
(consumerCountHigh, 1)
(consumerCountLow, 1)
(bindingCount, 2)
(bindingCountHigh, 2)
(bindingCountLow, 2)
(unackedMessages, 0)
(unackedMessagesHigh, 0)
(unackedMessagesLow, 0)
(messageLatencySamples, 0)
(messageLatencyMin, 0)
(messageLatencyMax, 0)
(messageLatencyAverage, 0)
&gt;&gt;&gt; 
</pre><p>
            or alternatively:
          </p><pre class="programlisting">
&gt;&gt;&gt; queue.byteTotalEnqueues
19116
&gt;&gt;&gt;
</pre><p>
            The proxy objects do not automatically track changes that occur
            on the real objects. For example, if the real queue enqueues more
            bytes, viewing the <span class="emphasis"><em>byteTotalEnqueues</em></span> statistic will show
            the same number as it did the first time. To get updated data on
            a proxy object, use the <span class="emphasis"><em>update</em></span> function call:
          </p><pre class="programlisting">
&gt;&gt;&gt; queue.update()
&gt;&gt;&gt; queue.byteTotalEnqueues
19783
&gt;&gt;&gt;
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;" title="Be Advised"><h3 class="title">Be Advised</h3><p>
                    The <span class="emphasis"><em>update</em></span> method was added after the M4 release
                    of Qpid/Qmf. It may not be available in your
                    distribution.
                  </p></div></div><div class="section" title="Invoking Methods on an Object"><div class="titlepage"><div><div><h5 class="title"><a id="QMFPythonConsoleTutorial-InvokingMethodsonanObject" />
            Invoking
            Methods on an Object
          </h5></div></div></div><p>
            Up to this point, we have used the QMF Console API to find
            managed objects and view their attributes, a read-only activity.
            The next topic to illustrate is how to invoke a method on a
            managed object. Methods allow consoles to control the managed
            agents by either triggering a one-time action or by changing the
            values of attributes in an object.
          </p><p>
            First, we'll cover some background information about methods. A
            <span class="emphasis"><em>QMF object class</em></span> (of which a <span class="emphasis"><em>QMF object</em></span> is an
            instance), may have zero or more methods. To obtain a list of
            methods available for an object, use the <span class="emphasis"><em>getMethods</em></span>
            function.
          </p><pre class="programlisting">
&gt;&gt;&gt; methodList = queue.getMethods()
</pre><p>
            <span class="emphasis"><em>getMethods</em></span> returns an array of method descriptors (of
            type qmf.console.SchemaMethod). To get a summary of a method, you
            can simply print it. The _<span class="emphasis"><em>repr</em></span>_ function returns a
            string that looks like a function prototype.
          </p><pre class="programlisting">
&gt;&gt;&gt; print methodList
[purge(request)]
&gt;&gt;&gt;
</pre><p>
            For the purposes of illustration, we'll use a more interesting
            method available on the <span class="emphasis"><em>broker</em></span> object which represents
            the connected Qpid message broker.
          </p><pre class="programlisting">
&gt;&gt;&gt; br = sess.getObjects(_class="broker", _package="org.apache.qpid.broker")[0]
&gt;&gt;&gt; mlist = br.getMethods()
&gt;&gt;&gt; for m in mlist:
...   print m
... 
echo(sequence, body)
connect(host, port, durable, authMechanism, username, password, transport)
queueMoveMessages(srcQueue, destQueue, qty)
&gt;&gt;&gt;
</pre><p>
            We have just learned that the <span class="emphasis"><em>broker</em></span> object has three
            methods: <span class="emphasis"><em>echo</em></span>, <span class="emphasis"><em>connect</em></span>, and
            <span class="emphasis"><em>queueMoveMessages</em></span>. We'll use the <span class="emphasis"><em>echo</em></span> method to
            "ping" the broker.
          </p><pre class="programlisting">
&gt;&gt;&gt; result = br.echo(1, "Message Body")
&gt;&gt;&gt; print result
OK (0) - {'body': u'Message Body', 'sequence': 1}
&gt;&gt;&gt; print result.status
0
&gt;&gt;&gt; print result.text
OK
&gt;&gt;&gt; print result.outArgs
{'body': u'Message Body', 'sequence': 1}
&gt;&gt;&gt;
</pre><p>
            In the above example, we have invoked the <span class="emphasis"><em>echo</em></span> method on
            the instance of the broker designated by the proxy "br" with a
            sequence argument of 1 and a body argument of "Message Body". The
            result indicates success and contains the output arguments (in
            this case copies of the input arguments).
          </p><p>
            To be more precise... Calling <span class="emphasis"><em>echo</em></span> on the proxy causes
            the input arguments to be marshalled and sent to the remote agent
            where the method is executed. Once the method execution
            completes, the output arguments are marshalled and sent back to
            the console to be stored in the method result.
          </p><p>
            You are probably wondering how you are supposed to know what
            types the arguments are and which arguments are input, which are
            output, or which are both. This will be addressed later in the
            "Discovering what Kinds of Objects are Available" section.
          </p></div></div></div><div class="section" title="2.3.3.&#160; Asynchronous Console Operations"><div class="titlepage"><div><div><h3 class="title"><a id="QMFPythonConsoleTutorial-AsynchronousConsoleOperations" />2.3.3.&#160;
            Asynchronous
            Console Operations
          </h3></div></div></div><p>
            QMF is built on top of a middleware messaging layer (Qpid
            Messaging). Because of this, QMF can use some communication
            patterns that are difficult to implement using network transports
            like UDP, TCP, or SSL. One of these patterns is called the
            <span class="emphasis"><em>Publication and Subscription</em></span> pattern (pub-sub for
            short). In the pub-sub pattern, data sources <span class="emphasis"><em>publish</em></span>
            information without a particular destination in mind. Data sinks
            (destinations) <span class="emphasis"><em>subscribe</em></span> using a set of criteria that
            describes what kind of data they are interested in receiving.
            Data published by a source may be received by zero, one, or many
            subscribers.
          </p><p>
            QMF uses the pub-sub pattern to distribute events, object
            creation and deletion, and changes to properties and statistics.
            A console application using the QMF Console API can receive these
            asynchronous and unsolicited events and updates. This is useful
            for applications that store and analyze events and/or statistics.
            It is also useful for applications that react to certain events
            or conditions.
          </p><p>
            Note that console applications may always use the synchronous
            mechanisms.
          </p><div class="section" title="2.3.3.1.&#160; Creating a Console Class to Receive Asynchronous Data"><div class="titlepage"><div><div><h4 class="title"><a id="QMFPythonConsoleTutorial-CreatingaConsoleClasstoReceiveAsynchronousData" />2.3.3.1.&#160;
            Creating a Console Class to Receive Asynchronous Data
          </h4></div></div></div><p>
            Asynchronous API operation occurs when the console application
            supplies a <span class="emphasis"><em>Console</em></span> object to the session manager. The
            <span class="emphasis"><em>Console</em></span> object (which overrides the
            <span class="emphasis"><em>qmf.console.Console</em></span> class) handles all asynchronously
            arriving data. The <span class="emphasis"><em>Console</em></span> class has the following
            methods. Any number of these methods may be overridden by the
            console application. Any method that is not overridden defaults
            to a null handler which takes no action when invoked.
          </p><div class="table"><a id="idp27374880" /><p class="title"><strong>Table&#160;2.4.&#160;QMF Python Console Class Methods</strong></p><div class="table-contents"><table border="1" summary="QMF Python Console Class Methods"><colgroup><col /><col /><col /></colgroup><tbody><tr><td>
                  Method
                </td><td>
                  Arguments
                </td><td>
                  Invoked when...
                </td></tr><tr><td>
                  brokerConnected
                </td><td>
                  broker
                </td><td>
                  a connection to a broker is established
                </td></tr><tr><td>
                  brokerDisconnected
                </td><td>
                  broker
                </td><td>
                  a connection to a broker is lost
                </td></tr><tr><td>
                  newPackage
                </td><td>
                  name
                </td><td>
                  a new package is seen on the QMF bus
                </td></tr><tr><td>
                  newClass
                </td><td>
                  kind, classKey
                </td><td>
                  a new class (event or object) is seen on the QMF bus
                </td></tr><tr><td>
                  newAgent
                </td><td>
                  agent
                </td><td>
                  a new agent appears on the QMF bus
                </td></tr><tr><td>
                  delAgent
                </td><td>
                  agent
                </td><td>
                  an agent disconnects from the QMF bus
                </td></tr><tr><td>
                  objectProps
                </td><td>
                  broker, object
                </td><td>
                  the properties of an object are published
                </td></tr><tr><td>
                  objectStats
                </td><td>
                  broker, object
                </td><td>
                  the statistics of an object are published
                </td></tr><tr><td>
                  event
                </td><td>
                  broker, event
                </td><td>
                  an event is published
                </td></tr><tr><td>
                  heartbeat
                </td><td>
                  agent, timestamp
                </td><td>
                  a heartbeat is published by an agent
                </td></tr><tr><td>
                  brokerInfo
                </td><td>
                  broker
                </td><td>
                  information about a connected broker is available to be
                  queried
                </td></tr><tr><td>
                  methodResponse
                </td><td>
                  broker, seq, response
                </td><td>
                  the result of an asynchronous method call is received
                </td></tr></tbody></table></div></div><br class="table-break" /><p>
            Supplied with the API is a class called <span class="emphasis"><em>DebugConsole</em></span>.
            This is a test <span class="emphasis"><em>Console</em></span> instance that overrides all of
            the methods such that arriving asynchronous data is printed to
            the screen. This can be used to see all of the arriving
            asynchronous data.
          </p></div><div class="section" title="2.3.3.2.&#160; Receiving Events"><div class="titlepage"><div><div><h4 class="title"><a id="QMFPythonConsoleTutorial-ReceivingEvents" />2.3.3.2.&#160;
            Receiving
            Events
          </h4></div></div></div><p>
            We'll start the example from the beginning to illustrate the
            reception and handling of events. In this example, we will create
            a <span class="emphasis"><em>Console</em></span> class that handles broker-connect,
            broker-disconnect, and event messages. We will also allow the
            session manager to manage the broker connection for us.
          </p><p>
            Begin by importing the necessary classes:
          </p><pre class="programlisting">
&gt;&gt;&gt; from qmf.console import Session, Console
</pre><p>
            Now, create a subclass of <span class="emphasis"><em>Console</em></span> that handles the three
            message types:
          </p><pre class="programlisting">
&gt;&gt;&gt; class EventConsole(Console):
...   def brokerConnected(self, broker):
...     print "brokerConnected:", broker
...   def brokerDisconnected(self, broker):
...     print "brokerDisconnected:", broker
...   def event(self, broker, event):
...     print "event:", event
...
&gt;&gt;&gt;
</pre><p>
            Make an instance of the new class:
          </p><pre class="programlisting">
&gt;&gt;&gt; myConsole = EventConsole()
</pre><p>
            Create a <span class="emphasis"><em>Session</em></span> class using the console instance. In
            addition, we shall request that the session manager do the
            connection management for us. Notice also that we are requesting
            that the session manager not receive objects or heartbeats. Since
            this example is concerned only with events, we can optimize the
            use of the messaging bus by telling the session manager not to
            subscribe for object updates or heartbeats.
          </p><pre class="programlisting">
&gt;&gt;&gt; sess = Session(myConsole, manageConnections=True, rcvObjects=False, rcvHeartbeats=False)
&gt;&gt;&gt; broker = sess.addBroker()
&gt;&gt;&gt;
</pre><p>
            Once the broker is added, we will begin to receive asynchronous
            events (assuming there is a functioning broker available to
            connect to).
          </p><pre class="programlisting">
brokerConnected: Broker connected at: localhost:5672
event: Thu Jan 29 19:53:19 2009 INFO  org.apache.qpid.broker:bind broker=localhost:5672 ...
</pre></div><div class="section" title="2.3.3.3.&#160; Receiving Objects"><div class="titlepage"><div><div><h4 class="title"><a id="QMFPythonConsoleTutorial-ReceivingObjects" />2.3.3.3.&#160;
            Receiving
            Objects
          </h4></div></div></div><p>
            To illustrate asynchronous handling of objects, a small console
            program is supplied. The entire program is shown below for
            convenience. We will then go through it part-by-part to explain
            its design.
          </p><p>
            This console program receives object updates and displays a set
            of statistics as they change. It focuses on broker queue objects.
          </p><pre class="programlisting">
# Import needed classes
from qmf.console import Session, Console
from time        import sleep

# Declare a dictionary to map object-ids to queue names
queueMap = {}

# Customize the Console class to receive object updates.
class MyConsole(Console):

  # Handle property updates
  def objectProps(self, broker, record):

    # Verify that we have received a queue object.  Exit otherwise.
    classKey = record.getClassKey()
    if classKey.getClassName() != "queue":
      return

    # If this object has not been seen before, create a new mapping from objectID to name
    oid = record.getObjectId()
    if oid not in queueMap:
      queueMap[oid] = record.name

  # Handle statistic updates
  def objectStats(self, broker, record):
    
    # Ignore updates for objects that are not in the map
    oid = record.getObjectId()
    if oid not in queueMap:
      return

    # Print the queue name and some statistics
    print "%s: enqueues=%d dequeues=%d" % (queueMap[oid], record.msgTotalEnqueues, record.msgTotalDequeues)

    # if the delete-time is non-zero, this object has been deleted.  Remove it from the map.
    if record.getTimestamps()[2] &gt; 0:
      queueMap.pop(oid)

# Create an instance of the QMF session manager.  Set userBindings to True to allow
# this program to choose which objects classes it is interested in.
sess = Session(MyConsole(), manageConnections=True, rcvEvents=False, userBindings=True)

# Register to receive updates for broker:queue objects.
sess.bindClass("org.apache.qpid.broker", "queue")
broker = sess.addBroker()

# Suspend processing while the asynchronous operations proceed.
try:
  while True:
    sleep(1)
except:
  pass

# Disconnect the broker before exiting.
sess.delBroker(broker)
</pre><p>
            Before going through the code in detail, it is important to
            understand the differences between synchronous object access and
            asynchronous object access. When objects are obtained
            synchronously (using the <span class="emphasis"><em>getObjects</em></span> function), the
            resulting proxy contains all of the object's attributes, both
            properties and statistics. When object data is published
            asynchronously, the properties and statistics are sent separately
            and only when the session first connects or when the content
            changes.
          </p><p>
            The script wishes to print the queue name with the updated
            statistics, but the queue name is only present with the
            properties. For this reason, the program needs to keep some state
            to correlate property updates with their corresponding statistic
            updates. This can be done using the <span class="emphasis"><em>ObjectId</em></span> that
            uniquely identifies the object.
          </p><pre class="programlisting">
    # If this object has not been seen before, create a new mapping from objectID to name
    oid = record.getObjectId()
    if oid not in queueMap:
      queueMap[oid] = record.name
</pre><p>
            The above code fragment gets the object ID from the proxy and
            checks to see if it is in the map (i.e. has been seen before). If
            it is not in the map, a new map entry is inserted mapping the
            object ID to the queue's name.
          </p><pre class="programlisting">
    # if the delete-time is non-zero, this object has been deleted.  Remove it from the map.
    if record.getTimestamps()[2] &gt; 0:
      queueMap.pop(oid)
</pre><p>
            This code fragment detects the deletion of a managed object.
            After reporting the statistics, it checks the timestamps of the
            proxy. <span class="emphasis"><em>getTimestamps</em></span> returns a list of timestamps in the
            order:
          </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>
              <span class="emphasis"><em>Current</em></span> - The timestamp of the sending of this update.
            </p></li><li class="listitem"><p>
              <span class="emphasis"><em>Create</em></span> - The time of the object's creation
            </p></li><li class="listitem"><p>
              <span class="emphasis"><em>Delete</em></span> - The time of the object's deletion (or zero if
              not deleted)
            </p></li></ul></div><p>
            This code structure is useful for getting information about
            very-short-lived objects. It is possible that an object will be
            created, used, and deleted within an update interval. In this
            case, the property update will arrive first, followed by the
            statistic update. Both will indicate that the object has been
            deleted but a full accounting of the object's existence and final
            state is reported.
          </p><pre class="programlisting">
# Create an instance of the QMF session manager.  Set userBindings to True to allow
# this program to choose which objects classes it is interested in.
sess = Session(MyConsole(), manageConnections=True, rcvEvents=False, userBindings=True)

# Register to receive updates for broker:queue objects.
sess.bindClass("org.apache.qpid.broker", "queue")
</pre><p>
            The above code is illustrative of the way a console application
            can tune its use of the QMF bus. Note that <span class="emphasis"><em>rcvEvents</em></span> is
            set to False. This prevents the reception of events. Note also
            the use of <span class="emphasis"><em>userBindings=True</em></span> and the call to
            <span class="emphasis"><em>sess.bindClass</em></span>. If <span class="emphasis"><em>userBindings</em></span> is set to False
            (its default), the session will receive object updates for all
            classes of object. In the case above, the application is only
            interested in broker:queue objects and reduces its bus bandwidth
            usage by requesting updates to only that class.
            <span class="emphasis"><em>bindClass</em></span> may be called as many times as desired to add
            classes to the list of subscribed classes.
          </p></div><div class="section" title="2.3.3.4.&#160; Asynchronous Method Calls and Method Timeouts"><div class="titlepage"><div><div><h4 class="title"><a id="QMFPythonConsoleTutorial-AsynchronousMethodCallsandMethodTimeouts" />2.3.3.4.&#160;
            Asynchronous Method Calls and Method Timeouts
          </h4></div></div></div><p>
            Method calls can also be invoked asynchronously. This is useful
            if a large number of calls needs to be made in a short time
            because the console application will not need to wait for the
            complete round-trip delay for each call.
          </p><p>
            Method calls are synchronous by default. They can be made
            asynchronous by adding the keyword-argument _<span class="emphasis"><em>async=True</em></span>
            to the method call.
          </p><p>
            In a synchronous method call, the return value is the method
            result. When a method is called asynchronously, the return value
            is a sequence number that can be used to correlate the eventual
            result to the request. This sequence number is passed as an
            argument to the <span class="emphasis"><em>methodResponse</em></span> function in the
            <span class="emphasis"><em>Console</em></span> interface.
          </p><p>
            It is important to realize that the <span class="emphasis"><em>methodResponse</em></span>
            function may be invoked before the asynchronous call returns.
            Make sure your code is written to handle this possibility.
          </p></div></div><div class="section" title="2.3.4.&#160; Discovering what Kinds of Objects are Available"><div class="titlepage"><div><div><h3 class="title"><a id="QMFPythonConsoleTutorial-DiscoveringwhatKindsofObjectsareAvailable" />2.3.4.&#160;
            Discovering what Kinds of Objects are Available
          </h3></div></div></div><p /></div></div></div></div></div>