<div class="docbook"><div class="book" title="Programming in Apache Qpid"><div class="titlepage"><div><div><h1 class="title"><a id="client-api-tutorial" />Programming in Apache Qpid</h1></div><div><h2 class="subtitle">Cross-Platform AMQP Messaging in Java JMS, .NET, C++, and Python</h2></div></div><hr /></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="chapter"><a href="#idp31340000">1. Introduction</a></span></dt><dt><span class="chapter"><a href="#idp29279616">2. Using the Qpid Messaging API</a></span></dt><dd><dl><dt><span class="section"><a href="#idp29021696">2.1. A Simple Messaging Program in C++</a></span></dt><dt><span class="section"><a href="#idp32355936">2.2. A Simple Messaging Program in Python</a></span></dt><dt><span class="section"><a href="#idp30310688">2.3. A Simple Messaging Program in .NET C#</a></span></dt><dt><span class="section"><a href="#section-addresses">2.4. Addresses</a></span></dt><dd><dl><dt><span class="section"><a href="#idp29969744">2.4.1. Address Strings</a></span></dt><dt><span class="section"><a href="#idp29611680">2.4.2. Subjects</a></span></dt><dt><span class="section"><a href="#idp26821104">2.4.3. Address String Options</a></span></dt><dt><span class="section"><a href="#section-address-string-bnf">2.4.4. Address String Grammar</a></span></dt></dl></dd><dt><span class="section"><a href="#replay">2.5. Sender Capacity and Replay</a></span></dt><dt><span class="section"><a href="#prefetch">2.6. Receiver Capacity (Prefetch)</a></span></dt><dt><span class="section"><a href="#acknowledgements">2.7. Acknowledging Received Messages</a></span></dt><dt><span class="section"><a href="#idp32566288">2.8. Receiving Messages from Multiple Sources</a></span></dt><dt><span class="section"><a href="#idp32574976">2.9. Transactions</a></span></dt><dt><span class="section"><a href="#connection-options">2.10. Connection Options</a></span></dt><dt><span class="section"><a href="#section-Maps">2.11. Maps and Lists in Message Content</a></span></dt><dd><dl><dt><span class="section"><a href="#section-Python-Maps">2.11.1. Qpid Maps and Lists in Python</a></span></dt><dt><span class="section"><a href="#section-cpp-Maps">2.11.2. Qpid Maps and Lists in C++</a></span></dt><dt><span class="section"><a href="#section-dotnet-Maps">2.11.3. Qpid Maps and Lists in .NET</a></span></dt></dl></dd><dt><span class="section"><a href="#idp32715392">2.12. The Request / Response Pattern</a></span></dt><dt><span class="section"><a href="#idp32725776">2.13. Performance Tips</a></span></dt><dt><span class="section"><a href="#idp32734464">2.14. Cluster Failover</a></span></dt><dt><span class="section"><a href="#idp32742752">2.15. Logging</a></span></dt><dd><dl><dt><span class="section"><a href="#idp32743888">2.15.1. Logging in C++</a></span></dt><dt><span class="section"><a href="#idp32748896">2.15.2. Logging in Python</a></span></dt></dl></dd><dt><span class="section"><a href="#section-amqp0-10-mapping">2.16. The AMQP 0-10 mapping</a></span></dt><dd><dl><dt><span class="section"><a href="#section-amqp0-10-message-props">2.16.1. 0-10 Message Property Keys</a></span></dt></dl></dd><dt><span class="section"><a href="#Message-Groups-Guide">2.17. Using Message Groups</a></span></dt><dd><dl><dt><span class="section"><a href="#messagegroups-setup">2.17.1. Creating Message Group Queues</a></span></dt><dt><span class="section"><a href="#messagegroups-sending">2.17.2. Sending Grouped Messages</a></span></dt><dt><span class="section"><a href="#messagegroups-receiving">2.17.3. Receiving Grouped Messages</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#QpidJMS">3. Using the Qpid JMS client</a></span></dt><dd><dl><dt><span class="section"><a href="#idp32819040">3.1. A Simple Messaging Program in Java JMS</a></span></dt><dt><span class="section"><a href="#QpidJNDI">3.2. Apache Qpid JNDI Properties for AMQP Messaging</a></span></dt><dd><dl><dt><span class="section"><a href="#idp32861648">3.2.1. JNDI Properties for Apache Qpid</a></span></dt><dt><span class="section"><a href="#section-jms-connection-url">3.2.2. Connection URLs</a></span></dt></dl></dd><dt><span class="section"><a href="#idp32950944">3.3. Java JMS Message Properties</a></span></dt><dt><span class="section"><a href="#section-JMS-MapMessage">3.4. JMS MapMessage Types</a></span></dt><dt><span class="section"><a href="#section-JMS-Logging">3.5. JMS Client Logging</a></span></dt><dt><span class="section"><a href="#idp32999424">3.6. Configuring the JMS Client</a></span></dt><dd><dl><dt><span class="section"><a href="#client-jvm-properties">3.6.1. Qpid JVM Arguments</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#QpidWCF">4. Using the Qpid WCF client</a></span></dt><dd><dl><dt><span class="section"><a href="#idp33147712">4.1. XML and Binary Bindings</a></span></dt><dt><span class="section"><a href="#idp33175216">4.2. Endpoints</a></span></dt><dt><span class="section"><a href="#idp33179504">4.3. Message Headers</a></span></dt><dt><span class="section"><a href="#idp33183024">4.4. Security</a></span></dt><dt><span class="section"><a href="#idp33187136">4.5. Transactions</a></span></dt></dl></dd><dt><span class="chapter"><a href="#idp33192768">5. The .NET Binding for the C++ Messaging Client</a></span></dt><dd><dl><dt><span class="section"><a href="#idp33194688">5.1. .NET Binding for the C++ Messaging Client Component Architecture</a></span></dt><dt><span class="section"><a href="#idp33208256">5.2. .NET Binding for the C++ Messaging Client Examples</a></span></dt><dt><span class="section"><a href="#idp33257520">5.3. .NET Binding Class Mapping to Underlying C++ Messaging API</a></span></dt><dd><dl><dt><span class="section"><a href="#idp33258768">5.3.1. .NET Binding for the C++ Messaging API Class: Address</a></span></dt><dt><span class="section"><a href="#idp33329600">5.3.2. .NET Binding for the C++ Messaging API Class: Connection</a></span></dt><dt><span class="section"><a href="#idp33404720">5.3.3. .NET Binding for the C++ Messaging API Class: Duration</a></span></dt><dt><span class="section"><a href="#idp33454048">5.3.4. .NET Binding for the C++ Messaging API Class: FailoverUpdates</a></span></dt><dt><span class="section"><a href="#idp33475168">5.3.5. .NET Binding for the C++ Messaging API Class: Message</a></span></dt><dt><span class="section"><a href="#idp33613408">5.3.6. .NET Binding for the C++ Messaging API Class: Receiver</a></span></dt><dt><span class="section"><a href="#idp33688832">5.3.7. .NET Binding for the C++ Messaging API Class: Sender</a></span></dt><dt><span class="section"><a href="#idp33745344">5.3.8. .NET Binding for the C++ Messaging API Class: Session</a></span></dt><dt><span class="section"><a href="#idp33857728">5.3.9. .NET Binding Class: SessionReceiver</a></span></dt></dl></dd></dl></dd></dl></div><div class="list-of-tables"><p><strong>List of Tables</strong></p><dl><dt>2.1. <a href="#idp32477632">Address String Options</a></dt><dt>2.2. <a href="#table-node-properties">Node Properties</a></dt><dt>2.3. <a href="#table-link-properties">Link Properties</a></dt><dt>2.4. <a href="#idp32593632">Connection Options</a></dt><dt>2.5. <a href="#tabl-Programming_in_Apache_Qpid-Qpid_Maps_in_Message_Content">Map and List Representation in Supported Languages</a></dt><dt>2.6. <a href="#table-Python-Maps">Python Datatypes in Maps</a></dt><dt>2.7. <a href="#table-cpp-Maps">C++ Datatypes in Maps</a></dt><dt>2.8. <a href="#table-dotnet-Maps">Datatype Mapping between C++ and .NET binding</a></dt><dt>2.9. <a href="#table-amqp0-10-message-properties">Mapping to AMQP 0-10 Message Properties</a></dt><dt>3.1. <a href="#idp32862768">JNDI Properties supported by Apache Qpid</a></dt><dt>3.2. <a href="#idp32878080">Connection URL Properties</a></dt><dt>3.3. <a href="#idp32913488">Broker List Options</a></dt><dt>3.4. <a href="#idp32954160">Java JMS Mapping to AMQP 0-10 Message Properties</a></dt><dt>3.5. <a href="#table-Java-Maps">Java Datatypes in Maps</a></dt><dt>3.6. <a href="#idp33010976">Config Options For Connection Behaviour</a></dt><dt>3.7. <a href="#idp33023024">Config Options For Session Behaviour</a></dt><dt>3.8. <a href="#idp33036288">Config Options For Consumer Behaviour</a></dt><dt>3.9. <a href="#idp33051760">Config Options For Producer Behaviour</a></dt><dt>3.10. <a href="#idp33058880">Config Options For Threading</a></dt><dt>3.11. <a href="#idp33067888">Config Options For I/O</a></dt><dt>3.12. <a href="#idp33091056">Config Options For Security</a></dt><dt>3.13. <a href="#idp33106000">Config Options For Security - Standard JVM properties needed when using GSSAPI as the SASL mechanism.</a></dt><dt>3.14. <a href="#idp33116320">Config Options For Security - Using SSL for securing connections or using EXTERNAL as the SASL mechanism.</a></dt><dt>3.15. <a href="#idp33129968">Config Options For Security - Standard JVM properties needed when Using SSL for securing connections or using EXTERNAL as the SASL mechanism.</a></dt><dt>4.1. <a href="#idp33157744">WCF Binding Parameters</a></dt><dt>5.1. <a href="#table-Dotnet-Binding-Component-Architecture">.NET Binding for the C++ Messaging Client Component Architecture</a></dt><dt>5.2. <a href="#table-Dotnet-Binding-Example-Client-Server">Example : Client - Server</a></dt><dt>5.3. <a href="#table-Dotnet-Binding-Example-MapSender-MapReceiver">Example : Map Sender &#8211; Map Receiver</a></dt><dt>5.4. <a href="#table-Dotnet-Binding-Example-Spout-Drain">Example : Spout - Drain</a></dt><dt>5.5. <a href="#table-Dotnet-Binding-Example-CallbackSender-CallbackReceiver">Example : Map Callback Sender &#8211; Map Callback Receiver</a></dt><dt>5.6. <a href="#table-Dotnet-Binding-Example-DeclareQueues">Example - Declare Queues</a></dt><dt>5.7. <a href="#table-Dotnet-Binding-Example-DirectSender-DirectReceiver">Example: Direct Sender - Direct Receiver</a></dt><dt>5.8. <a href="#table-Dotnet-Binding-Example-Helloworld">Example: Hello World</a></dt><dt>5.9. <a href="#table-Dotnet-Binding-Address">.NET Binding for the C++ Messaging API Class: Address</a></dt><dt>5.10. <a href="#table-Dotnet-Binding-Connection">.NET Binding for the C++ Messaging API Class: Connection</a></dt><dt>5.11. <a href="#table-Dotnet-Binding-Duration">.NET Binding for the C++ Messaging API Class: Duration</a></dt><dt>5.12. <a href="#table-Dotnet-Binding-FailoverUpdates">.NET Binding for the C++ Messaging API Class: FailoverUpdates</a></dt><dt>5.13. <a href="#table-Dotnet-Binding-Message">.NET Binding for the C++ Messaging API Class: Message</a></dt><dt>5.14. <a href="#table-Dotnet-Binding-Receiver">.NET Binding for the C++ Messaging API Class: Receiver</a></dt><dt>5.15. <a href="#table-Dotnet-Binding-Sender">.NET Binding for the C++ Messaging API Class: Sender</a></dt><dt>5.16. <a href="#table-Dotnet-Binding-Session">.NET Binding for the C++ Messaging API Class: Session</a></dt></dl></div><div class="list-of-examples"><p><strong>List of Examples</strong></p><dl><dt>2.1. <a href="#idp29334528">"Hello world!" in C++</a></dt><dt>2.2. <a href="#idp30875152">"Hello world!" in Python</a></dt><dt>2.3. <a href="#idp32092848">"Hello world!" in .NET C#</a></dt><dt>2.4. <a href="#idp29568656">Queues</a></dt><dt>2.5. <a href="#idp32216144">Topics</a></dt><dt>2.6. <a href="#idp29442000">Using subjects</a></dt><dt>2.7. <a href="#idp26804384">Subjects with multi-word keys</a></dt><dt>2.8. <a href="#idp32433824">Assertions on Nodes</a></dt><dt>2.9. <a href="#idp32443328">Creating a Queue Automatically</a></dt><dt>2.10. <a href="#idp32451488">Browsing a Queue</a></dt><dt>2.11. <a href="#idp32464992">Using the XML Exchange</a></dt><dt>2.12. <a href="#idp32569168">Receiving Messages from Multiple Sources</a></dt><dt>2.13. <a href="#idp32577216">Transactions</a></dt><dt>2.14. <a href="#idp32582480">Specifying Connection Options in C++, Python, and .NET</a></dt><dt>2.15. <a href="#idp32650064">Sending Qpid Maps and Lists in Python</a></dt><dt>2.16. <a href="#idp32668912">Sending Qpid Maps and Lists in C++</a></dt><dt>2.17. <a href="#idp32692448">Sending Qpid Maps and Lists in .NET C#</a></dt><dt>2.18. <a href="#idp32717520">Request / Response Applications in C++</a></dt><dt>2.19. <a href="#idp32737248">Tracking cluster membership</a></dt><dt>2.20. <a href="#idp32812080">Accessing the AMQP 0-10 Message Timestamp in Python</a></dt><dt>2.21. <a href="#idp32814464">Accessing the AMQP 0-10 Message Timestamp in C++</a></dt><dt>2.22. <a href="#idp32523728">Message Group Queue Creation - Python</a></dt><dt>2.23. <a href="#idp32525536">Message Group Queue Creation - C++</a></dt><dt>2.24. <a href="#idp32527376">Message Group Queue Creation - Java</a></dt><dt>2.25. <a href="#idp26745120">Sending Grouped Messages - Python</a></dt><dt>2.26. <a href="#idp26747056">Sending Grouped Messages - C++</a></dt><dt>2.27. <a href="#idp26749072">Sending Grouped Messages - Java</a></dt><dt>3.1. <a href="#idp32821216">"Hello world!" in Java</a></dt><dt>3.2. <a href="#idp32850192">JNDI Properties File for "Hello world!" example</a></dt><dt>3.3. <a href="#idp32859408">JNDI Properties File</a></dt><dt>3.4. <a href="#idp32908256">Broker Lists</a></dt><dt>3.5. <a href="#idp32973984">Sending a Java JMS MapMessage</a></dt><dt>3.6. <a href="#idp32997536">log4j Logging Properties</a></dt><dt>4.1. <a href="#idp33149760">Traditional service model "Hello world!" example</a></dt><dt>4.2. <a href="#idp33153088">Binary  "Hello world!" example using the channel model</a></dt></dl></div><div class="chapter" title="Chapter&#160;1.&#160;Introduction"><div class="titlepage"><div><div><h2 class="title"><a id="idp31340000" />Chapter&#160;1.&#160;Introduction</h2></div></div></div><p>Apache Qpid is a reliable, asynchronous messaging system that
    supports the AMQP messaging protocol in several common programming
    languages. Qpid is supported on most common platforms.
    </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>
	  On the Java platform, Qpid uses the
	  established <a class="ulink" href="http://java.sun.com/products/jms/" target="_top">Java JMS
	  API</a>.
	</p></li><li class="listitem"><p>
	  For Python, C++, and .NET, Qpid defines its own messaging API, the
	  <em class="firstterm">Qpid Messaging API</em>, which is
	  conceptually similar in each.
	</p><p>
	  On the .NET platform, Qpid also provides a WCF binding.
	</p></li><li class="listitem"><p>
	  Ruby will also use the Qpid Messaging API, which will soon
	  be implemented. (Ruby currently uses an API that is closely
	  tied to the AMQP version).
	</p></li></ul></div></div><div class="chapter" title="Chapter&#160;2.&#160;Using the Qpid Messaging API"><div class="titlepage"><div><div><h2 class="title"><a id="idp29279616" />Chapter&#160;2.&#160;Using the Qpid Messaging API</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="section"><a href="#idp29021696">2.1. A Simple Messaging Program in C++</a></span></dt><dt><span class="section"><a href="#idp32355936">2.2. A Simple Messaging Program in Python</a></span></dt><dt><span class="section"><a href="#idp30310688">2.3. A Simple Messaging Program in .NET C#</a></span></dt><dt><span class="section"><a href="#section-addresses">2.4. Addresses</a></span></dt><dd><dl><dt><span class="section"><a href="#idp29969744">2.4.1. Address Strings</a></span></dt><dt><span class="section"><a href="#idp29611680">2.4.2. Subjects</a></span></dt><dt><span class="section"><a href="#idp26821104">2.4.3. Address String Options</a></span></dt><dt><span class="section"><a href="#section-address-string-bnf">2.4.4. Address String Grammar</a></span></dt></dl></dd><dt><span class="section"><a href="#replay">2.5. Sender Capacity and Replay</a></span></dt><dt><span class="section"><a href="#prefetch">2.6. Receiver Capacity (Prefetch)</a></span></dt><dt><span class="section"><a href="#acknowledgements">2.7. Acknowledging Received Messages</a></span></dt><dt><span class="section"><a href="#idp32566288">2.8. Receiving Messages from Multiple Sources</a></span></dt><dt><span class="section"><a href="#idp32574976">2.9. Transactions</a></span></dt><dt><span class="section"><a href="#connection-options">2.10. Connection Options</a></span></dt><dt><span class="section"><a href="#section-Maps">2.11. Maps and Lists in Message Content</a></span></dt><dd><dl><dt><span class="section"><a href="#section-Python-Maps">2.11.1. Qpid Maps and Lists in Python</a></span></dt><dt><span class="section"><a href="#section-cpp-Maps">2.11.2. Qpid Maps and Lists in C++</a></span></dt><dt><span class="section"><a href="#section-dotnet-Maps">2.11.3. Qpid Maps and Lists in .NET</a></span></dt></dl></dd><dt><span class="section"><a href="#idp32715392">2.12. The Request / Response Pattern</a></span></dt><dt><span class="section"><a href="#idp32725776">2.13. Performance Tips</a></span></dt><dt><span class="section"><a href="#idp32734464">2.14. Cluster Failover</a></span></dt><dt><span class="section"><a href="#idp32742752">2.15. Logging</a></span></dt><dd><dl><dt><span class="section"><a href="#idp32743888">2.15.1. Logging in C++</a></span></dt><dt><span class="section"><a href="#idp32748896">2.15.2. Logging in Python</a></span></dt></dl></dd><dt><span class="section"><a href="#section-amqp0-10-mapping">2.16. The AMQP 0-10 mapping</a></span></dt><dd><dl><dt><span class="section"><a href="#section-amqp0-10-message-props">2.16.1. 0-10 Message Property Keys</a></span></dt></dl></dd><dt><span class="section"><a href="#Message-Groups-Guide">2.17. Using Message Groups</a></span></dt><dd><dl><dt><span class="section"><a href="#messagegroups-setup">2.17.1. Creating Message Group Queues</a></span></dt><dt><span class="section"><a href="#messagegroups-sending">2.17.2. Sending Grouped Messages</a></span></dt><dt><span class="section"><a href="#messagegroups-receiving">2.17.3. Receiving Grouped Messages</a></span></dt></dl></dd></dl></div><p>The Qpid Messaging API is quite simple, consisting of only a
    handful of core classes.
    </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>
          A <em class="firstterm">message</em> consists of a standard set
          of fields (e.g. <code class="literal">subject</code>,
          <code class="literal">reply-to</code>), an application-defined set of
          properties, and message content (the main body of the
          message).
        </p></li><li class="listitem"><p>
          A <em class="firstterm">connection</em> represents a network
          connection to a remote endpoint.
        </p></li><li class="listitem"><p>
          A <em class="firstterm">session</em> provides a sequentially
          ordered context for sending and receiving
          <span class="emphasis"><em>messages</em></span>. A session is obtained from a
          connection.
        </p></li><li class="listitem"><p>
	  A <em class="firstterm">sender</em> sends messages to a target
	  using the <code class="literal">sender.send</code> method. A sender is
	  obtained from a session for a given target address.
        </p></li><li class="listitem"><p>
	  A <em class="firstterm">receiver</em> receives messages from a
	  source using the <code class="literal">receiver.fetch</code> method.
	  A receiver is obtained from a session for a given source
	  address.
        </p></li></ul></div><p>
      The following sections show how to use these classes in a
      simple messaging program.
    </p><div class="section" title="2.1.&#160;A Simple Messaging Program in C++"><div class="titlepage"><div><div><h2 class="title"><a id="idp29021696" />2.1.&#160;A Simple Messaging Program in C++</h2></div></div></div><p>The following C++ program shows how to create a connection,
      create a session, send messages using a sender, and receive
      messages using a receiver.</p><div class="example"><a id="idp29334528" /><p class="title"><strong>Example&#160;2.1.&#160;"Hello world!" in C++</strong></p><div class="example-contents"><pre class="programlisting" lang="c++" xml:lang="c++">
	#include &lt;qpid/messaging/Connection.h&gt;
	#include &lt;qpid/messaging/Message.h&gt;
	#include &lt;qpid/messaging/Receiver.h&gt;
	#include &lt;qpid/messaging/Sender.h&gt;
	#include &lt;qpid/messaging/Session.h&gt;

	#include &lt;iostream&gt;

	using namespace qpid::messaging;

	int main(int argc, char** argv) {
	std::string broker = argc &gt; 1 ? argv[1] : "localhost:5672";
	std::string address = argc &gt; 2 ? argv[2] : "amq.topic";
	std::string connectionOptions = argc &gt; 3 ? argv[3] : "";

	Connection connection(broker, connectionOptions);
	try {
        connection.open();  <a class="co" href="#callout-cpp-open" id="hello-cpp-open">(1)</a>
        Session session = connection.createSession(); <a class="co" href="#callout-cpp-session" id="hello-cpp-session">(2)</a>

        Receiver receiver = session.createReceiver(address); <a class="co" href="#callout-cpp-receiver" id="hello-cpp-receiver">(3)</a>
        Sender sender = session.createSender(address); <a class="co" href="#callout-cpp-sender" id="hello-cpp-sender">(4)</a>

        sender.send(Message("Hello world!"));

        Message message = receiver.fetch(Duration::SECOND * 1); <a class="co" href="#callout-cpp-fetch" id="hello-cpp-fetch">(5)</a>
        std::cout &lt;&lt; message.getContent() &lt;&lt; std::endl;
        session.acknowledge(); <a class="co" href="#callout-cpp-acknowledge" id="hello-cpp-acknowledge">(6)</a>

        connection.close(); <a class="co" href="#callout-cpp-close" id="hello-cpp-close">(7)</a>
        return 0;
	} catch(const std::exception&amp; error) {
        std::cerr &lt;&lt; error.what() &lt;&lt; std::endl;
        connection.close();
        return 1;
	}
	}</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td align="left" valign="top" width="5%"><p><a id="callout-cpp-open" /><a href="#hello-cpp-open">(1)</a> </p></td><td align="left" valign="top"><p>Establishes the connection with the messaging broker.</p></td></tr><tr><td align="left" valign="top" width="5%"><p><a id="callout-cpp-session" /><a href="#hello-cpp-session">(2)</a> </p></td><td align="left" valign="top"><p>Creates a session object on which messages will be sent and received.</p></td></tr><tr><td align="left" valign="top" width="5%"><p><a id="callout-cpp-receiver" /><a href="#hello-cpp-receiver">(3)</a> </p></td><td align="left" valign="top"><p>Creates a receiver that receives messages from the given address.</p></td></tr><tr><td align="left" valign="top" width="5%"><p><a id="callout-cpp-sender" /><a href="#hello-cpp-sender">(4)</a> </p></td><td align="left" valign="top"><p>Creates a sender that sends to the given address.</p></td></tr><tr><td align="left" valign="top" width="5%"><p><a id="callout-cpp-fetch" /><a href="#hello-cpp-fetch">(5)</a> </p></td><td align="left" valign="top"><p>Receives the next message. The duration is optional, if omitted, will wait indefinitely for the next message.</p></td></tr><tr><td align="left" valign="top" width="5%"><p><a id="callout-cpp-acknowledge" /><a href="#hello-cpp-acknowledge">(6)</a> </p></td><td align="left" valign="top"><p>Acknowledges receipt of all fetched messages on the
	    session. This informs the broker that the messages were
	    transferred and processed by the client successfully.</p></td></tr><tr><td align="left" valign="top" width="5%"><p><a id="callout-cpp-close" /><a href="#hello-cpp-close">(7)</a> </p></td><td align="left" valign="top"><p>Closes the connection, all sessions managed by the connection, and all senders and receivers managed by each session.</p></td></tr></table></div></div></div><br class="example-break" /></div><div class="section" title="2.2.&#160;A Simple Messaging Program in Python"><div class="titlepage"><div><div><h2 class="title"><a id="idp32355936" />2.2.&#160;A Simple Messaging Program in Python</h2></div></div></div><p>The following Python program shows how to create a
      connection, create a session, send messages using a sender, and
      receive messages using a receiver.</p><div class="example"><a id="idp30875152" /><p class="title"><strong>Example&#160;2.2.&#160;"Hello world!" in Python</strong></p><div class="example-contents"><pre class="programlisting" lang="python" xml:lang="python">
	import sys
	from qpid.messaging import *

	broker =  "localhost:5672" if len(sys.argv)&lt;2 else sys.argv[1]
	address = "amq.topic" if len(sys.argv)&lt;3 else sys.argv[2]

	connection = Connection(broker)

	try:
	connection.open()  <a class="co" href="#callout-python-open" id="hello-python-open">(1)</a>
	session = connection.session()   <a class="co" href="#callout-python-session" id="hello-python-session">(2)</a>

	sender = session.sender(address)  <a class="co" href="#callout-python-sender" id="hello-python-sender">(3)</a>
	receiver = session.receiver(address)  <a class="co" href="#callout-python-receiver" id="hello-python-receiver">(4)</a>

	sender.send(Message("Hello world!"));

	message = receiver.fetch(timeout=1)  <a class="co" href="#callout-python-fetch" id="hello-python-fetch">(5)</a>
	print message.content
	session.acknowledge() <a class="co" href="#callout-python-acknowledge" id="hello-python-acknowledge">(6)</a>

	except MessagingError,m:
	print m
	finally:
	connection.close()  <a class="co" href="#callout-python-close" id="hello-python-close">(7)</a>
	</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td align="left" valign="top" width="5%"><p><a id="callout-python-open" /><a href="#hello-python-open">(1)</a> </p></td><td align="left" valign="top"><p>Establishes the connection with the messaging broker.</p></td></tr><tr><td align="left" valign="top" width="5%"><p><a id="callout-python-session" /><a href="#hello-python-session">(2)</a> </p></td><td align="left" valign="top"><p>Creates a session object on which messages will be sent and received.</p></td></tr><tr><td align="left" valign="top" width="5%"><p><a id="callout-python-receiver" /><a href="#hello-python-receiver">(4)</a> </p></td><td align="left" valign="top"><p>Creates a receiver that receives messages from the given address.</p></td></tr><tr><td align="left" valign="top" width="5%"><p><a id="callout-python-sender" /><a href="#hello-python-sender">(3)</a> </p></td><td align="left" valign="top"><p>Creates a sender that sends to the given address.</p></td></tr><tr><td align="left" valign="top" width="5%"><p><a id="callout-python-fetch" /><a href="#hello-python-fetch">(5)</a> </p></td><td align="left" valign="top"><p>Receives the next message. The duration is optional, if omitted, will wait indefinitely for the next message.</p></td></tr><tr><td align="left" valign="top" width="5%"><p><a id="callout-python-acknowledge" /><a href="#hello-python-acknowledge">(6)</a> </p></td><td align="left" valign="top"><p>Acknowledges receipt of all fetched messages on
	    the session. This informs the broker that the messages were
	    transfered and processed by the client successfully.</p></td></tr><tr><td align="left" valign="top" width="5%"><p><a id="callout-python-close" /><a href="#hello-python-close">(7)</a> </p></td><td align="left" valign="top"><p>Closes the connection, all sessions managed by the connection, and all senders and receivers managed by each session.</p></td></tr></table></div></div></div><br class="example-break" /></div><div class="section" title="2.3.&#160;A Simple Messaging Program in .NET C#"><div class="titlepage"><div><div><h2 class="title"><a id="idp30310688" />2.3.&#160;A Simple Messaging Program in .NET C#</h2></div></div></div><p>The following .NET C#
      <sup>[<a class="footnote" href="#ftn.idp31078656" id="idp31078656">1</a>]</sup>
      program shows how to create a connection,
      create a session, send messages using a sender, and receive
      messages using a receiver.
      </p><div class="example"><a id="idp32092848" /><p class="title"><strong>Example&#160;2.3.&#160;"Hello world!" in .NET C#</strong></p><div class="example-contents"><pre class="programlisting" lang="c++" xml:lang="c++">
	  using System;
	  using Org.Apache.Qpid.Messaging;  <a class="co" href="#callout-csharp-using" id="hello-csharp-using">(1)</a>

	  namespace Org.Apache.Qpid.Messaging {
	  class Program {
	  static void Main(string[] args) {
	  String broker = args.Length &gt; 0 ? args[0] : "localhost:5672";
	  String address = args.Length &gt; 1 ? args[1] : "amq.topic";

	  Connection connection = null;
	  try {
	  connection = new Connection(broker);
	  connection.Open();   <a class="co" href="#callout-csharp-open" id="hello-csharp-open">(2)</a>
	  Session session = connection.CreateSession();   <a class="co" href="#callout-csharp-session" id="hello-csharp-session">(3)</a>

	  Receiver receiver = session.CreateReceiver(address);   <a class="co" href="#callout-csharp-receiver" id="hello-csharp-receiver">(4)</a>
	  Sender sender = session.CreateSender(address);   <a class="co" href="#callout-csharp-sender" id="hello-csharp-sender">(5)</a>

	  sender.Send(new Message("Hello world!"));

	  Message message = new Message();
	  message = receiver.Fetch(DurationConstants.SECOND * 1);   <a class="co" href="#callout-csharp-fetch" id="hello-csharp-fetch">(6)</a>
	  Console.WriteLine("{0}", message.GetContent());
	  session.Acknowledge();   <a class="co" href="#callout-csharp-acknowledge" id="hello-csharp-acknowledge">(7)</a>

	  connection.Close();   <a class="co" href="#callout-csharp-close" id="hello-csharp-close">(8)</a>
	  } catch (Exception e) {
	  Console.WriteLine("Exception {0}.", e);
	  if (null != connection)
	  connection.Close();
	  }
	  }
	  }
	  }

	</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td align="left" valign="top" width="5%"><p><a id="callout-csharp-using" /><a href="#hello-csharp-using">(1)</a> </p></td><td align="left" valign="top"><p> Permits use of Org.Apache.Qpid.Messaging types and methods without explicit namespace qualification. Any .NET project must have a project reference to the assembly file <code class="literal">Org.Apache.Qpid.Messaging.dll</code> in order to obtain the definitions of the .NET Binding for Qpid Messaging namespace.</p></td></tr><tr><td align="left" valign="top" width="5%"><p><a id="callout-csharp-open" /><a href="#hello-csharp-open">(2)</a> </p></td><td align="left" valign="top"><p>Establishes the connection with the messaging broker.</p></td></tr><tr><td align="left" valign="top" width="5%"><p><a id="callout-csharp-session" /><a href="#hello-csharp-session">(3)</a> </p></td><td align="left" valign="top"><p>Creates a session object on which messages will be sent and received.</p></td></tr><tr><td align="left" valign="top" width="5%"><p><a id="callout-csharp-receiver" /><a href="#hello-csharp-receiver">(4)</a> </p></td><td align="left" valign="top"><p>Creates a receiver that receives messages from the given address.</p></td></tr><tr><td align="left" valign="top" width="5%"><p><a id="callout-csharp-sender" /><a href="#hello-csharp-sender">(5)</a> </p></td><td align="left" valign="top"><p>Creates a sender that sends to the given address.</p></td></tr><tr><td align="left" valign="top" width="5%"><p><a id="callout-csharp-fetch" /><a href="#hello-csharp-fetch">(6)</a> </p></td><td align="left" valign="top"><p>Receives the next message. The duration is optional, if omitted, will wait indefinitely for the next message.</p></td></tr><tr><td align="left" valign="top" width="5%"><p><a id="callout-csharp-acknowledge" /><a href="#hello-csharp-acknowledge">(7)</a> </p></td><td align="left" valign="top"><p>Acknowledges receipt of all fetched messages on the
	    session. This informs the broker that the messages were
	    transfered and processed by the client successfully.</p></td></tr><tr><td align="left" valign="top" width="5%"><p><a id="callout-csharp-close" /><a href="#hello-csharp-close">(8)</a> </p></td><td align="left" valign="top"><p>Closes the connection, all sessions managed by the connection, and all senders and receivers managed by each session.</p></td></tr></table></div></div></div><br class="example-break" /><div class="footnotes"><br /><hr align="left" width="100" /><div class="footnote"><p><sup>[<a class="para" href="#idp31078656" id="ftn.idp31078656">1</a>] </sup>
	  The .NET binding for the Qpid C++ Messaging API
	  applies to all .NET Framework managed code languages. C# was chosen
	  for illustration purposes only.
	</p></div></div></div><div class="section" title="2.4.&#160;Addresses"><div class="titlepage"><div><div><h2 class="title"><a id="section-addresses" />2.4.&#160;Addresses</h2></div></div></div><p>An <em class="firstterm">address</em> is the name of a message
      target or message source.

      <sup>[<a class="footnote" href="#ftn.idp30929088" id="idp30929088">2</a>]</sup>

      The methods that create senders and receivers require an
      address. The details of sending to a particular target or
      receiving from a particular source are then handled by the
      sender or receiver. A different target or source can be used
      simply by using a different address.
      </p><p>An address resolves to a <em class="firstterm">node</em>. The
      Qpid Messaging API recognises two kinds of nodes,
      <em class="firstterm">queues</em> and <em class="firstterm">topics</em>

      <sup>[<a class="footnote" href="#ftn.idp31866448" id="idp31866448">3</a>]</sup>.

      A queue stores each message until it has been received and
      acknowledged, and only one receiver can receive a given message

      <sup>[<a class="footnote" href="#ftn.idp29704896" id="idp29704896">4</a>]</sup>.

      A topic immediately delivers a message to all eligible
      receivers; if there are no eligible receivers, it discards the
      message.  In the AMQP 0-10 implementation of the API,

      <sup>[<a class="footnote" href="#ftn.idp31492912" id="idp31492912">5</a>]</sup>

      queues map to AMQP queues, and topics map to AMQP exchanges.

      <sup>[<a class="footnote" href="#ftn.idp30057568" id="idp30057568">6</a>]</sup>
      </p><p>In the rest of this tutorial, we present many examples
      using two programs that take an address as a command line
      parameter.  <span class="command"><strong>spout</strong></span> sends messages to the
      target address, <span class="command"><strong>drain</strong></span> receives messages from
      the source address.  The source code is available in C++, Python, and
      .NET C# and can be found in the examples directory for each
      language. These programs can use any address string as a source
      or a destination, and have many command line options to
      configure behavior&#8212;use the <span class="command"><strong>-h</strong></span> option
      for documentation on these options.

      <sup>[<a class="footnote" href="#ftn.idp30167472" id="idp30167472">7</a>]</sup>


      The examples in this tutorial also use the
      <span class="command"><strong>qpid-config</strong></span> utility to configure AMQP 0-10
      queues and exchanges on a Qpid broker.
      </p><div class="example"><a id="idp29568656" /><p class="title"><strong>Example&#160;2.4.&#160;Queues</strong></p><div class="example-contents"><p>Create a queue with <span class="command"><strong>qpid-config</strong></span>, send a message using
	<span class="command"><strong>spout</strong></span>, and read it using <span class="command"><strong>drain</strong></span>:</p><pre class="screen">
	  $ qpid-config add queue hello-world
	  $ ./spout hello-world
	  $ ./drain hello-world

	  Message(properties={spout-id:c877e622-d57b-4df2-bf3e-6014c68da0ea:0}, content='')
        </pre><p>The queue stored the message sent by <span class="command"><strong>spout</strong></span> and delivered
        it to <span class="command"><strong>drain</strong></span> when requested.</p><p>Once the message has been delivered and and acknowledged
	by <span class="command"><strong>drain</strong></span>, it is no longer available on the queue. If we run
	<span class="command"><strong>drain</strong></span> one more time, no messages will be retrieved.</p><pre class="screen">
	  $ ./drain hello-world
	  $
	</pre></div></div><br class="example-break" /><div class="example"><a id="idp32216144" /><p class="title"><strong>Example&#160;2.5.&#160;Topics</strong></p><div class="example-contents"><p>This example is similar to the previous example, but it
	uses a topic instead of a queue.</p><p>First, use <span class="command"><strong>qpid-config</strong></span> to remove the queue
	and create an exchange with the same name:</p><pre class="screen">
	  $ qpid-config del queue hello-world
	  $ qpid-config add exchange topic hello-world
        </pre><p>Now run <span class="command"><strong>drain</strong></span> and <span class="command"><strong>spout</strong></span> the same way we did in the previous example:</p><pre class="screen">
	  $ ./spout hello-world
	  $ ./drain hello-world
	  $
        </pre><p>Topics deliver messages immediately to any interested
        receiver, and do not store messages. Because there were no
        receivers at the time <span class="command"><strong>spout</strong></span> sent the
        message, it was simply discarded. When we ran
        <span class="command"><strong>drain</strong></span>, there were no messages to
        receive.</p><p>Now let's run <span class="command"><strong>drain</strong></span> first, using the
	<code class="literal">-t</code> option to specify a timeout in seconds.
	While <span class="command"><strong>drain</strong></span> is waiting for messages,
	run <span class="command"><strong>spout</strong></span> in another window.</p><p><span class="emphasis"><em>First Window:</em></span></p><pre class="screen">
	  $ ./drain -t 30 hello-word
        </pre><p><span class="emphasis"><em>Second Window:</em></span></p><pre class="screen">
	  $ ./spout hello-word
        </pre><p>Once <span class="command"><strong>spout</strong></span> has sent a message, return
	to the first window to see the output from
	<span class="command"><strong>drain</strong></span>:</p><pre class="screen">
	  Message(properties={spout-id:7da2d27d-93e6-4803-8a61-536d87b8d93f:0}, content='')
        </pre><p>You can run <span class="command"><strong>drain</strong></span> in several separate
	windows; each creates a subscription for the exchange, and
	each receives all messages sent to the exchange.</p></div></div><br class="example-break" /><div class="section" title="2.4.1.&#160;Address Strings"><div class="titlepage"><div><div><h3 class="title"><a id="idp29969744" />2.4.1.&#160;Address Strings</h3></div></div></div><p>So far, our examples have used address strings that
	contain only the name of a node. An <em class="firstterm">address
	string</em> can also contain a
	<em class="firstterm">subject</em> and
	<em class="firstterm">options</em>.</p><p>The syntax for an address string is:</p><pre class="programlisting">
	address_string ::=  &lt;address&gt; [ / &lt;subject&gt; ] [ ; &lt;options&gt; ]
	options ::=  { &lt;key&gt; : &lt;value&gt;, ... }
	</pre><p>Addresses, subjects, and keys are strings.  Values can
	be numbers, strings (with optional single or double quotes),
	maps, or lists. A complete BNF for address strings appears in
	<a class="xref" href="#section-address-string-bnf" title="2.4.4.&#160;Address String Grammar">Section&#160;2.4.4, &#8220;Address String Grammar&#8221;</a>.</p><p>So far, the address strings in this tutorial have only
	used simple names. The following sections show how to use
	subjects and options.</p></div><div class="section" title="2.4.2.&#160;Subjects"><div class="titlepage"><div><div><h3 class="title"><a id="idp29611680" />2.4.2.&#160;Subjects</h3></div></div></div><p>Every message has a property called
	<em class="firstterm">subject</em>, which is analogous to the
	subject on an email message. If no subject is specified, the
	message's subject is null. For convenience, address strings
	also allow a subject. If a sender's address contains a
	subject, it is used as the default subject for the messages
	it sends.

	If a receiver's address contains a subject, it is used to
	select only messages that match the subject&#8212;the matching
	algorithm depends on the message source.
	</p><p>
	  In AMQP 0-10, each exchange type has its own matching
	  algorithm. This is discussed in
	  <a class="xref" href="#section-amqp0-10-mapping" title="2.16.&#160;The AMQP 0-10 mapping">Section&#160;2.16, &#8220;The AMQP 0-10 mapping&#8221;</a>.
	</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;" title="Note"><h3 class="title">Note</h3><p>
	    Currently, a receiver bound to a queue ignores subjects,
	    receiving messages from the queue without filtering. Support
	    for subject filtering on queues will be implemented soon.
	  </p></div><div class="example"><a id="idp29442000" /><p class="title"><strong>Example&#160;2.6.&#160;Using subjects</strong></p><div class="example-contents"><p>In this example we show how subjects affect message
	  flow.</p><p>First, let's use <span class="command"><strong>qpid-config</strong></span> to create a topic exchange.</p><pre class="screen">
	    $ qpid-config add exchange topic news-service
	  </pre><p>Now we use drain to receive messages from <code class="literal">news-service</code> that match the subject <code class="literal">sports</code>.</p><p><span class="emphasis"><em>First Window:</em></span></p><pre class="screen">
	    $ ./drain -t 30 news-service/sports
	  </pre><p>In a second window, let's send messages to <code class="literal">news-service</code> using two different subjects:</p><p><span class="emphasis"><em>Second Window:</em></span></p><pre class="screen">
	    $ ./spout news-service/sports
	    $ ./spout news-service/news
	  </pre><p>Now look at the first window, the message with the
	  subject <code class="literal">sports</code> has been received, but not
	  the message with the subject <code class="literal">news</code>:</p><pre class="screen">
	    Message(properties={qpid.subject:sports, spout-id:9441674e-a157-4780-a78e-f7ccea998291:0}, content='')
	  </pre><p>If you run <span class="command"><strong>drain</strong></span> in multiple
          windows using the same subject, all instances of
          <span class="command"><strong>drain</strong></span> receive the messages for that
          subject.</p></div></div><br class="example-break" /><p>The AMQP exchange type we are using here,
        <code class="literal">amq.topic</code>, can also do more sophisticated
        matching.

	A sender's subject can contain multiple words separated by a
	<span class="quote">&#8220;<span class="quote">.</span>&#8221;</span> delimiter. For instance, in a news
	application, the sender might use subjects like
	<code class="literal">usa.news</code>, <code class="literal">usa.weather</code>,
	<code class="literal">europe.news</code>, or
	<code class="literal">europe.weather</code>.

	The receiver's subject can include wildcard characters&#8212;
	<span class="quote">&#8220;<span class="quote">#</span>&#8221;</span> matches one or more words in the message's
	subject, <span class="quote">&#8220;<span class="quote">*</span>&#8221;</span> matches a single word.

	For instance, if the subject in the source address is
	<code class="literal">*.news</code>, it matches messages with the
	subject <code class="literal">europe.news</code> or
	<code class="literal">usa.news</code>; if it is
	<code class="literal">europe.#</code>, it matches messages with subjects
	like <code class="literal">europe.news</code> or
	<code class="literal">europe.pseudo.news</code>.</p><div class="example"><a id="idp26804384" /><p class="title"><strong>Example&#160;2.7.&#160;Subjects with multi-word keys</strong></p><div class="example-contents"><p>This example uses drain and spout to demonstrate the
	  use of subjects with two-word keys.</p><p>Let's use <span class="command"><strong>drain</strong></span> with the subject
	  <code class="literal">*.news</code> to listen for messages in which
	  the second word of the key is
	  <code class="literal">news</code>.</p><p><span class="emphasis"><em>First Window:</em></span></p><pre class="screen">
	    $ ./drain -t 30 news-service/*.news
	  </pre><p>Now let's send messages using several different
	  two-word keys:</p><p><span class="emphasis"><em>Second Window:</em></span></p><pre class="screen">
	    $ ./spout news-service/usa.news
	    $ ./spout news-service/usa.sports
	    $ ./spout news-service/europe.sports
	    $ ./spout news-service/europe.news
	  </pre><p>In the first window, the messages with
	  <code class="literal">news</code> in the second word of the key have
	  been received:</p><pre class="screen">
	    Message(properties={qpid.subject:usa.news, spout-id:73fc8058-5af6-407c-9166-b49a9076097a:0}, content='')
	    Message(properties={qpid.subject:europe.news, spout-id:f72815aa-7be4-4944-99fd-c64c9747a876:0}, content='')
	  </pre><p>Next, let's use <span class="command"><strong>drain</strong></span> with the
	  subject <code class="literal">#.news</code> to match any sequence of
	  words that ends with <code class="literal">news</code>.</p><p><span class="emphasis"><em>First Window:</em></span></p><pre class="screen">
	    $ ./drain -t 30 news-service/#.news
	  </pre><p>In the second window, let's send messages using a
	  variety of different multi-word keys:</p><p><span class="emphasis"><em>Second Window:</em></span></p><pre class="screen">
	    $ ./spout news-service/news
	    $ ./spout news-service/sports
	    $ ./spout news-service/usa.news
	    $ ./spout news-service/usa.sports
	    $ ./spout news-service/usa.faux.news
	    $ ./spout news-service/usa.faux.sports
	  </pre><p>In the first window, messages with
	  <code class="literal">news</code> in the last word of the key have been
	  received:</p><pre class="screen">
	    Message(properties={qpid.subject:news, spout-id:cbd42b0f-c87b-4088-8206-26d7627c9640:0}, content='')
	    Message(properties={qpid.subject:usa.news, spout-id:234a78d7-daeb-4826-90e1-1c6540781eac:0}, content='')
	    Message(properties={qpid.subject:usa.faux.news, spout-id:6029430a-cfcb-4700-8e9b-cbe4a81fca5f:0}, content='')
	  </pre></div></div><br class="example-break" /></div><div class="section" title="2.4.3.&#160;Address String Options"><div class="titlepage"><div><div><h3 class="title"><a id="idp26821104" />2.4.3.&#160;Address String Options</h3></div></div></div><p>
	  The options in an address string can contain additional
	  information for the senders or receivers created for it,
	  including:
	</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>
	      Policies for assertions about the node to which an address
	      refers.
	    </p><p>
	      For instance, in the address string <code class="literal">my-queue;
	      {assert: always, node:{ type: queue }}</code>, the node
	      named <code class="literal">my-queue</code> must be a queue; if not,
	      the address does not resolve to a node, and an exception
	      is raised.
	    </p></li><li class="listitem"><p>
	      Policies for automatically creating or deleting the node to which an address refers.
	    </p><p>
	      For instance, in the address string <code class="literal">xoxox ; {create: always}</code>,
	      the queue <code class="literal">xoxox</code> is created, if it does
	      not exist, before the address is resolved.
	    </p></li><li class="listitem"><p>
	      Extension points that can be used for sender/receiver configuration.
	    </p><p>
	      For instance, if the address for a receiver is
	      <code class="literal">my-queue; {mode: browse}</code>, the receiver
	      works in <code class="literal">browse</code> mode, leaving messages
	      on the queue so other receivers can receive them.
	    </p></li><li class="listitem"><p>
	      Extension points providing more direct control over the underlying protocol.
	    </p><p>
	      For instance, the <code class="literal">x-bindings</code> property
	      allows greater control over the AMQP 0-10 binding process
	      when an address is resolved.
	    </p></li></ul></div><p>
	  Let's use some examples to show how these different kinds of
	  address string options affect the behavior of senders and
	  receives.
	</p><div class="section" title="2.4.3.1.&#160;assert"><div class="titlepage"><div><div><h4 class="title"><a id="idp32432064" />2.4.3.1.&#160;assert</h4></div></div></div><p>
	    In this section, we use the <code class="literal">assert</code> option
	    to ensure that the address resolves to a node of the required
	    type.
	  </p><div class="example"><a id="idp32433824" /><p class="title"><strong>Example&#160;2.8.&#160;Assertions on Nodes</strong></p><div class="example-contents"><p>Let's use <span class="command"><strong>qpid-config</strong></span> to create a
	    queue and a topic.</p><pre class="screen">
	      $ qpid-config add queue my-queue
	      $ qpid-config add exchange topic my-topic
	    </pre><p>
	      We can now use the address specified to drain to assert that it is
	      of a particular type:
	    </p><pre class="screen">
	      $ ./drain 'my-queue; {assert: always, node:{ type: queue }}'
	      $ ./drain 'my-queue; {assert: always, node:{ type: topic }}'
	      2010-04-20 17:30:46 warning Exception received from broker: not-found: not-found: Exchange not found: my-queue (../../src/qpid/broker/ExchangeRegistry.cpp:92) [caused by 2 \x07:\x01]
	      Exchange my-queue does not exist
	    </pre><p>
	      The first attempt passed without error as my-queue is indeed a
	      queue. The second attempt however failed; my-queue is not a
	      topic.
	    </p><p>
	      We can do the same thing for my-topic:
	    </p><pre class="screen">
	      $ ./drain 'my-topic; {assert: always, node:{ type: topic }}'
	      $ ./drain 'my-topic; {assert: always, node:{ type: queue }}'
	      2010-04-20 17:31:01 warning Exception received from broker: not-found: not-found: Queue not found: my-topic (../../src/qpid/broker/SessionAdapter.cpp:754) [caused by 1 \x08:\x01]
	      Queue my-topic does not exist
	    </pre></div></div><br class="example-break" /><p>Now let's use the <code class="literal">create</code> option to
	  create the queue <code class="literal">xoxox</code> if it does not already
	  exist:</p></div><div class="section" title="2.4.3.2.&#160;create"><div class="titlepage"><div><div><h4 class="title"><a id="idp32441568" />2.4.3.2.&#160;create</h4></div></div></div><p>In previous examples, we created the queue before
	  listening for messages on it. Using <code class="literal">create:
	  always</code>, the queue is automatically created if it
	  does not exist.</p><div class="example"><a id="idp32443328" /><p class="title"><strong>Example&#160;2.9.&#160;Creating a Queue Automatically</strong></p><div class="example-contents"><p><span class="emphasis"><em>First Window:</em></span></p><pre class="screen">$ ./drain -t 30 "xoxox ; {create: always}"</pre><p>Now we can send messages to this queue:</p><p><span class="emphasis"><em>Second Window:</em></span></p><pre class="screen">$ ./spout "xoxox ; {create: always}"</pre><p>Returning to the first window, we see that <span class="command"><strong>drain</strong></span> has received this message:</p><pre class="screen">Message(properties={spout-id:1a1a3842-1a8b-4f88-8940-b4096e615a7d:0}, content='')</pre></div></div><br class="example-break" /><p>The details of the node thus created can be controlled by further options within the node. See <a class="xref" href="#table-node-properties" title="Table&#160;2.2.&#160;Node Properties">Table&#160;2.2, &#8220;Node Properties&#8221;</a> for details.</p></div><div class="section" title="2.4.3.3.&#160;browse"><div class="titlepage"><div><div><h4 class="title"><a id="idp32449600" />2.4.3.3.&#160;browse</h4></div></div></div><p>Some options specify message transfer semantics; for
	  instance, they may state whether messages should be consumed or
	  read in browsing mode, or specify reliability
	  characteristics. The following example uses the
	  <code class="literal">browse</code> option to receive messages without
	  removing them from a queue.</p><div class="example"><a id="idp32451488" /><p class="title"><strong>Example&#160;2.10.&#160;Browsing a Queue</strong></p><div class="example-contents"><p>
	      Let's use the browse mode to receive messages without
	      removing them from the queue. First we send three messages to the
	      queue:
	    </p><pre class="screen">
	      $ ./spout my-queue --content one
	      $ ./spout my-queue --content two
	      $ ./spout my-queue --content three
	    </pre><p>Now we use drain to get those messages, using the browse option:</p><pre class="screen">
	      $ ./drain 'my-queue; {mode: browse}'
	      Message(properties={spout-id:fbb93f30-0e82-4b6d-8c1d-be60eb132530:0}, content='one')
	      Message(properties={spout-id:ab9e7c31-19b0-4455-8976-34abe83edc5f:0}, content='two')
	      Message(properties={spout-id:ea75d64d-ea37-47f9-96a9-d38e01c97925:0}, content='three')
	    </pre><p>We can confirm the messages are still on the queue by repeating the drain:</p><pre class="screen">
	      $ ./drain 'my-queue; {mode: browse}'
	      Message(properties={spout-id:fbb93f30-0e82-4b6d-8c1d-be60eb132530:0}, content='one')
	      Message(properties={spout-id:ab9e7c31-19b0-4455-8976-34abe83edc5f:0}, content='two')
	      Message(properties={spout-id:ea75d64d-ea37-47f9-96a9-d38e01c97925:0}, content='three')
	    </pre></div></div><br class="example-break" /></div><div class="section" title="2.4.3.4.&#160;x-bindings"><div class="titlepage"><div><div><h4 class="title"><a id="idp32456608" />2.4.3.4.&#160;x-bindings</h4></div></div></div><p>Greater control over the AMQP 0-10 binding process can
	  be achieved by including an <code class="literal">x-bindings</code>
	  option in an address string.

	  For instance, the XML Exchange is an AMQP 0-10 custom exchange
	  provided by the Apache Qpid C++ broker. It allows messages to
	  be filtered using XQuery; queries can address either message
	  properties or XML content in the body of the message. The
	  xquery is specified in the arguments field of the AMQP 0-10
	  command. When using the messaging API an xquery can be
	  specified in and address that resolves to an XML exchange by
	  using the x-bindings property.</p><p>An instance of the XML Exchange must be added before it
	  can be used:</p><pre class="programlisting">
	    $ qpid-config add exchange xml xml
	  </pre><p>When using the XML Exchange, a receiver provides an
	  XQuery as an x-binding argument. If the query contains a
	  context item (a path starting with <span class="quote">&#8220;<span class="quote">.</span>&#8221;</span>), then it
	  is applied to the content of the message, which must be
	  well-formed XML. For instance, <code class="literal">./weather</code> is
	  a valid XQuery, which matches any message in which the root
	  element is named <code class="literal">weather</code>. Here is an
	  address string that contains this query:</p><pre class="programlisting">
	  xml; {
	  link: {
	  x-bindings: [{exchange:xml, key:weather, arguments:{xquery:"./weather"} }]
	  }
	  }
	  </pre><p>When using longer queries with <span class="command"><strong>drain</strong></span>,
	  it is often useful to place the query in a file, and use
	  <span class="command"><strong>cat</strong></span> in the command line. We do this in the
	  following example.</p><div class="example"><a id="idp32464992" /><p class="title"><strong>Example&#160;2.11.&#160;Using the XML Exchange</strong></p><div class="example-contents"><p>This example uses an x-binding that contains queries, which filter based on the content of XML messages. Here is an XQuery that we will use in this example:</p><pre class="programlisting">
	      
		       let $w := ./weather
		       return $w/station = 'Raleigh-Durham International Airport (KRDU)'
		       and $w/temperature_f &gt; 50
		       and $w/temperature_f - $w/dewpoint &gt; 5
		       and $w/wind_speed_mph &gt; 7
		       and $w/wind_speed_mph &lt; 20 
	    </pre><p>We can specify this query in an x-binding to listen to messages that meet the criteria specified by the query:</p><p><span class="emphasis"><em>First Window:</em></span></p><pre class="screen">
	      $ ./drain -f "xml; {link:{x-bindings:[{key:'weather',
	      arguments:{xquery:\"$(cat rdu.xquery )\"}}]}}"
	    </pre><p>In another window, let's create an XML message that meets the criteria in the query, and place it in the file <code class="filename">rdu.xml</code>:</p><pre class="programlisting">
	      
		       &lt;weather&gt;
		       &lt;station&gt;Raleigh-Durham International Airport (KRDU)&lt;/station&gt;
		       &lt;wind_speed_mph&gt;16&lt;/wind_speed_mph&gt;
		       &lt;temperature_f&gt;70&lt;/temperature_f&gt;
		       &lt;dewpoint&gt;35&lt;/dewpoint&gt;
		       &lt;/weather&gt;
	      </pre><p>Now let's use <span class="command"><strong>spout</strong></span> to send this message to the XML exchange:</p><p><span class="emphasis"><em>Second Window:</em></span></p><pre class="screen">
		spout --content "$(cat rdu.xml)" xml/weather
	      </pre><p>Returning to the first window, we see that the message has been received:</p><pre class="screen">$ ./drain -f "xml; {link:{x-bindings:[{exchange:'xml', key:'weather', arguments:{xquery:\"$(cat rdu.xquery )\"}}]}}"
	      Message(properties={qpid.subject:weather, spout-id:31c431de-593f-4bec-a3dd-29717bd945d3:0},
	      content='&lt;weather&gt;
	      &lt;station&gt;Raleigh-Durham International Airport (KRDU)&lt;/station&gt;
	      &lt;wind_speed_mph&gt;16&lt;/wind_speed_mph&gt;
	      &lt;temperature_f&gt;40&lt;/temperature_f&gt;
	      &lt;dewpoint&gt;35&lt;/dewpoint&gt;
	      &lt;/weather&gt;') 
	      </pre></div></div><br class="example-break" /></div><div class="section" title="2.4.3.5.&#160;Address String Options - Reference"><div class="titlepage"><div><div><h4 class="title"><a id="idp32476992" />2.4.3.5.&#160;Address String Options - Reference</h4></div></div></div><div class="table"><a id="idp32477632" /><p class="title"><strong>Table&#160;2.1.&#160;Address String Options</strong></p><div class="table-contents"><table border="1" summary="Address String Options" width="100%"><colgroup><col /><col /><col /></colgroup><thead><tr><th>option</th><th>value</th><th>semantics</th></tr></thead><tbody><tr><td>
		    assert
		  </td><td>
		    one of: always, never, sender or receiver
		  </td><td>
		    Asserts that the properties specified in the node option
		    match whatever the address resolves to. If they do not,
		    resolution fails and an exception is raised. 
		  </td></tr><tr><td>
		    create
		  </td><td>
		    one of: always, never, sender or receiver
		  </td><td>
		    Creates the node to which an address refers if it does
		    not exist. No error is raised if the node does
		    exist. The details of the node may be specified in the
		    node option.
		  </td></tr><tr><td>
		    delete
		  </td><td>
		    one of: always, never, sender or receiver
		  </td><td>
		    Delete the node when the sender or receiver is closed.
		  </td></tr><tr><td>
		    node
		  </td><td>
		    A nested map containing the entries shown in <a class="xref" href="#table-node-properties" title="Table&#160;2.2.&#160;Node Properties">Table&#160;2.2, &#8220;Node Properties&#8221;</a>.
		  </td><td>
		    Specifies properties of the node to which the address
		    refers. These are used in conjunction with the assert or
		    create options.
		  </td></tr><tr><td>
		    link
		  </td><td>
		    A nested map containing the entries shown in <a class="xref" href="#table-link-properties" title="Table&#160;2.3.&#160;Link Properties">Table&#160;2.3, &#8220;Link Properties&#8221;</a>.
		  </td><td>
		    Used to control the establishment of a conceptual link
		    from the client application to or from the target/source
		    address.
		  </td></tr><tr><td>
		    mode
		  </td><td>
		    one of: browse, consume
		  </td><td>
		    This option is only of relevance for source addresses
		    that resolve to a queue. If browse is specified the
		    messages delivered to the receiver are left on the queue
		    rather than being removed. If consume is specified the
		    normal behaviour applies; messages are removed from the
		    queue once the client acknowledges their receipt.
		  </td></tr></tbody></table></div></div><br class="table-break" /><div class="table"><a id="table-node-properties" /><p class="title"><strong>Table&#160;2.2.&#160;Node Properties</strong></p><div class="table-contents"><table border="1" summary="Node Properties" width="100%"><colgroup><col /><col /><col /></colgroup><thead><tr><th>property</th><th>value</th><th>semantics</th></tr></thead><tbody><tr><td>
		    type
		  </td><td>
		    topic, queue
		  </td><td>
		    Indicates the type of the node.
		  </td></tr><tr><td>
		    durable
		  </td><td>
		    True, False
		  </td><td>
		    Indicates whether the node survives a loss of
		    volatile storage e.g. if the broker is restarted.
		  </td></tr><tr><td>
		    x-declare
		  </td><td>
		    A nested map whose values correspond to the valid fields
		    on an AMQP 0-10 queue-declare or exchange-declare
		    command.
		  </td><td>
		    These values are used to fine tune the creation or
		    assertion process. Note however that they are protocol
		    specific.
		  </td></tr><tr><td>
		    x-bindings
		  </td><td>
		    A nested list in which each binding is represented by
		    a map. The entries of the map for a binding contain
		    the fields that describe an AMQP 0-10 binding. Here is
		    the format for x-bindings:

		    <pre class="programlisting">
		    [
		    {
		    exchange: &lt;exchange&gt;,
		    queue: &lt;queue&gt;,
		    key: &lt;key&gt;,
		    arguments: {
		    &lt;key_1&gt;: &lt;value_1&gt;,
		    ...,
		    &lt;key_n&gt;: &lt;value_n&gt; }
		    },
		    ...
		    ]
		    </pre>
		  </td><td>
		    In conjunction with the create option, each of these
		    bindings is established as the address is resolved. In
		    conjunction with the assert option, the existence of
		    each of these bindings is verified during
		    resolution. Again, these are protocol specific.
		  </td></tr></tbody></table></div></div><br class="table-break" /><div class="table"><a id="table-link-properties" /><p class="title"><strong>Table&#160;2.3.&#160;Link Properties</strong></p><div class="table-contents"><table border="1" summary="Link Properties" width="100%"><colgroup><col /><col /><col /></colgroup><thead><tr><th>option</th><th>value</th><th>semantics</th></tr></thead><tbody><tr><td>
		    reliability
		  </td><td>
		    one of: unreliable, at-least-once, at-most-once, exactly-once
		  </td><td>
		    Reliability indicates the level of reliability that
		    the sender or receiver.  <code class="literal">unreliable</code>
		    and <code class="literal">at-most-once</code> are currently
		    treated as synonyms, and allow messages to be lost if
		    a broker crashes or the connection to a broker is
		    lost. <code class="literal">at-least-once</code> guarantees that
		    a message is not lost, but duplicates may be
		    received. <code class="literal">exactly-once</code> guarantees
		    that a message is not lost, and is delivered precisely
		    once. Currently only <code class="literal">unreliable</code>
		    and <code class="literal">at-least-once</code> are supported.
		    <sup>[<a class="footnote" href="#ftn.idp32521600" id="idp32521600">a</a>]</sup>
		  </td></tr><tr><td>
		    durable
		  </td><td>
		    True, False
		  </td><td>
		    Indicates whether the link survives a loss of
		    volatile storage e.g. if the broker is restarted.
		  </td></tr><tr><td>
		    x-declare
		  </td><td>
		    A nested map whose values correspond to the valid fields
		    of an AMQP 0-10 queue-declare command.
		  </td><td>
		    These values can be used to customise the subscription
		    queue in the case of receiving from an exchange. Note
		    however that they are protocol specific.
		  </td></tr><tr><td>
		    x-subscribe
		  </td><td>
		    A nested map whose values correspond to the valid fields
		    of an AMQP 0-10 message-subscribe command.
		  </td><td>
		    These values can be used to customise the subscription.
		  </td></tr><tr><td>
		    x-bindings
		  </td><td>
		    A nested list each of whose entries is a map that may
		    contain fields (queue, exchange, key and arguments)
		    describing an AMQP 0-10 binding.
		  </td><td>
		    These bindings are established during resolution
		    independent of the create option. They are considered
		    logically part of the linking process rather than of
		    node creation.
		  </td></tr></tbody><tbody class="footnotes"><tr><td colspan="3"><div class="footnote"><p><sup>[<a class="para" href="#idp32521600" id="ftn.idp32521600">a</a>] </sup>If at-most-once is requested,
		    unreliable will be used and for durable messages on
		    durable queues there is the possibility that messages
		    will be redelivered; if exactly-once is requested,
		    at-least-once will be used and the application needs to
		    be able to deal with duplicates.</p></div></td></tr></tbody></table></div></div><br class="table-break" /></div></div><div class="section" title="2.4.4.&#160;Address String Grammar"><div class="titlepage"><div><div><h3 class="title"><a id="section-address-string-bnf" />2.4.4.&#160;Address String Grammar</h3></div></div></div><p>This section provides a formal grammar for address strings.</p><p title="Tokens"><strong>Tokens.&#160;</strong>The following regular expressions define the tokens used
	to parse address strings:</p><pre class="programlisting">
	LBRACE: \\{
	RBRACE: \\}
	LBRACK: \\[
	RBRACK: \\]
	COLON:  :
	SEMI:   ;
	SLASH:  /
	COMMA:  ,
	NUMBER: [+-]?[0-9]*\\.?[0-9]+
	ID:     [a-zA-Z_](?:[a-zA-Z0-9_-]*[a-zA-Z0-9_])?
	STRING: "(?:[^\\\\"]|\\\\.)*"|\'(?:[^\\\\\']|\\\\.)*\'
	ESC:    \\\\[^ux]|\\\\x[0-9a-fA-F][0-9a-fA-F]|\\\\u[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F]
	SYM:    [.#*%@$^!+-]
	WSPACE: [ \\n\\r\\t]+
	</pre><p title="Grammar"><strong>Grammar.&#160;</strong>The formal grammar for addresses is given below:</p><pre class="programlisting">
	address := name [ SLASH subject ] [ ";" options ]
	name := ( part | quoted )+
	subject := ( part | quoted | SLASH )*
	quoted := STRING / ESC
	part := LBRACE / RBRACE / COLON / COMMA / NUMBER / ID / SYM
	options := map
	map := "{" ( keyval ( "," keyval )* )? "}"
	keyval "= ID ":" value
	value := NUMBER / STRING / ID / map / list
	list := "[" ( value ( "," value )* )? "]"
	</pre><p title="Address String Options"><strong>Address String Options.&#160;</strong>The address string options map supports the following parameters:</p><pre class="programlisting">
	&lt;name&gt; [ / &lt;subject&gt; ] ; {
	create: always | sender | receiver | never,
	delete: always | sender | receiver | never,
	assert: always | sender | receiver | never,
	mode: browse | consume,
	node: {
	type: queue | topic,
	durable: True | False,
	x-declare: { ... &lt;declare-overrides&gt; ... },
	x-bindings: [&lt;binding_1&gt;, ... &lt;binding_n&gt;]
	},
	link: {
	name: &lt;link-name&gt;,
	durable: True | False,
	reliability: unreliable | at-most-once | at-least-once | exactly-once,
	x-declare: { ... &lt;declare-overrides&gt; ... },
	x-bindings: [&lt;binding_1&gt;, ... &lt;binding_n&gt;],
	x-subscribe: { ... &lt;subscribe-overrides&gt; ... }
	}
	}
	</pre><div class="itemizedlist" title="Create, Delete, and Assert Policies"><p class="title"><strong>Create, Delete, and Assert Policies</strong></p><p>The create, delete, and assert policies specify who should
	  perfom the associated action:</p><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>always</em></span>: the action is performed by any messaging client</p></li><li class="listitem"><p><span class="emphasis"><em>sender</em></span>: the action is only performed by a sender</p></li><li class="listitem"><p><span class="emphasis"><em>receiver</em></span>: the action is only performed by a receiver</p></li><li class="listitem"><p><span class="emphasis"><em>never</em></span>: the action is never performed (this is the default)</p></li></ul></div><div class="itemizedlist" title="Node-Type"><p class="title"><strong>Node-Type</strong></p><p>The node-type is one of:</p><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>topic</em></span>: in the AMQP 0-10
	  mapping, a topic node defaults to the topic exchange, x-declare
	  may be used to specify other exchange types</p></li><li class="listitem"><p><span class="emphasis"><em>queue</em></span>: this is the default node-type</p></li></ul></div></div><div class="footnotes"><br /><hr align="left" width="100" /><div class="footnote"><p><sup>[<a class="para" href="#idp30929088" id="ftn.idp30929088">2</a>] </sup>In the programs we have just seen, we used
      <code class="literal">amq.topic</code> as the default address if none is
      passed in. This is the name of a standard exchange that always
      exists on an AMQP 0-10 messaging broker.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp31866448" id="ftn.idp31866448">3</a>] </sup>The terms <span class="emphasis"><em>queue</em></span> and
      <span class="emphasis"><em>topic</em></span> here were chosen to align with
      their meaning in JMS. These two addressing 'patterns',
      queue and topic, are sometimes refered as point-to-point
      and publish-subscribe. AMQP 0-10 has an exchange type
      called a <span class="emphasis"><em>topic exchange</em></span>. When the term
      <span class="emphasis"><em>topic</em></span> occurs alone, it refers to a
      Messaging API topic, not the topic
      exchange.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp29704896" id="ftn.idp29704896">4</a>] </sup>There are exceptions to this rule; for instance,
      a receiver can use <code class="literal">browse</code> mode, which leaves
      messages on the queue for other receivers to
      read.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp31492912" id="ftn.idp31492912">5</a>] </sup>The AMQP 0-10 implementation is the only one
      that currently exists.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp30057568" id="ftn.idp30057568">6</a>] </sup>In AMQP 0-10, messages are sent to
      exchanges, and read from queues. The Messaging API also
      allows a sender to send messages to a queue; internally,
      Qpid implements this by sending the message to the default
      exchange, with the name of the queue as the routing key. The
      Messaging API also allows a receiver to receive messages
      from a topic; internally, Qpid implements this by setting up
      a private subscription queue for the receiver and binding
      the subscription queue to the exchange that corresponds to
      the topic.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp30167472" id="ftn.idp30167472">7</a>] </sup>Currently, the C++, Python, and .NET C#
      implementations of <span class="command"><strong>drain</strong></span> and
      <span class="command"><strong>spout</strong></span> have slightly different
      options. This tutorial uses the C++ implementation. The
      options will be reconciled in the near
      future.</p></div></div></div><div class="section" title="2.5.&#160;Sender Capacity and Replay"><div class="titlepage"><div><div><h2 class="title"><a id="replay" />2.5.&#160;Sender Capacity and Replay</h2></div></div></div><p>The send method of a sender has an optional second parameter
      that controls whether the send call is synchronous or not. A
      synchronous send call will block until the broker has confirmed
      receipt of the message. An asynchronous send call will return
      before the broker confirms receipt of the message, allowing for
      example further send calls to be made without waiting for a
      roundtrip to the broker for each message. This is desirable where
      increased throughput is important.</p><p>The sender maintains a list of sent messages whose receipt
      has yet to be confirmed by the broker. The maximum number of such
      messages that it will hold is defined by the capacity of the
      sender, which can be set by the application. If an application
      tries to send with a sender whose capacity is already fully used
      up, the send call will block waiting for capacity regardless of
      the value of the sync flag.</p><p>The sender can be queried for the available space (i.e. the
      unused capacity), and for the current count of unsettled messages
      (i.e. those held in the replay list pending confirmation by the
      server). When the unsettled count is zero, all messages on that
      sender have been successfully sent.</p><p>If the connection fails and is transparently reconnected
      (see <a class="xref" href="#connection-options" title="2.10.&#160;Connection Options">Section&#160;2.10, &#8220;Connection Options&#8221;</a> for details on how to control
      this feature), the unsettled messages for each sender over that
      connection will be re-transmitted. This provides a transparent
      level of reliability. This feature can be controlled through the
      link's reliability as defined in the address (see
      <a class="xref" href="#table-link-properties" title="Table&#160;2.3.&#160;Link Properties">Table&#160;2.3, &#8220;Link Properties&#8221;</a>). At present only
      at-least-once guarantees are offered. </p></div><div class="section" title="2.6.&#160;Receiver Capacity (Prefetch)"><div class="titlepage"><div><div><h2 class="title"><a id="prefetch" />2.6.&#160;Receiver Capacity (Prefetch)</h2></div></div></div><p>By default, a receiver requests the next message from the
      server in response to each fetch call, resulting in messages being
      sent to the receiver one at a time. As in the case of sending, it
      is often desirable to avoid this roundtrip for each message. This
      can be achieved by allowing the receiver
      to <em class="firstterm">prefetch</em> messages in anticipation of
      fetch calls being made. The receiver needs to be able to store
      these prefetched messages, the number it can hold is controlled by
      the receivers capacity.</p></div><div class="section" title="2.7.&#160;Acknowledging Received Messages"><div class="titlepage"><div><div><h2 class="title"><a id="acknowledgements" />2.7.&#160;Acknowledging Received Messages</h2></div></div></div><p>Applications that receive messages should acknowledge their
      receipt by calling the session's acknowledge method. As in the
      case of sending messages, acknowledged transfer of messages to
      receivers provides at-least-once reliability, which means that the
      loss of the connection or a client crash does not result in lost
      messages; durable messages are not lost even if the broker is
      restarted.

      Some cases may not require this however and the reliability can be
      controlled through a link property in the address options (see
      <a class="xref" href="#table-link-properties" title="Table&#160;2.3.&#160;Link Properties">Table&#160;2.3, &#8220;Link Properties&#8221;</a>).</p><p>The acknowledge call acknowledges all messages received on
      the session (i.e. all message that have been returned from a fetch
      call on a receiver created on that session).</p><p>The acknowledge call also support an optional parameter
      controlling whether the call is synchronous or not. A synchronous
      acknowledge will block until the server has confirmed that it has
      received the acknowledgement. In the asynchronous case, when the
      call returns there is not yet any guarantee that the server has
      received and processed the acknowledgement. The session may be
      queried for the number of unsettled acknowledgements; when that
      count is zero all acknowledgements made for received messages have
      been successful.</p></div><div class="section" title="2.8.&#160;Receiving Messages from Multiple Sources"><div class="titlepage"><div><div><h2 class="title"><a id="idp32566288" />2.8.&#160;Receiving Messages from Multiple Sources</h2></div></div></div><p>A receiver can only read from one source, but many
      programs need to be able to read messages from many sources. In
      the Qpid Messaging API, a program can ask a session for
      the <span class="quote">&#8220;<span class="quote">next receiver</span>&#8221;</span>; that is, the receiver that is
      responsible for the next available message. The following
      examples show how this is done in C++, Python, and .NET C#.
      </p><p>Note that to use this pattern you must enable prefetching
      for each receiver of interest so that the broker will send
      messages before a fetch call is made. See
      <a class="xref" href="#prefetch" title="2.6.&#160;Receiver Capacity (Prefetch)">Section&#160;2.6, &#8220;Receiver Capacity (Prefetch)&#8221;</a> for more on this.</p><div class="example"><a id="idp32569168" /><p class="title"><strong>Example&#160;2.12.&#160;Receiving Messages from Multiple Sources</strong></p><div class="example-contents"><p>C++:</p><pre class="programlisting">
	Receiver receiver1 = session.createReceiver(address1);
	receiver1.setCapacity(10);
	Receiver receiver2 = session.createReceiver(address2);
	receiver2.setCapacity(10);

	Message message =  session.nextReceiver().fetch();
	std::cout &lt;&lt; message.getContent() &lt;&lt; std::endl;
	session.acknowledge(); // acknowledge message receipt
		  </pre><p>Python:</p><pre class="programlisting">
	receiver1 = session.receiver(address1)
	receiver1.capacity = 10
	receiver2 = session.receiver(address)
	receiver2.capacity = 10
	message = session.next_receiver().fetch()
	print message.content
	session.acknowledge()
		  </pre><p>.NET C#:</p><pre class="programlisting">
	Receiver receiver1 = session.CreateReceiver(address1);
	receiver1.Capacity = 10;
	Receiver receiver2 = session.CreateReceiver(address2);
	receiver2.Capacity = 10;

	Message message = new Message();
	message =  session.NextReceiver().Fetch();
	Console.WriteLine("{0}", message.GetContent());
	session.Acknowledge();
		  </pre></div></div><br class="example-break" /></div><div class="section" title="2.9.&#160;Transactions"><div class="titlepage"><div><div><h2 class="title"><a id="idp32574976" />2.9.&#160;Transactions</h2></div></div></div><p>Sometimes it is useful to be able to group messages
      transfers - sent and/or received - on a session into atomic
      grouping. This can be done be creating the session as
      transactional. On a transactional session sent messages only
      become available at the target address on commit. Likewise any
      received and acknowledged messages are only discarded at their
      source on commit

      <sup>[<a class="footnote" href="#ftn.idp32576304" id="idp32576304">8</a>]</sup>

      .</p><div class="example"><a id="idp32577216" /><p class="title"><strong>Example&#160;2.13.&#160;Transactions</strong></p><div class="example-contents"><p>C++:</p><pre class="programlisting">
	Connection connection(broker);
	Session session =  connection.createTransactionalSession();
	...
	if (smellsOk())
	session.commit();
	else
	session.rollback();
	</pre><p>
	  .NET C#:
	</p><pre class="programlisting">
	  Connection connection = new Connection(broker);
	  Session session =  connection.CreateTransactionalSession();
	  ...
	  if (smellsOk())
	  session.Commit();
	  else
	  session.Rollback();
	</pre></div></div><br class="example-break" /><div class="footnotes"><br /><hr align="left" width="100" /><div class="footnote"><p><sup>[<a class="para" href="#idp32576304" id="ftn.idp32576304">8</a>] </sup>Note that this currently is only true for
      messages received using a reliable mode
      e.g. at-least-once. Messages sent by a broker to a receiver in
      unreliable receiver will be discarded immediately regardless of
      transctionality.</p></div></div></div><div class="section" title="2.10.&#160;Connection Options"><div class="titlepage"><div><div><h2 class="title"><a id="connection-options" />2.10.&#160;Connection Options</h2></div></div></div><p>
        Aspects of the connections behaviour can be controlled through
        specifying connection options. For example, connections can be
        configured to automatically reconnect if the connection to a
        broker is lost.
      </p><div class="example"><a id="idp32582480" /><p class="title"><strong>Example&#160;2.14.&#160;Specifying Connection Options in C++, Python, and .NET</strong></p><div class="example-contents"><p>In C++, these options can be set using <code class="function">Connection::setOption()</code> or by passing in a set of options to the constructor. The options can be passed in as a map or in string form:</p><pre class="programlisting">
	Connection connection("localhost:5672", "{reconnect: true}");
	try {
	connection.open();
	!!! SNIP !!!
	</pre><p>or</p><pre class="programlisting">
	Connection connection("localhost:5672");
	connection.setOption("reconnect", true);
	try {
	connection.open();
	!!! SNIP !!!
	</pre><p>In Python, these options can be set as attributes of the connection or using named arguments in
	the <code class="function">Connection</code> constructor:</p><pre class="programlisting">
	connection = Connection("localhost:5672", reconnect=True)
	try:
	connection.open()
	!!! SNIP !!!
	</pre><p>or</p><pre class="programlisting">
	connection = Connection("localhost:5672")
	connection.reconnect = True
	try:
	connection.open()
	!!! SNIP !!!
	</pre><p>
	  In .NET, these options can be set using <code class="function">Connection.SetOption()</code> or by passing in a set of options to the constructor. The options can be passed in as a map or in string form:
	</p><pre class="programlisting">
	  Connection connection= new Connection("localhost:5672", "{reconnect: true}");
	  try {
	  connection.Open();
	  !!! SNIP !!!
	</pre><p>
	  or
	</p><pre class="programlisting">
	  Connection connection = new Connection("localhost:5672");
	  connection.SetOption("reconnect", true);
	  try {
	  connection.Open();
	  !!! SNIP !!!
	</pre><p>See the reference documentation for details in each language.</p></div></div><br class="example-break" /><p>The following table lists the supported connection options.</p><div class="table"><a id="idp32593632" /><p class="title"><strong>Table&#160;2.4.&#160;Connection Options</strong></p><div class="table-contents"><table border="1" summary="Connection Options" width="100%"><colgroup><col /><col /><col /></colgroup><thead><tr><th>option name</th><th>value type</th><th>semantics</th></tr></thead><tbody><tr><td>
		<code class="literal">username</code>
	      </td><td>
		string
	      </td><td>
		The username to use when authenticating to the broker.
	      </td></tr><tr><td>
		<code class="literal">password</code>
	      </td><td>
		string
	      </td><td>
		The password to use when authenticating to the broker.
	      </td></tr><tr><td>
		<code class="literal">sasl_mechanisms</code>
	      </td><td>
		string
	      </td><td>
		The specific SASL mechanisms to use with the python
		client when authenticating to the broker. The value
		is a space separated list.
	      </td></tr><tr><td>
		<code class="literal">reconnect</code>
	      </td><td>
		boolean
	      </td><td>
		Transparently reconnect if the connection is lost.
	      </td></tr><tr><td>
		<code class="literal">reconnect_timeout</code>
	      </td><td>
		integer
	      </td><td>
		Total number of seconds to continue reconnection attempts before giving up and raising an exception.
	      </td></tr><tr><td>
		<code class="literal">reconnect_limit</code>
	      </td><td>
		integer
	      </td><td>
		Maximum number of reconnection attempts before giving up and raising an exception.
	      </td></tr><tr><td>
		<code class="literal">reconnect_interval_min</code>
	      </td><td>
		integer representing time in seconds
	      </td><td>
		Minimum number of seconds between reconnection attempts. The first reconnection attempt is made immediately; if that fails, the first reconnection delay is set to the value of <code class="literal">reconnect_interval_min</code>; if that attempt fails, the reconnect interval increases exponentially until a reconnection attempt succeeds or <code class="literal">reconnect_interval_max</code> is reached.
	      </td></tr><tr><td>
		<code class="literal">reconnect_interval_max</code>
	      </td><td>
		integer representing time in seconds
	      </td><td>
		Maximum reconnect interval.
	      </td></tr><tr><td>
		<code class="literal">reconnect_interval</code>
	      </td><td>
		integer representing time in seconds
	      </td><td>
		Sets both <code class="literal">reconnection_interval_min</code> and <code class="literal">reconnection_interval_max</code> to the same value.
	      </td></tr><tr><td>
		<code class="literal">heartbeat</code>
	      </td><td>
		integer representing time in seconds
	      </td><td>
		Requests that heartbeats be sent every N seconds. If two
		successive heartbeats are missed the connection is
		considered to be lost.
	      </td></tr><tr><td>
		<code class="literal">protocol</code>
	      </td><td>
		string
	      </td><td>
		Sets the underlying protocol used. The default option is 'tcp'. To enable ssl, set to 'ssl'. The C++ client additionally supports 'rdma'.
	      </td></tr><tr><td>
		<code class="literal">tcp-nodelay</code>
	      </td><td>
		boolean
	      </td><td>
		Set tcp no-delay, i.e. disable Nagle algorithm. [C++ only]
	      </td></tr></tbody></table></div></div><br class="table-break" /></div><div class="section" title="2.11.&#160;Maps and Lists in Message Content"><div class="titlepage"><div><div><h2 class="title"><a id="section-Maps" />2.11.&#160;Maps and Lists in Message Content</h2></div></div></div><p>Many messaging applications need to exchange data across
      languages and platforms, using the native datatypes of each
      programming language.</p><p>The Qpid Messaging API supports <code class="classname">map</code> and <code class="classname">list</code> in message content.

      <sup>[<a class="footnote" href="#ftn.idp32631888" id="idp32631888">9</a>]</sup>

      <sup>[<a class="footnote" href="#ftn.idp32632496" id="idp32632496">10</a>]</sup>
      Specific language support for <code class="classname">map</code> and <code class="classname">list</code> objects are shown in the following table.
      </p><div class="table"><a id="tabl-Programming_in_Apache_Qpid-Qpid_Maps_in_Message_Content" /><p class="title"><strong>Table&#160;2.5.&#160;Map and List Representation in Supported Languages</strong></p><div class="table-contents"><table border="1" summary="Map and List Representation in Supported Languages"><colgroup><col /><col /><col /></colgroup><thead><tr><th>Language</th><th>map</th><th>list</th></tr></thead><tbody><tr><td>Python</td><td><code class="classname">dict</code></td><td><code class="classname">list</code></td></tr><tr><td>C++</td><td><code class="classname">Variant::Map</code></td><td><code class="classname">Variant::List</code></td></tr><tr><td>Java</td><td><code class="classname">MapMessage</code></td><td><code class="classname">&#160;</code></td></tr><tr><td>.NET</td><td><code class="classname">Dictionary&lt;string, object&gt;</code></td><td><code class="classname">Collection&lt;object&gt;</code></td></tr></tbody></table></div></div><br class="table-break" /><p>
	In all languages, messages are encoded using AMQP's portable datatypes.
      </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;" title="Tip"><h3 class="title">Tip</h3><p>Because of the differences in type systems among
	languages, the simplest way to provide portable messages is to
	rely on maps, lists, strings, 64 bit signed integers, and
	doubles for messages that need to be exchanged across languages
	and platforms.</p></div><div class="section" title="2.11.1.&#160;Qpid Maps and Lists in Python"><div class="titlepage"><div><div><h3 class="title"><a id="section-Python-Maps" />2.11.1.&#160;Qpid Maps and Lists in Python</h3></div></div></div><p>In Python, Qpid supports the <code class="classname">dict</code> and <code class="classname">list</code> types directly in message content. The following code shows how to send these structures in a message:</p><div class="example"><a id="idp32650064" /><p class="title"><strong>Example&#160;2.15.&#160;Sending Qpid Maps and Lists in Python</strong></p><div class="example-contents"><pre class="programlisting">
	  from qpid.messaging import *
	  # !!! SNIP !!!

	  content = {'Id' : 987654321, 'name' : 'Widget', 'percent' : 0.99}
	  content['colours'] = ['red', 'green', 'white']
	  content['dimensions'] = {'length' : 10.2, 'width' : 5.1,'depth' : 2.0};
	  content['parts'] = [ [1,2,5], [8,2,5] ]
	  content['specs'] = {'colors' : content['colours'],
	  'dimensions' : content['dimensions'],
	  'parts' : content['parts'] }
	  message = Message(content=content)
	  sender.send(message)
	     </pre></div></div><br class="example-break" /><p>The following table shows the datatypes that can be sent in a Python map message,
	and the corresponding datatypes that will be received by clients in Java or C++.</p><div class="table"><a id="table-Python-Maps" /><p class="title"><strong>Table&#160;2.6.&#160;Python Datatypes in Maps</strong></p><div class="table-contents"><table border="1" summary="Python Datatypes in Maps"><colgroup><col /><col /><col /></colgroup><thead><tr><th>Python Datatype</th><th>&#8594; C++</th><th>&#8594; Java</th></tr></thead><tbody><tr><td>bool</td><td>bool</td><td>boolean</td></tr><tr><td>int</td><td>int64</td><td>long</td></tr><tr><td>long</td><td>int64</td><td>long</td></tr><tr><td>float</td><td>double</td><td>double</td></tr><tr><td>unicode</td><td>string</td><td>java.lang.String</td></tr><tr><td>uuid</td><td>qpid::types::Uuid</td><td>java.util.UUID</td></tr><tr><td>dict</td><td>Variant::Map</td><td>java.util.Map</td></tr><tr><td>list</td><td>Variant::List</td><td>java.util.List</td></tr></tbody></table></div></div><br class="table-break" /></div><div class="section" title="2.11.2.&#160;Qpid Maps and Lists in C++"><div class="titlepage"><div><div><h3 class="title"><a id="section-cpp-Maps" />2.11.2.&#160;Qpid Maps and Lists in C++</h3></div></div></div><p>In C++, Qpid defines the the
	<code class="classname">Variant::Map</code> and
	<code class="classname">Variant::List</code> types, which can be
	encoded into message content. The following code shows how to
	send these structures in a message:</p><div class="example"><a id="idp32668912" /><p class="title"><strong>Example&#160;2.16.&#160;Sending Qpid Maps and Lists in C++</strong></p><div class="example-contents"><pre class="programlisting">
	  using namespace qpid::types;

	  // !!! SNIP !!!

	  Message message;
	  Variant::Map content;
	  content["id"] = 987654321;
	  content["name"] = "Widget";
	  content["percent"] = 0.99;
	  Variant::List colours;
	  colours.push_back(Variant("red"));
	  colours.push_back(Variant("green"));
	  colours.push_back(Variant("white"));
	  content["colours"] = colours;

	  Variant::Map dimensions;
	  dimensions["length"] = 10.2;
	  dimensions["width"] = 5.1;
	  dimensions["depth"] = 2.0;
	  content["dimensions"]= dimensions;

	  Variant::List part1;
	  part1.push_back(Variant(1));
	  part1.push_back(Variant(2));
	  part1.push_back(Variant(5));

	  Variant::List part2;
	  part2.push_back(Variant(8));
	  part2.push_back(Variant(2));
	  part2.push_back(Variant(5));

	  Variant::List parts;
	  parts.push_back(part1);
	  parts.push_back(part2);
	  content["parts"]= parts;

	  Variant::Map specs;
	  specs["colours"] = colours;
	  specs["dimensions"] = dimensions;
	  specs["parts"] = parts;
	  content["specs"] = specs;

	  encode(content, message);
	  sender.send(message, true);
	       </pre></div></div><br class="example-break" /><p>The following table shows the datatypes that can be sent
	in a C++ map message, and the corresponding datatypes that
	will be received by clients in Java and Python.</p><div class="table"><a id="table-cpp-Maps" /><p class="title"><strong>Table&#160;2.7.&#160;C++ Datatypes in Maps</strong></p><div class="table-contents"><table border="1" summary="C++ Datatypes in Maps"><colgroup><col /><col /><col /></colgroup><thead><tr><th>C++ Datatype</th><th>&#8594; Python</th><th>&#8594; Java</th></tr></thead><tbody><tr><td>bool</td><td>bool</td><td>boolean</td></tr><tr><td>uint16</td><td>int | long</td><td>short</td></tr><tr><td>uint32</td><td>int | long</td><td>int</td></tr><tr><td>uint64</td><td>int | long</td><td>long</td></tr><tr><td>int16</td><td>int | long</td><td>short</td></tr><tr><td>int32</td><td>int | long</td><td>int</td></tr><tr><td>int64</td><td>int | long</td><td>long</td></tr><tr><td>float</td><td>float</td><td>float</td></tr><tr><td>double</td><td>float</td><td>double</td></tr><tr><td>string</td><td>unicode</td><td>java.lang.String</td></tr><tr><td>qpid::types::Uuid</td><td>uuid</td><td>java.util.UUID</td></tr><tr><td>Variant::Map</td><td>dict</td><td>java.util.Map</td></tr><tr><td>Variant::List</td><td>list</td><td>java.util.List</td></tr></tbody></table></div></div><br class="table-break" /></div><div class="section" title="2.11.3.&#160;Qpid Maps and Lists in .NET"><div class="titlepage"><div><div><h3 class="title"><a id="section-dotnet-Maps" />2.11.3.&#160;Qpid Maps and Lists in .NET</h3></div></div></div><p>
	  The .NET binding for the Qpid Messaging API binds .NET managed data types
	  to C++ <code class="classname">Variant</code> data types.  The following code shows how to
	  send Map and List structures in a message:
	</p><div class="example"><a id="idp32692448" /><p class="title"><strong>Example&#160;2.17.&#160;Sending Qpid Maps and Lists in .NET C#</strong></p><div class="example-contents"><pre class="programlisting">
	  using System;
	  using Org.Apache.Qpid.Messaging;

	  // !!! SNIP !!!

	  Dictionary&lt;string, object&gt; content = new Dictionary&lt;string, object&gt;();
	  Dictionary&lt;string, object&gt; subMap = new Dictionary&lt;string, object&gt;();
	  Collection&lt;object&gt; colors = new Collection&lt;object&gt;();

	  // add simple types
	  content["id"] = 987654321;
	  content["name"] = "Widget";
	  content["percent"] = 0.99;

	  // add nested amqp/map
	  subMap["name"] = "Smith";
	  subMap["number"] = 354;
	  content["nestedMap"] = subMap;

	  // add an amqp/list
	  colors.Add("red");
	  colors.Add("green");
	  colors.Add("white");
	  content["colorsList"] = colors;

	  // add one of each supported amqp data type
	  bool mybool = true;
	  content["mybool"] = mybool;

	  byte mybyte = 4;
	  content["mybyte"] = mybyte;

	  UInt16 myUInt16 = 5;
	  content["myUInt16"] = myUInt16;

	  UInt32 myUInt32 = 6;
	  content["myUInt32"] = myUInt32;

	  UInt64 myUInt64 = 7;
	  content["myUInt64"] = myUInt64;

	  char mychar = 'h';
	  content["mychar"] = mychar;

	  Int16 myInt16 = 9;
	  content["myInt16"] = myInt16;

	  Int32 myInt32 = 10;
	  content["myInt32"] = myInt32;

	  Int64 myInt64 = 11;
	  content["myInt64"] = myInt64;

	  Single mySingle = (Single)12.12;
	  content["mySingle"] = mySingle;

	  Double myDouble = 13.13;
	  content["myDouble"] = myDouble;

	  Guid myGuid = new Guid("000102030405060708090a0b0c0d0e0f");
	  content["myGuid"] = myGuid;

	  Message message = new Message(content);
	  Send(message, true);
	       </pre></div></div><br class="example-break" /><p>
	  The following table shows the mapping between datatypes in .NET and C++.
	</p><div class="table"><a id="table-dotnet-Maps" /><p class="title"><strong>Table&#160;2.8.&#160;Datatype Mapping between C++ and .NET binding</strong></p><div class="table-contents"><table border="1" summary="Datatype Mapping between C++ and .NET binding"><colgroup><col /><col /></colgroup><thead><tr><th>C++ Datatype</th><th>&#8594; .NET binding</th></tr></thead><tbody><tr><td>void</td><td>nullptr</td></tr><tr><td>bool</td><td>bool</td></tr><tr><td>uint8</td><td>byte</td></tr><tr><td>uint16</td><td>UInt16</td></tr><tr><td>uint32</td><td>UInt32</td></tr><tr><td>uint64</td><td>UInt64</td></tr><tr><td>uint8</td><td>char</td></tr><tr><td>int16</td><td>Int16</td></tr><tr><td>int32</td><td>Int32</td></tr><tr><td>int64</td><td>Int64</td></tr><tr><td>float</td><td>Single</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>string</td><td>string
	      <sup>[<a class="footnote" href="#ftn.callout-dotnet-string" id="callout-dotnet-string">a</a>]</sup></td></tr><tr><td>qpid::types::Uuid</td><td>Guid</td></tr><tr><td>Variant::Map</td><td>Dictionary&lt;string, object&gt;
	      <sup>[<a class="footnoteref" href="#ftn.callout-dotnet-string">a</a>]</sup></td></tr><tr><td>Variant::List</td><td>Collection&lt;object&gt;
	      <sup>[<a class="footnoteref" href="#ftn.callout-dotnet-string">a</a>]</sup></td></tr></tbody><tbody class="footnotes"><tr><td colspan="2"><div class="footnote"><p><sup>[<a class="para" href="#callout-dotnet-string" id="ftn.callout-dotnet-string">a</a>] </sup>Strings are currently interpreted only with UTF-8 encoding.</p></div></td></tr></tbody></table></div></div><br class="table-break" /></div><div class="footnotes"><br /><hr align="left" width="100" /><div class="footnote"><p><sup>[<a class="para" href="#idp32631888" id="ftn.idp32631888">9</a>] </sup>Unlike JMS, there is not a specific message type for
      map messages.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp32632496" id="ftn.idp32632496">10</a>] </sup>
	  Note that the Qpid JMS client supports MapMessages whose values can be nested maps or lists. This is not standard JMS behaviour.
	</p></div></div></div><div class="section" title="2.12.&#160;The Request / Response Pattern"><div class="titlepage"><div><div><h2 class="title"><a id="idp32715392" />2.12.&#160;The Request / Response Pattern</h2></div></div></div><p>Request / Response applications use the reply-to property,
      described in <a class="xref" href="#table-amqp0-10-message-properties" title="Table&#160;2.9.&#160;Mapping to AMQP 0-10 Message Properties">Table&#160;2.9, &#8220;Mapping to AMQP 0-10 Message Properties&#8221;</a>, to allow a server
      to respond to the client that sent a message. A server sets up a
      service queue, with a name known to clients. A client creates a
      private queue for the server's response, creates a message for a
      request, sets the request's reply-to property to the address of
      the client's response queue, and sends the request to the
      service queue. The server sends the response to the address
      specified in the request's reply-to property.
      </p><div class="example"><a id="idp32717520" /><p class="title"><strong>Example&#160;2.18.&#160;Request / Response Applications in C++</strong></p><div class="example-contents"><p>This example shows the C++ code for a client and server
	that use the request / response pattern.</p><p>The server creates a service queue and waits for a
	message to arrive. If it receives a message, it sends a
	message back to the sender.</p><pre class="programlisting">Receiver receiver = session.createReceiver("service_queue; {create: always}");

	Message request = receiver.fetch();
	const Address&amp;amp; address = request.getReplyTo(); // Get "reply-to" from request ...
	if (address) {
	Sender sender = session.createSender(address); // ... send response to "reply-to"
	Message response("pong!");
	sender.send(response);
	session.acknowledge();
	}
	</pre><p>The client creates a sender for the service queue, and
	also creates a response queue that is deleted when the
	client closes the receiver for the response queue. In the C++
	client, if the address starts with the character
	<code class="literal">#</code>, it is given a unique name.</p><pre class="programlisting">
	Sender sender = session.createSender("service_queue");

	Address responseQueue("#response-queue; {create:always, delete:always}");
	Receiver receiver = session.createReceiver(responseQueue);

	Message request;
	request.setReplyTo(responseQueue);
	request.setContent("ping");
	sender.send(request);
	Message response = receiver.fetch();
	std::cout &lt;&lt; request.getContent() &lt;&lt; " -&gt; " &lt;&lt; response.getContent() &lt;&lt; std::endl;
		  </pre><p>The client sends the string <code class="literal">ping</code> to
	the server. The server sends the response
	<code class="literal">pong</code> back to the same client, using the
	<code class="varname">replyTo</code> property.</p></div></div><br class="example-break" /></div><div class="section" title="2.13.&#160;Performance Tips"><div class="titlepage"><div><div><h2 class="title"><a id="idp32725776" />2.13.&#160;Performance Tips</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Consider prefetching messages for receivers (see
          <a class="xref" href="#prefetch" title="2.6.&#160;Receiver Capacity (Prefetch)">Section&#160;2.6, &#8220;Receiver Capacity (Prefetch)&#8221;</a>). This helps eliminate roundtrips
          and increases throughput. Prefetch is disabled by default,
          and enabling it is the most effective means of improving
          throughput of received messages.</p></li><li class="listitem"><p>Send messages asynchronously. Again, this helps
          eliminate roundtrips and increases throughput. The C++ and
          .NET clients send asynchronously by default, however the
          python client defaults to synchronous sends.  </p></li><li class="listitem"><p>Acknowledge messages in batches (see
          <a class="xref" href="#acknowledgements" title="2.7.&#160;Acknowledging Received Messages">Section&#160;2.7, &#8220;Acknowledging Received Messages&#8221;</a>). Rather than
          acknowledging each message individually, consider issuing
          acknowledgements after n messages and/or after a particular
          duration has elapsed.</p></li><li class="listitem"><p>Tune the sender capacity (see
          <a class="xref" href="#replay" title="2.5.&#160;Sender Capacity and Replay">Section&#160;2.5, &#8220;Sender Capacity and Replay&#8221;</a>). If the capacity is too low the
          sender may block waiting for the broker to confirm receipt
          of messages, before it can free up more capacity.</p></li><li class="listitem"><p>If you are setting a reply-to address on messages
          being sent by the c++ client, make sure the address type is
          set to either queue or topic as appropriate. This avoids the
          client having to determine which type of node is being
          refered to, which is required when hanling reply-to in AMQP
          0-10. </p></li><li class="listitem"><p>For latency sensitive applications, setting tcp-nodelay
	  on qpidd and on client connections can help reduce the
	  latency.</p></li></ul></div></div><div class="section" title="2.14.&#160;Cluster Failover"><div class="titlepage"><div><div><h2 class="title"><a id="idp32734464" />2.14.&#160;Cluster Failover</h2></div></div></div><p>The messaging broker can be run in clustering mode, which provides high reliability through replicating state between brokers in the cluster. If one broker in a cluster fails, clients can choose another broker in the cluster and continue their work. Each broker in the cluster also advertises the addresses of all known brokers

      <sup>[<a class="footnote" href="#ftn.idp32735712" id="idp32735712">11</a>]</sup>

      . A client can use this information to dynamically keep the list of reconnection urls up to date.</p><p>In C++, the <code class="classname">FailoverUpdates</code> class provides this functionality:</p><div class="example"><a id="idp32737248" /><p class="title"><strong>Example&#160;2.19.&#160;Tracking cluster membership</strong></p><div class="example-contents"><p>In C++:</p><pre class="programlisting">
	#include &lt;qpid/messaging/FailoverUpdates.h&gt;
	...
	Connection connection("localhost:5672");
	connection.setOption("reconnect", true);
	try {
	connection.open();
	std::auto_ptr&lt;FailoverUpdates&gt; updates(new FailoverUpdates(connection));
	
	</pre><p>In python:</p><pre class="programlisting">
	import qpid.messaging.util
	...
	connection = Connection("localhost:5672")
	connection.reconnect = True
	try:
	connection.open()
	auto_fetch_reconnect_urls(connection)
	
	</pre><p>
	  In .NET C#:
	</p><pre class="programlisting">
	  using Org.Apache.Qpid.Messaging;
	  ...
	  connection = new Connection("localhost:5672");
	  connection.SetOption("reconnect", true);
	  try {
	  connection.Open();
	  FailoverUpdates failover = new FailoverUpdates(connection);

	</pre></div></div><br class="example-break" /><div class="footnotes"><br /><hr align="left" width="100" /><div class="footnote"><p><sup>[<a class="para" href="#idp32735712" id="ftn.idp32735712">11</a>] </sup>This is done via the amq.failover exchange in AMQP 0-10</p></div></div></div><div class="section" title="2.15.&#160;Logging"><div class="titlepage"><div><div><h2 class="title"><a id="idp32742752" />2.15.&#160;Logging</h2></div></div></div><p>To simplify debugging, Qpid provides a logging facility
      that prints out messaging events.</p><div class="section" title="2.15.1.&#160;Logging in C++"><div class="titlepage"><div><div><h3 class="title"><a id="idp32743888" />2.15.1.&#160;Logging in C++</h3></div></div></div><p>
	  The Qpidd broker and C++ clients can both use environment variables to enable logging. Linux and Windows systems use the same named environment variables and values.
	</p><p>Use QPID_LOG_ENABLE to set the level of logging you are interested in (trace, debug, info, notice, warning, error, or critical):
	</p><pre class="screen">
	  export QPID_LOG_ENABLE="warning+"
	</pre><p>
	  The Qpidd broker and C++ clients use QPID_LOG_OUTPUT to determine where logging output should be sent. This is either a file name or the special values stderr, stdout, or syslog:
	</p><pre class="screen">
	  export QPID_LOG_TO_FILE="/tmp/myclient.out"
	</pre><p>
	  From a Windows command prompt, use the following command format to set the environment variables:
	</p><pre class="screen">
	  set QPID_LOG_ENABLE=warning+
	  set QPID_LOG_TO_FILE=D:\tmp\myclient.out
	</pre></div><div class="section" title="2.15.2.&#160;Logging in Python"><div class="titlepage"><div><div><h3 class="title"><a id="idp32748896" />2.15.2.&#160;Logging in Python</h3></div></div></div><p>
	  The Python client library supports logging using the standard Python logging module. The easiest way to do logging is to use the <span class="command"><strong>basicConfig()</strong></span>, which reports all warnings and errors:
	</p><pre class="programlisting">from logging import basicConfig
	basicConfig()
	</pre><p>
	  Qpidd also provides a convenience method that makes it easy to specify the level of logging desired. For instance, the following code enables logging at the <span class="command"><strong>DEBUG</strong></span> level:
	</p><pre class="programlisting">from qpid.log import enable, DEBUG
	enable("qpid.messaging.io", DEBUG)
	</pre><p>
	  For more information on Python logging, see <a class="ulink" href="http://docs.python.org/lib/node425.html" target="_top">http://docs.python.org/lib/node425.html</a>. For more information on Qpid logging, use <span class="command"><strong>$ pydoc qpid.log</strong></span>.
	</p></div></div><div class="section" title="2.16.&#160;The AMQP 0-10 mapping"><div class="titlepage"><div><div><h2 class="title"><a id="section-amqp0-10-mapping" />2.16.&#160;The AMQP 0-10 mapping</h2></div></div></div><p>
	This section describes the AMQP 0-10 mapping for the Qpid
	Messaging API.
      </p><p>
        The interaction with the broker triggered by creating a sender
        or receiver depends on what the specified address resolves
        to. Where the node type is not specified in the address, the
        client queries the broker to determine whether it refers to a
        queue or an exchange.
      </p><p>
        When sending to a queue, the queue's name is set as the
        routing key and the message is transfered to the default (or
        nameless) exchange. When sending to an exchange, the message
        is transfered to that exchange and the routing key is set to
        the message subject if one is specified. A default subject may
        be specified in the target address. The subject may also be
        set on each message individually to override the default if
        required. In each case any specified subject is also added as
        a qpid.subject entry in the application-headers field of the
        message-properties.
      </p><p>
        When receiving from a queue, any subject in the source address
        is currently ignored. The client sends a message-subscribe
        request for the queue in question. The accept-mode is
        determined by the reliability option in the link properties;
        for unreliable links the accept-mode is none, for reliable
        links it is explicit. The default for a queue is reliable. The
        acquire-mode is determined by the value of the mode option. If
        the mode is set to browse the acquire mode is not-acquired,
        otherwise it is set to pre-acquired. The exclusive and
        arguments fields in the message-subscribe command can be
        controlled using the x-subscribe map.
      </p><p>
        When receiving from an exchange, the client creates a
        subscription queue and binds that to the exchange. The
        subscription queue's arguments can be specified using the
        x-declare map within the link properties. The reliability
        option determines most of the other parameters. If the
        reliability is set to unreliable then an auto-deleted,
        exclusive queue is used meaning that if the client or
        connection fails messages may be lost. For exactly-once the
        queue is not set to be auto-deleted. The durability of the
        subscription queue is determined by the durable option in the
        link properties. The binding process depends on the type of
        the exchange the source address resolves to.
      </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>
            For a topic exchange, if no subject is specified and no
            x-bindings are defined for the link, the subscription
            queue is bound using a wildcard matching any routing key
            (thus satisfying the expectation that any message sent to
            that address will be received from it). If a subject is
            specified in the source address however, it is used for
            the binding key (this means that the subject in the source
            address may be a binding pattern including wildcards).
          </p></li><li class="listitem"><p>
            For a fanout exchange the binding key is irrelevant to
            matching. A receiver created from a source address that
            resolves to a fanout exchange receives all messages
            sent to that exchange regardless of any subject the source
            address may contain. An x-bindings element in the link
            properties should be used if there is any need to set the
            arguments to the bind.
          </p></li><li class="listitem"><p>
            For a direct exchange, the subject is used as the binding
            key. If no subject is specified an empty string is used as
            the binding key.
          </p></li><li class="listitem"><p>
            For a headers exchange, if no subject is specified the
            binding arguments simply contain an x-match entry and no
            other entries, causing all messages to match. If a subject
            is specified then the binding arguments contain an x-match
            entry set to all and an entry for qpid.subject whose value
            is the subject in the source address (this means the
            subject in the source address must match the message
            subject exactly). For more control the x-bindings element
            in the link properties must be used.
          </p></li><li class="listitem"><p>
            For the XML exchange,<sup>[<a class="footnote" href="#ftn.idp32767008" id="idp32767008">12</a>]</sup> if a subject is specified it is
            used as the binding key and an XQuery is defined that
            matches any message with that value for
            qpid.subject. Again this means that only messages whose
            subject exactly match that specified in the source address
            are received. If no subject is specified then the empty
            string is used as the binding key with an xquery that will
            match any message (this means that only messages with an
            empty string as the routing key will be received). For more
            control the x-bindings element in the link properties must
            be used. A source address that resolves to the XML
            exchange must contain either a subject or an x-bindings
            element in the link properties as there is no way at
            present to receive any message regardless of routing key.
          </p></li></ul></div><p>
        If an x-bindings list is present in the link options a binding
        is created for each element within that list. Each element is
        a nested map that may contain values named queue, exchange,
        key or arguments. If the queue value is absent the queue name
        the address resolves to is implied. If the exchange value is
        absent the exchange name the address resolves to is implied.
      </p><p>The following table shows how Qpid Messaging API message
      properties are mapped to AMQP 0-10 message properties and
      delivery properties. In this table <code class="varname">msg</code>
      refers to the Message class defined in the Qpid Messaging API,
      <code class="varname">mp</code> refers to an AMQP 0-10
      <code class="varname">message-properties</code> struct, and
      <code class="varname">dp</code> refers to an AMQP 0-10
      <code class="varname">delivery-properties</code> struct.</p><div class="table"><a id="table-amqp0-10-message-properties" /><p class="title"><strong>Table&#160;2.9.&#160;Mapping to AMQP 0-10 Message Properties</strong></p><div class="table-contents"><table border="1" summary="Mapping to AMQP 0-10 Message Properties" width="100%"><colgroup><col /><col /><col /></colgroup><thead><tr><th>Python API</th><th>C++ API
	      <sup>[<a class="footnote" href="#ftn.idp32778544" id="idp32778544">a</a>]</sup>
	      </th><th>AMQP 0-10 Property<sup>[<a class="footnote" href="#ftn.idp32780336" id="idp32780336">b</a>]</sup></th></tr></thead><tbody><tr><td>msg.id</td><td>msg.{get,set}MessageId()</td><td>mp.message_id</td></tr><tr><td>msg.subject</td><td>msg.{get,set}Subject()</td><td>mp.application_headers["qpid.subject"]</td></tr><tr><td>msg.user_id</td><td>msg.{get,set}UserId()</td><td>mp.user_id</td></tr><tr><td>msg.reply_to</td><td>msg.{get,set}ReplyTo()</td><td>mp.reply_to<sup>[<a class="footnote" href="#ftn.idp32787472" id="idp32787472">c</a>]</sup></td></tr><tr><td>msg.correlation_id</td><td>msg.{get,set}CorrelationId()</td><td>mp.correlation_id</td></tr><tr><td>msg.durable</td><td>msg.{get,set}Durable()</td><td>dp.delivery_mode == delivery_mode.persistent<sup>[<a class="footnote" href="#ftn.idp32790512" id="idp32790512">d</a>]</sup></td></tr><tr><td>msg.priority</td><td>msg.{get,set}Priority()</td><td>dp.priority</td></tr><tr><td>msg.ttl</td><td>msg.{get,set}Ttl()</td><td>dp.ttl</td></tr><tr><td>msg.redelivered</td><td>msg.{get,set}Redelivered()</td><td>dp.redelivered</td></tr><tr><td>msg.properties</td><td>msg.getProperties()/msg.setProperty()</td><td>mp.application_headers</td></tr><tr><td>msg.content_type</td><td>msg.{get,set}ContentType()</td><td>mp.content_type</td></tr></tbody><tbody class="footnotes"><tr><td colspan="3"><div class="footnote"><p><sup>[<a class="para" href="#idp32778544" id="ftn.idp32778544">a</a>] </sup>
		  The .NET Binding for C++ Messaging provides all the
		  message and delivery properties described in the C++ API.
		  See  <a class="xref" href="#table-Dotnet-Binding-Message" title="Table&#160;5.13.&#160;.NET Binding for the C++ Messaging API Class: Message">Table&#160;5.13, &#8220;.NET Binding for the C++ Messaging API Class: Message&#8221;</a> .
		</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp32780336" id="ftn.idp32780336">b</a>] </sup>In these entries, <code class="literal">mp</code> refers to an AMQP message property, and <code class="literal">dp</code> refers to an AMQP delivery property.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp32787472" id="ftn.idp32787472">c</a>] </sup>The reply_to is converted from the protocol representation into an address.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp32790512" id="ftn.idp32790512">d</a>] </sup>Note that msg.durable is a boolean, not an enum.</p></div></td></tr></tbody></table></div></div><br class="table-break" /><div class="section" title="2.16.1.&#160;0-10 Message Property Keys"><div class="titlepage"><div><div><h3 class="title"><a id="section-amqp0-10-message-props" />2.16.1.&#160;0-10 Message Property Keys</h3></div></div></div><p>
          The QPID Messaging API also recognises special message property keys and
          automatically provides a mapping to their corresponding AMQP 0-10 definitions.
        </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>
              When sending a message, if the properties contain an entry for
              <code class="literal">x-amqp-0-10.app-id</code>, its value will be used to set the
              <code class="literal">message-properties.app-id</code> property in the outgoing
              message.  Likewise, if an incoming message has
              <code class="literal">message-properties.app-id</code> set, its value can be accessed
              via the <code class="literal">x-amqp-0-10.app-id</code> message property key.
            </p></li><li class="listitem"><p>
              When sending a message, if the properties contain an entry for
              <code class="literal">x-amqp-0-10.content-encoding</code>, its value will be used to
              set the <code class="literal">message-properties.content-encoding</code> property in
              the outgoing message.  Likewise, if an incoming message has
              <code class="literal">message-properties.content-encoding</code> set, its value can be
              accessed via the <code class="literal">x-amqp-0-10.content-encoding</code> message
              property key.
            </p></li><li class="listitem"><p>
              The routing key (<code class="literal">delivery-properties.routing-key</code>) in an
              incoming messages can be accessed via the
              <code class="literal">x-amqp-0-10.routing-key</code> message property.
            </p></li><li class="listitem"><p>
              If the timestamp delivery property is set in an incoming message
              (<code class="literal">delivery-properties.timestamp</code>), the timestamp value will
              be made available via the <code class="literal">x-amqp-0-10.timestamp</code> message
              property.
              <sup>[<a class="footnote" href="#ftn.idp32810800" id="idp32810800">13</a>]</sup>
            </p></li></ul></div><div class="example"><a id="idp32812080" /><p class="title"><strong>Example&#160;2.20.&#160;Accessing the AMQP 0-10 Message Timestamp in Python</strong></p><div class="example-contents"><p>
            The following code fragment checks for and extracts the message timestamp from
            a received message.
          </p><pre class="programlisting" lang="python" xml:lang="python">
	    try:
	    msg = receiver.fetch(timeout=1)
	    if "x-amqp-0-10.timestamp" in msg.properties:
	    print("Timestamp=%s" % str(msg.properties["x-amqp-0-10.timestamp"]))
	    except Empty:
	    pass
          </pre></div></div><br class="example-break" /><div class="example"><a id="idp32814464" /><p class="title"><strong>Example&#160;2.21.&#160;Accessing the AMQP 0-10 Message Timestamp in C++</strong></p><div class="example-contents"><p>
            The same example, except in C++.
          </p><pre class="programlisting" lang="c++" xml:lang="c++">
	    messaging::Message msg;
	    if (receiver.fetch(msg, messaging::Duration::SECOND*1)) {
	    if (msg.getProperties().find("x-amqp-0-10.timestamp") != msg.getProperties().end()) {
	    std::cout &lt;&lt; "Timestamp=" &lt;&lt; msg.getProperties()["x-amqp-0-10.timestamp"].asString() &lt;&lt; std::endl;
	    }
	    }
          </pre></div></div><br class="example-break" /></div><div class="footnotes"><br /><hr align="left" width="100" /><div class="footnote"><p><sup>[<a class="para" href="#idp32767008" id="ftn.idp32767008">12</a>] </sup>Note that the XML
            exchange is not a standard AMQP exchange type. It is a
            Qpid extension and is currently only supported by the C++
            broker.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp32810800" id="ftn.idp32810800">13</a>] </sup>
                  This special property is currently not supported by the Qpid JMS client.
                </p></div></div></div><div class="section" title="2.17.&#160;Using Message Groups"><div class="titlepage"><div><div><h2 class="title"><a id="Message-Groups-Guide" />2.17.&#160;Using Message Groups</h2></div></div></div><p>
    This section describes how messaging applications can use the Message Group feature
    provided by the C++ Broker.
  </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;" title="Note"><h3 class="title">Note</h3>
    The content of this section assumes the reader is familiar with the Message Group
    feature as described in the AMQP Messaging Broker (C++) user's guide.  Please read the
    section <span class="emphasis"><em>Using Message Groups</em></span> in the user's guide before using the
    examples given in this section.
  </div><div class="section" title="2.17.1.&#160;Creating Message Group Queues"><div class="titlepage"><div><div><h3 class="title"><a id="messagegroups-setup" />2.17.1.&#160;Creating Message Group Queues</h3></div></div></div><p>
      The following examples show how to create a message group queue that enforces
      ordered group consumption across multiple consumers.
    </p><div class="example"><a id="idp32523728" /><p class="title"><strong>Example&#160;2.22.&#160;Message Group Queue Creation - Python</strong></p><div class="example-contents"><pre class="programlisting" lang="python" xml:lang="python">
sender = connection.session().sender("msg-group-q;" +
                                     " {create:always, delete:receiver," +
                                     " node: {x-declare: {arguments:" +
                                     " {'qpid.group_header_key':'THE-GROUP'," +
                                     " 'qpid.shared_msg_group':1}}}}")
      </pre></div></div><br class="example-break" /><div class="example"><a id="idp32525536" /><p class="title"><strong>Example&#160;2.23.&#160;Message Group Queue Creation - C++</strong></p><div class="example-contents"><pre class="programlisting" lang="c++" xml:lang="c++">
std::string addr("msg-group-q; "
                 " {create:always, delete:receiver,"
                 " node: {x-declare: {arguments:"
                 " {qpid.group_header_key:'THE-GROUP',"
                 " qpid.shared_msg_group:1}}}}");
Sender sender = session.createSender(addr);
      </pre></div></div><br class="example-break" /><div class="example"><a id="idp32527376" /><p class="title"><strong>Example&#160;2.24.&#160;Message Group Queue Creation - Java</strong></p><div class="example-contents"><pre class="programlisting" lang="java" xml:lang="java">
Session s = c.createSession(false, Session.CLIENT_ACKNOWLEDGE);
String addr = "msg-group-q; {create:always, delete:receiver," +
                             " node: {x-declare: {arguments:" +
                             " {'qpid.group_header_key':'THE-GROUP'," +
                             " 'qpid.shared_msg_group':1}}}}";
Destination d = (Destination) new AMQAnyDestination(addr);
MessageProducer sender = s.createProducer(d);
      </pre></div></div><br class="example-break" /><p>
      The example code uses the x-declare map to specify the message group configuration
      that should be used for the queue.  See the AMQP Messaging Broker (C++) user's guide
      for a detailed description of these arguments.  Note that the
      qpid.group_header_key's value MUST be a string type.
    </p></div><div class="section" title="2.17.2.&#160;Sending Grouped Messages"><div class="titlepage"><div><div><h3 class="title"><a id="messagegroups-sending" />2.17.2.&#160;Sending Grouped Messages</h3></div></div></div><p>
      When sending grouped messages, the client must add a message property containing the
      group identifier to the outgoing message.  The group identifier must be a string
      type.  The key used for the property must exactly match the value passed in the
      'qpid.group_header_key' configuration argument.
    </p><div class="example"><a id="idp26745120" /><p class="title"><strong>Example&#160;2.25.&#160;Sending Grouped Messages - Python</strong></p><div class="example-contents"><pre class="programlisting" lang="python" xml:lang="python">
group = "A"
m = Message(content="some data", properties={"THE-GROUP": group})
sender.send(m)

group = "B"
m = Message(content="some other group's data", properties={"THE-GROUP": group})
sender.send(m)

group = "A"
m = Message(content="more data for group 'A'", properties={"THE-GROUP": group})
sender.send(m)
      </pre></div></div><br class="example-break" /><div class="example"><a id="idp26747056" /><p class="title"><strong>Example&#160;2.26.&#160;Sending Grouped Messages - C++</strong></p><div class="example-contents"><pre class="programlisting" lang="C++" xml:lang="C++">

const std::string groupKey("THE-GROUP");
{
    Message msg("some data");
    msg.getProperties()[groupKey] = std::string("A");
    sender.send(msg);
}
{
    Message msg("some other group's data");
    msg.getProperties()[groupKey] = std::string("B");
    sender.send(msg);
}
{
    Message msg("more data for group 'A'");
    msg.getProperties()[groupKey] = std::string("A");
    sender.send(msg);
}
      </pre></div></div><br class="example-break" /><div class="example"><a id="idp26749072" /><p class="title"><strong>Example&#160;2.27.&#160;Sending Grouped Messages - Java</strong></p><div class="example-contents"><pre class="programlisting" lang="java" xml:lang="java">
String groupKey = "THE-GROUP";

TextMessage tmsg1 = s.createTextMessage("some data");
tmsg1.setStringProperty(groupKey, "A");
sender.send(tmsg1);

TextMessage tmsg2 = s.createTextMessage("some other group's data");
tmsg2.setStringProperty(groupKey, "B");
sender.send(tmsg2);

TextMessage tmsg3 = s.createTextMessage("more data for group 'A'");
tmsg3.setStringProperty(groupKey, "A");
sender.send(tmsg3);
      </pre></div></div><br class="example-break" /><p>
      The examples above send two groups worth of messages to the queue created in the
      previous example.  Two messages belong to group "A", and one belongs to group
      "B". Note that it is not necessary to complete sending one group's messages before
      starting another.  Also note that there is no need to indicate to the broker when a
      new group is created or an existing group retired - the broker tracks group state
      automatically.
    </p></div><div class="section" title="2.17.3.&#160;Receiving Grouped Messages"><div class="titlepage"><div><div><h3 class="title"><a id="messagegroups-receiving" />2.17.3.&#160;Receiving Grouped Messages</h3></div></div></div><p>
      Since the broker enforces group policy when delivering messages, no special actions
      are necessary for receiving grouped messages from the broker.  However, applications
      must adhere to the rules for message group consumption as described in the AMQP
      Messaging Broker (C++) user's guide.  Refer to the section <span class="emphasis"><em>Well Behaved
      Consumers</em></span> for details.
    </p></div></div></div><div class="chapter" title="Chapter&#160;3.&#160;Using the Qpid JMS client"><div class="titlepage"><div><div><h2 class="title"><a id="QpidJMS" />Chapter&#160;3.&#160;Using the Qpid JMS client</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="section"><a href="#idp32819040">3.1. A Simple Messaging Program in Java JMS</a></span></dt><dt><span class="section"><a href="#QpidJNDI">3.2. Apache Qpid JNDI Properties for AMQP Messaging</a></span></dt><dd><dl><dt><span class="section"><a href="#idp32861648">3.2.1. JNDI Properties for Apache Qpid</a></span></dt><dt><span class="section"><a href="#section-jms-connection-url">3.2.2. Connection URLs</a></span></dt></dl></dd><dt><span class="section"><a href="#idp32950944">3.3. Java JMS Message Properties</a></span></dt><dt><span class="section"><a href="#section-JMS-MapMessage">3.4. JMS MapMessage Types</a></span></dt><dt><span class="section"><a href="#section-JMS-Logging">3.5. JMS Client Logging</a></span></dt><dt><span class="section"><a href="#idp32999424">3.6. Configuring the JMS Client</a></span></dt><dd><dl><dt><span class="section"><a href="#client-jvm-properties">3.6.1. Qpid JVM Arguments</a></span></dt></dl></dd></dl></div><div class="section" title="3.1.&#160;A Simple Messaging Program in Java JMS"><div class="titlepage"><div><div><h2 class="title"><a id="idp32819040" />3.1.&#160;A Simple Messaging Program in Java JMS</h2></div></div></div><p>The following program shows how to send and receive a
      message using the Qpid JMS client. JMS programs typically use
      JNDI to obtain connection factory and destination objects which
      the application needs. In this way the configuration is kept
      separate from the application code itself.</p><p>In this example, we create a JNDI context using a
      properties file, use the context to lookup a connection factory,
      create and start a connection, create a session, and lookup a
      destination from the JNDI context. Then we create a producer and
      a consumer, send a message with the producer and receive it with
      the consumer. This code should be straightforward for anyone
      familiar with Java JMS.</p><div class="example"><a id="idp32821216" /><p class="title"><strong>Example&#160;3.1.&#160;"Hello world!" in Java</strong></p><div class="example-contents"><pre class="programlisting" lang="java" xml:lang="java">
	  package org.apache.qpid.example.jmsexample.hello;

	  import javax.jms.*;
	  import javax.naming.Context;
	  import javax.naming.InitialContext;
	  import java.util.Properties;

	  public class Hello {

	  public Hello() {
	  }

	  public static void main(String[] args) {
	  Hello producer = new Hello();
	  producer.runTest();
	  }

	  private void runTest() {
	  try {
	  Properties properties = new Properties();
	  properties.load(this.getClass().getResourceAsStream("hello.properties"));  <a class="co" href="#callout-java-properties" id="hello-java-properties">(1)</a>
	  Context context = new InitialContext(properties);   <a class="co" href="#callout-java-context" id="hello-java-context">(2)</a>

	  ConnectionFactory connectionFactory
          = (ConnectionFactory) context.lookup("qpidConnectionfactory"); <a class="co" href="#callout-java-connection-factory" id="hello-java-connection-factory">(3)</a>
	  Connection connection = connectionFactory.createConnection();  <a class="co" href="#callout-java-connection" id="hello-java-connection">(4)</a>
	  connection.start();  <a class="co" href="#callout-java-start" id="hello-java-start">(5)</a>

	  Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);<a class="co" href="#callout-java-session" id="hello-java-session">(6)</a>
	  Destination destination = (Destination) context.lookup("topicExchange");  <a class="co" href="#callout-java-destination" id="hello-java-destination">(7)</a>

	  MessageProducer messageProducer = session.createProducer(destination);  <a class="co" href="#callout-java-producer" id="hello-java-producer">(8)</a>
	  MessageConsumer messageConsumer = session.createConsumer(destination);  <a class="co" href="#callout-java-consumer" id="hello-java-consumer">(9)</a>

	  TextMessage message = session.createTextMessage("Hello world!");
	  messageProducer.send(message);

	  message = (TextMessage)messageConsumer.receive();    <a class="co" href="#callout-java-receive" id="hello-java-receive">(10)</a>
	  System.out.println(message.getText());

	  connection.close();  <a class="co" href="#callout-java-close" id="hello-java-close">(11)</a>
	  context.close();   <a class="co" href="#callout-java-jndi-close" id="hello-java-jndi-close">(12)</a>
	  }
	  catch (Exception exp) {
	  exp.printStackTrace();
	  }
	  }
	  }
	</pre></div></div><br class="example-break" /><div class="calloutlist"><table border="0" summary="Callout list"><tr><td align="left" valign="top" width="5%"><p><a id="callout-java-properties" /><a href="#hello-java-properties">(1)</a> </p></td><td align="left" valign="top"><p>Loads the JNDI properties file, which specifies connection properties, queues, topics, and addressing options. See <a class="xref" href="#QpidJNDI" title="3.2.&#160;Apache Qpid JNDI Properties for AMQP Messaging">Section&#160;3.2, &#8220;Apache Qpid JNDI Properties for AMQP Messaging&#8221;</a> for details.</p></td></tr><tr><td align="left" valign="top" width="5%"><p><a id="callout-java-context" /><a href="#hello-java-context">(2)</a> </p></td><td align="left" valign="top"><p>Creates the JNDI initial context.</p></td></tr><tr><td align="left" valign="top" width="5%"><p><a id="callout-java-connection-factory" /><a href="#hello-java-connection-factory">(3)</a> </p></td><td align="left" valign="top"><p>Creates a JMS connection factory for Qpid.</p></td></tr><tr><td align="left" valign="top" width="5%"><p><a id="callout-java-connection" /><a href="#hello-java-connection">(4)</a> </p></td><td align="left" valign="top"><p>Creates a JMS connection.</p></td></tr><tr><td align="left" valign="top" width="5%"><p><a id="callout-java-start" /><a href="#hello-java-start">(5)</a> </p></td><td align="left" valign="top"><p>Activates the connection.</p></td></tr><tr><td align="left" valign="top" width="5%"><p><a id="callout-java-session" /><a href="#hello-java-session">(6)</a> </p></td><td align="left" valign="top"><p>Creates a session. This session is not transactional (transactions='false'), and messages are automatically acknowledged.</p></td></tr><tr><td align="left" valign="top" width="5%"><p><a id="callout-java-destination" /><a href="#hello-java-destination">(7)</a> </p></td><td align="left" valign="top"><p>Creates a destination for the topic exchange, so senders and receivers can use it.</p></td></tr><tr><td align="left" valign="top" width="5%"><p><a id="callout-java-producer" /><a href="#hello-java-producer">(8)</a> </p></td><td align="left" valign="top"><p>Creates a producer that sends messages to the topic exchange.</p></td></tr><tr><td align="left" valign="top" width="5%"><p><a id="callout-java-consumer" /><a href="#hello-java-consumer">(9)</a> </p></td><td align="left" valign="top"><p>Creates a consumer that reads messages from the topic exchange.</p></td></tr><tr><td align="left" valign="top" width="5%"><p><a id="callout-java-receive" /><a href="#hello-java-receive">(10)</a> </p></td><td align="left" valign="top"><p>Reads the next available message.</p></td></tr><tr><td align="left" valign="top" width="5%"><p><a id="callout-java-close" /><a href="#hello-java-close">(11)</a> </p></td><td align="left" valign="top"><p>Closes the connection, all sessions managed by the connection, and all senders and receivers managed by each session.</p></td></tr><tr><td align="left" valign="top" width="5%"><p><a id="callout-java-jndi-close" /><a href="#hello-java-jndi-close">(12)</a> </p></td><td align="left" valign="top"><p>Closes the JNDI context.</p></td></tr></table></div><p>The contents of the hello.properties file are shown below.</p><div class="example"><a id="idp32850192" /><p class="title"><strong>Example&#160;3.2.&#160;JNDI Properties File for "Hello world!" example</strong></p><div class="example-contents"><pre class="programlisting">
	  java.naming.factory.initial
	  = org.apache.qpid.jndi.PropertiesFileInitialContextFactory

	  # connectionfactory.[jndiname] = [ConnectionURL]
	  connectionfactory.qpidConnectionfactory
	  = amqp://guest:guest@clientid/test?brokerlist='tcp://localhost:5672' <a class="co" href="#callout-hello-properties-connectionfactory" id="hello-properties-connectionfactory">(1)</a>
	  # destination.[jndiname] = [address_string]
	  destination.topicExchange = amq.topic <a class="co" href="#callout-hello-properties-destination" id="hello-properties-destination">(2)</a>
	</pre></div></div><br class="example-break" /><div class="calloutlist"><table border="0" summary="Callout list"><tr><td align="left" valign="top" width="5%"><p><a id="callout-hello-properties-connectionfactory" /><a href="#hello-properties-connectionfactory">(1)</a> </p></td><td align="left" valign="top"><p>Defines a connection factory from which connections
	  can be created. The syntax of a ConnectionURL is given in
	  <a class="xref" href="#QpidJNDI" title="3.2.&#160;Apache Qpid JNDI Properties for AMQP Messaging">Section&#160;3.2, &#8220;Apache Qpid JNDI Properties for AMQP Messaging&#8221;</a>.</p></td></tr><tr><td align="left" valign="top" width="5%"><p><a id="callout-hello-properties-destination" /><a href="#hello-properties-destination">(2)</a> </p></td><td align="left" valign="top"><p>Defines a destination for which MessageProducers
	  and/or MessageConsumers can be created to send and receive
	  messages. The value for the destination in the properties
	  file is an address string as described in
	  <a class="xref" href="#section-addresses" title="2.4.&#160;Addresses">Section&#160;2.4, &#8220;Addresses&#8221;</a>. In the JMS
	  implementation MessageProducers are analogous to senders in
	  the Qpid Message API, and MessageConsumers are analogous to
	  receivers.</p></td></tr></table></div></div><div class="section" title="3.2.&#160;Apache Qpid JNDI Properties for AMQP Messaging"><div class="titlepage"><div><div><h2 class="title"><a id="QpidJNDI" />3.2.&#160;Apache Qpid JNDI Properties for AMQP Messaging</h2></div></div></div><p>
	Apache Qpid defines JNDI properties that can be used to specify JMS Connections and Destinations. Here is a typical JNDI properties file:
      </p><div class="example"><a id="idp32859408" /><p class="title"><strong>Example&#160;3.3.&#160;JNDI Properties File</strong></p><div class="example-contents"><pre class="programlisting">
	java.naming.factory.initial
	= org.apache.qpid.jndi.PropertiesFileInitialContextFactory

	# connectionfactory.[jndiname] = [ConnectionURL]
	connectionfactory.qpidConnectionfactory
	= amqp://guest:guest@clientid/test?brokerlist='tcp://localhost:5672'
	# destination.[jndiname] = [address_string]
	destination.topicExchange = amq.topic
	</pre></div></div><br class="example-break" /><p>The following sections describe the JNDI properties that Qpid uses.</p><div class="section" title="3.2.1.&#160;JNDI Properties for Apache Qpid"><div class="titlepage"><div><div><h3 class="title"><a id="idp32861648" />3.2.1.&#160;JNDI Properties for Apache Qpid</h3></div></div></div><p>
	  Apache Qpid supports the properties shown in the following table:
        </p><div class="table"><a id="idp32862768" /><p class="title"><strong>Table&#160;3.1.&#160;JNDI Properties supported by Apache Qpid</strong></p><div class="table-contents"><table border="1" summary="JNDI Properties supported by Apache Qpid"><colgroup><col /><col /></colgroup><thead><tr><th>
		  Property
	        </th><th>
		  Purpose
	        </th></tr></thead><tbody><tr><td>
		  connectionfactory.&lt;jndiname&gt;
	        </td><td>
		  <p>
		    The Connection URL that the connection factory uses to perform connections.
		  </p>
	        </td></tr><tr><td>
		  queue.&lt;jndiname&gt;
	        </td><td>
		  <p>
		    A JMS queue, which is implemented as an amq.direct exchange in Apache Qpid.
		  </p>
	        </td></tr><tr><td>
		  topic.&lt;jndiname&gt;
	        </td><td>
		  <p>
		    A JMS topic, which is implemented as an amq.topic exchange in Apache Qpid.
		  </p>
	        </td></tr><tr><td>
		  destination.&lt;jndiname&gt;
	        </td><td>
		  <p>
		    Can be used for defining all amq destinations,
		    queues, topics and header matching, using an
		    address string.

		    <sup>[<a class="footnote" href="#ftn.idp32872048" id="idp32872048">a</a>]</sup>
		  </p>
	        </td></tr></tbody><tbody class="footnotes"><tr><td colspan="2"><div class="footnote"><p><sup>[<a class="para" href="#idp32872048" id="ftn.idp32872048">a</a>] </sup>Binding URLs, which were used in
		    earlier versions of the Qpid Java JMS client, can
		    still be used instead of address
		    strings.</p></div></td></tr></tbody></table></div></div><br class="table-break" /></div><div class="section" title="3.2.2.&#160;Connection URLs"><div class="titlepage"><div><div><h3 class="title"><a id="section-jms-connection-url" />3.2.2.&#160;Connection URLs</h3></div></div></div><p>
	  In JNDI properties, a Connection URL specifies properties for a connection. The format for a Connection URL is:
        </p><pre class="programlisting">amqp://[&lt;user&gt;:&lt;pass&gt;@][&lt;clientid&gt;]&lt;virtualhost&gt;[?&lt;option&gt;='&lt;value&gt;'[&amp;&lt;option&gt;='&lt;value&gt;']]
        </pre><p>
	  For instance, the following Connection URL specifies a user name, a password, a client ID, a virtual host ("test"), a broker list with a single broker, and a TCP host with the host name <span class="quote">&#8220;<span class="quote">localhost</span>&#8221;</span> using port 5672:
        </p><pre class="programlisting">amqp://username:password@clientid/test?brokerlist='tcp://localhost:5672'
        </pre><p>
	  Apache Qpid supports the following properties in Connection URLs:
        </p><div class="table"><a id="idp32878080" /><p class="title"><strong>Table&#160;3.2.&#160;Connection URL Properties</strong></p><div class="table-contents"><table border="1" summary="Connection URL Properties" width="100%"><colgroup><col /><col /><col /></colgroup><thead><tr><th>
		  Option
	        </th><th>
		  Type
	        </th><th>
		  Description
	        </th></tr></thead><tbody><tr><td>
		  brokerlist
	        </td><td>
		  see below
	        </td><td>
		  List of one or more broker addresses.
	        </td></tr><tr><td>
		  maxprefetch
	        </td><td>
		  integer
	        </td><td>
		  <p>
                    The maximum number of pre-fetched messages per consumer. If not specified, default value of 500 is used.
		  </p>
		  <p>
                    Note: You can also set the default per-consumer prefetch value on a client-wide basis by configuring the client using <a class="link" href="#client-jvm-properties" title="3.6.1.&#160;Qpid JVM Arguments">Java system properties.</a>
		  </p>
	        </td></tr><tr><td>
		  sync_publish
	        </td><td>
		  {'persistent' | 'all'}
	        </td><td>
		  A sync command is sent after every persistent message to guarantee that it has been received; if the value is 'persistent', this is done only for persistent messages.
	        </td></tr><tr><td>
		  sync_ack
	        </td><td>
		  Boolean
	        </td><td>
		  A sync command is sent after every acknowledgement to guarantee that it has been received.
	        </td></tr><tr><td>
		  use_legacy_map_msg_format
	        </td><td>
		  Boolean
	        </td><td>
		  If you are using JMS Map messages and deploying a new client with any JMS client older than 0.8 release, you must set this to true to ensure the older clients can understand the map message encoding.
	        </td></tr><tr><td>
		  failover
	        </td><td>
		  {'singlebroker' | 'roundrobin' | 'failover_exchange' | 'nofailover' | '&lt;class&gt;'}
	        </td><td>
		  <p>
		    This option controls failover behaviour.  The method <code class="literal">singlebroker</code> uses only the first broker in the list,
		    <code class="literal">roundrobin</code> will try each broker given in the broker list until a connection is established,
		    <code class="literal">failover_exchange</code> connects to the initial broker given in the broker URL and will receive membership updates
		    via the failover exchange. <code class="literal">nofailover</code> disables all retry and failover logic.  Any other value is interpreted as a
		    classname which must implement the <code class="literal">org.apache.qpid.jms.failover.FailoverMethod</code> interface.
		  </p>
		  <p>
		    The broker list options <code class="literal">retries</code> and <code class="literal">connectdelay</code> (described below) determine the number of times a
		    connection to a broker will be retried and the the length of time to wait between successive connection attempts before moving on to
		    the next broker in the list. The failover option <code class="literal">cyclecount</code> controls the number of times to loop through the list of
		    available brokers before finally giving up.
		  </p>
		  <p>
		    Defaults to <code class="literal">roundrobin</code> if the brokerlist contains multiple brokers, or <code class="literal">singlebroker</code> otherwise.
		  </p>
	        </td></tr><tr><td>
		        ssl
	        </td><td>
		        boolean
	        </td><td>
	            <p>
	                If <code class="literal">ssl='true'</code>, use SSL for all broker connections. Overrides any per-broker settings in the brokerlist (see below) entries. If not specified, the brokerlist entry for each given broker is used to determine whether SSL is used.
	            </p>
	            <p>
	                Introduced in version 0.22.
	            </p>
	        </td></tr></tbody></table></div></div><br class="table-break" /><p>
	  Broker lists are specified using a URL in this format:
        </p><pre class="programlisting">brokerlist=&lt;transport&gt;://&lt;host&gt;[:&lt;port&gt;](?&lt;param&gt;='&lt;value&gt;')(&amp;&lt;param&gt;='&lt;value&gt;')*</pre><p>
	  For instance, this is a typical broker list:
        </p><pre class="programlisting">brokerlist='tcp://localhost:5672'
        </pre><p>
	  A broker list can contain more than one broker address; if so, the connection is made to the first broker in the list that is available. In general, it is better to use the failover exchange when using multiple brokers, since it allows applications to fail over if a broker goes down.
	</p><div class="example"><a id="idp32908256" /><p class="title"><strong>Example&#160;3.4.&#160;Broker Lists</strong></p><div class="example-contents"><p>A broker list can specify properties to be used when connecting to the broker, such as security options. This broker list specifies options for a Kerberos connection using GSSAPI:</p><pre class="programlisting">
	  amqp://guest:guest@test/test?sync_ack='true'
	  &amp;brokerlist='tcp://ip1:5672?sasl_mechs='GSSAPI''
	  </pre><p>This broker list specifies SSL options:</p><pre class="programlisting">
	  amqp://guest:guest@test/test?sync_ack='true'
	  &amp;brokerlist='tcp://ip1:5672?ssl='true'&amp;ssl_cert_alias='cert1''
	  </pre><p>
	    This broker list specifies two brokers using the connectdelay and retries broker options. It also illustrates the failover connection URL
	    property.
	  </p><pre class="programlisting">

	  amqp://guest:guest@/test?failover='roundrobin?cyclecount='2''
	  &amp;brokerlist='tcp://ip1:5672?retries='5'&amp;connectdelay='2000';tcp://ip2:5672?retries='5'&amp;connectdelay='2000''
	  </pre></div></div><br class="example-break" /><p>The following broker list options are supported.</p><div class="table"><a id="idp32913488" /><p class="title"><strong>Table&#160;3.3.&#160;Broker List Options</strong></p><div class="table-contents"><table border="1" summary="Broker List Options" width="100%"><colgroup><col /><col /><col /></colgroup><thead><tr><th>
		  Option
	        </th><th>
		  Type
	        </th><th>
		  Description
	        </th></tr></thead><tbody><tr><td>
		  heartbeat
	        </td><td>
		  integer
	        </td><td>
		  frequency of heartbeat messages (in seconds)
	        </td></tr><tr><td>
		  sasl_mechs
	        </td><td>
		  --
	        </td><td>
		  For secure applications, we suggest CRAM-MD5,
		  DIGEST-MD5, or GSSAPI. The ANONYMOUS method is not
		  secure. The PLAIN method is secure only when used
		  together with SSL. For Kerberos, sasl_mechs must be
		  set to GSSAPI, sasl_protocol must be set to the
		  principal for the qpidd broker, e.g. qpidd/, and
		  sasl_server must be set to the host for the SASL
		  server, e.g. sasl.com.  SASL External is supported
		  using SSL certification, e.g.
		  <code class="literal">ssl='true'&amp;sasl_mechs='EXTERNAL'</code>
	        </td></tr><tr><td>
		  sasl_encryption
	        </td><td>
		  Boolean
	        </td><td>
		  If <code class="literal">sasl_encryption='true'</code>, the JMS client attempts to negotiate a security layer with the broker using GSSAPI to encrypt the connection. Note that for this to happen, GSSAPI must be selected as the sasl_mech.
	        </td></tr><tr><td>
		  sasl_protocol
	        </td><td>
		  --
	        </td><td>
		  Used only for
		  Kerberos. <code class="literal">sasl_protocol</code> must be
		  set to the principal for the qpidd broker,
		  e.g. <code class="literal">qpidd/</code>
	        </td></tr><tr><td>
		  sasl_server
	        </td><td>
		  --
	        </td><td>
		  For Kerberos, sasl_mechs must be set to GSSAPI,
		  sasl_server must be set to the host for the SASL
		  server, e.g. <code class="literal">sasl.com</code>.
	        </td></tr><tr><td>
		  trust_store
	        </td><td>
		  --
	        </td><td>
		  path to trust store
	        </td></tr><tr><td>
		  trust_store_password
	        </td><td>
		        --
	        </td><td>
		  Trust store password
	        </td></tr><tr><td>
		  key_store
	        </td><td>
		        --
	        </td><td>
		  path to key store
	        </td></tr><tr><td>
		  key_store_password
	        </td><td>
		  --
	        </td><td>
		  key store password
	        </td></tr><tr><td>
		  ssl
	        </td><td>
		  Boolean
	        </td><td>
	            <p>If <code class="literal">ssl='true'</code>, the JMS client will encrypt the connection to this broker using SSL.</p>

	            <p>This can also be set/overridden for all brokers using the <a class="link" href="#section-jms-connection-url" title="3.2.2.&#160;Connection URLs">Connection URL</a> options.</p>
	        </td></tr><tr><td>
		  ssl_verify_hostname
	        </td><td>
		  Boolean
	        </td><td>
		  When using SSL you can enable hostname verification
		  by using <code class="literal">ssl_verify_hostname='true'</code> in the broker
		  URL.
	        </td></tr><tr><td>
		  ssl_cert_alias
	        </td><td>
		        --
	        </td><td>
		  If multiple certificates are present in the keystore, the alias will be used to extract the correct certificate.
	        </td></tr><tr><td>
		  retries
	        </td><td>
		  integer
	        </td><td>
		  The number of times to retry connection to each broker in the broker list. Defaults to 1.
	        </td></tr><tr><td>
		  connectdelay
	        </td><td>
		  integer
	        </td><td>
		  Length of time (in milliseconds) to wait before attempting to reconnect. Defaults to 0.
	        </td></tr><tr><td>
		  connecttimeout
	        </td><td>
		  integer
	        </td><td>
		  Length of time (in milliseconds) to wait for the socket connection to succeed. A value of 0 represents an infinite timeout, i.e. the connection attempt will block until established or an error occurs.  Defaults to 30000.
	        </td></tr><tr><td>
		  tcp_nodelay
	        </td><td>
		  Boolean
	        </td><td>
		  If <code class="literal">tcp_nodelay='true'</code>, TCP packet
		  batching is disabled. Defaults to true since Qpid 0.14.
	        </td></tr></tbody></table></div></div><br class="table-break" /></div></div><div class="section" title="3.3.&#160;Java JMS Message Properties"><div class="titlepage"><div><div><h2 class="title"><a id="idp32950944" />3.3.&#160;Java JMS Message Properties</h2></div></div></div><p>The following table shows how Qpid Messaging API message
      properties are mapped to AMQP 0-10 message properties and
      delivery properties. In this table <code class="varname">msg</code>
      refers to the Message class defined in the Qpid Messaging API,
      <code class="varname">mp</code> refers to an AMQP 0-10
      <code class="varname">message-properties</code> struct, and
      <code class="varname">dp</code> refers to an AMQP 0-10
      <code class="varname">delivery-properties</code> struct.</p><div class="table"><a id="idp32954160" /><p class="title"><strong>Table&#160;3.4.&#160;Java JMS Mapping to AMQP 0-10 Message Properties</strong></p><div class="table-contents"><table border="1" summary="Java JMS Mapping to AMQP 0-10 Message Properties"><colgroup><col /><col /></colgroup><thead><tr><th>Java JMS Message Property</th><th>AMQP 0-10 Property<sup>[<a class="footnote" href="#ftn.idp32956448" id="idp32956448">a</a>]</sup></th></tr></thead><tbody><tr><td>JMSMessageID</td><td>mp.message_id</td></tr><tr><td>qpid.subject<sup>[<a class="footnote" href="#ftn.idp32960256" id="idp32960256">b</a>]</sup></td><td>mp.application_headers["qpid.subject"]</td></tr><tr><td>JMSXUserID</td><td>mp.user_id</td></tr><tr><td>JMSReplyTo</td><td>mp.reply_to<sup>[<a class="footnote" href="#ftn.idp32963040" id="idp32963040">c</a>]</sup></td></tr><tr><td>JMSCorrelationID</td><td>mp.correlation_id</td></tr><tr><td>JMSDeliveryMode</td><td>dp.delivery_mode</td></tr><tr><td>JMSPriority</td><td>dp.priority</td></tr><tr><td>JMSExpiration</td><td>dp.ttl<sup>[<a class="footnote" href="#ftn.idp32967616" id="idp32967616">d</a>]</sup></td></tr><tr><td>JMSRedelivered</td><td>dp.redelivered</td></tr><tr><td>JMS Properties</td><td>mp.application_headers</td></tr><tr><td>JMSType</td><td>mp.content_type</td></tr></tbody><tbody class="footnotes"><tr><td colspan="2"><div class="footnote"><p><sup>[<a class="para" href="#idp32956448" id="ftn.idp32956448">a</a>] </sup>In these entries, <code class="literal">mp</code> refers to an AMQP message property, and <code class="literal">dp</code> refers to an AMQP delivery property.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp32960256" id="ftn.idp32960256">b</a>] </sup>This is a custom JMS property, set automatically by the Java JMS client implementation.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp32963040" id="ftn.idp32963040">c</a>] </sup>The reply_to is converted from the protocol representation into an address.</p></div><div class="footnote"><p><sup>[<a class="para" href="#idp32967616" id="ftn.idp32967616">d</a>] </sup>JMSExpiration = dp.ttl + currentTime</p></div></td></tr></tbody></table></div></div><br class="table-break" /></div><div class="section" title="3.4.&#160;JMS MapMessage Types"><div class="titlepage"><div><div><h2 class="title"><a id="section-JMS-MapMessage" />3.4.&#160;JMS MapMessage Types</h2></div></div></div><p>Qpid supports the Java JMS <code class="classname">MapMessage</code> interface, which provides support for maps in messages. The following code shows how to send a <code class="classname">MapMessage</code> in Java JMS.</p><div class="example"><a id="idp32973984" /><p class="title"><strong>Example&#160;3.5.&#160;Sending a Java JMS MapMessage</strong></p><div class="example-contents"><pre class="programlisting">
	import java.util.ArrayList;
	import java.util.HashMap;
	import java.util.List;
	import java.util.Map;

	import javax.jms.Connection;
	import javax.jms.Destination;
	import javax.jms.MapMessage;
	import javax.jms.MessageProducer;
	import javax.jms.Session;

	import java.util.Arrays;

	// !!! SNIP !!!

	MessageProducer producer = session.createProducer(queue);

	MapMessage m = session.createMapMessage();
	m.setIntProperty("Id", 987654321);
	m.setStringProperty("name", "Widget");
	m.setDoubleProperty("price", 0.99);

	List&lt;String&gt; colors = new ArrayList&lt;String&gt;();
	colors.add("red");
	colors.add("green");
	colors.add("white");
	m.setObject("colours", colors);

	Map&lt;String,Double&gt; dimensions = new HashMap&lt;String,Double&gt;();
	dimensions.put("length",10.2);
	dimensions.put("width",5.1);
	dimensions.put("depth",2.0);
	m.setObject("dimensions",dimensions);

	List&lt;List&lt;Integer&gt;&gt; parts = new ArrayList&lt;List&lt;Integer&gt;&gt;();
	parts.add(Arrays.asList(new Integer[] {1,2,5}));
	parts.add(Arrays.asList(new Integer[] {8,2,5}));
	m.setObject("parts", parts);

	Map&lt;String,Object&gt; specs = new HashMap&lt;String,Object&gt;();
	specs.put("colours", colors);
	specs.put("dimensions", dimensions);
	specs.put("parts", parts);
	m.setObject("specs",specs);

	producer.send(m);
	</pre></div></div><br class="example-break" /><p>The following table shows the datatypes that can be sent in a <code class="classname">MapMessage</code>, and the corresponding datatypes that will be received by clients in Python or C++.</p><div class="table"><a id="table-Java-Maps" /><p class="title"><strong>Table&#160;3.5.&#160;Java Datatypes in Maps</strong></p><div class="table-contents"><table border="1" summary="Java Datatypes in Maps"><colgroup><col /><col /><col /></colgroup><thead><tr><th>Java Datatype</th><th>&#8594; Python</th><th>&#8594; C++</th></tr></thead><tbody><tr><td>boolean</td><td>bool</td><td>bool</td></tr><tr><td>short</td><td>int | long</td><td>int16</td></tr><tr><td>int</td><td>int | long</td><td>int32</td></tr><tr><td>long</td><td>int | long</td><td>int64</td></tr><tr><td>float</td><td>float</td><td>float</td></tr><tr><td>double</td><td>float</td><td>double</td></tr><tr><td>java.lang.String</td><td>unicode</td><td>std::string</td></tr><tr><td>java.util.UUID</td><td>uuid</td><td>qpid::types::Uuid</td></tr><tr><td>java.util.Map<sup>[<a class="footnote" href="#ftn.idp32989776" id="idp32989776">a</a>]</sup></td><td>dict</td><td>Variant::Map</td></tr><tr><td>java.util.List</td><td>list</td><td>Variant::List</td></tr></tbody><tbody class="footnotes"><tr><td colspan="3"><div class="footnote"><p><sup>[<a class="para" href="#idp32989776" id="ftn.idp32989776">a</a>] </sup>In Qpid, maps can nest. This goes beyond the functionality required by the JMS specification.</p></div></td></tr></tbody></table></div></div><br class="table-break" /></div><div class="section" title="3.5.&#160;JMS Client Logging"><div class="titlepage"><div><div><h2 class="title"><a id="section-JMS-Logging" />3.5.&#160;JMS Client Logging</h2></div></div></div><p>The JMS Client logging is handled using the Simple Logging Facade for Java (<a class="ulink" href="http://www.slf4j.org/" target="_top">SLF4J</a>). As the name implies, slf4j is a facade that delegates to other logging systems like log4j or JDK 1.4 logging. For more information on how to configure slf4j for specific logging systems, please consult the slf4j documentation.</p><p>When using the log4j binding, please set the log level for org.apache.qpid explicitly. Otherwise log4j will default to DEBUG which will degrade performance considerably due to excessive logging. The recommended logging level for production is <code class="literal">WARN</code>.</p><p>The following example shows the logging properties used to configure client logging for slf4j using the log4j binding. These properties can be placed in a log4j.properties file and placed in the <code class="varname">CLASSPATH</code>, or they can be set explicitly using the <code class="literal">-Dlog4j.configuration</code> property.</p><div class="example"><a id="idp32997536" /><p class="title"><strong>Example&#160;3.6.&#160;log4j Logging Properties</strong></p><div class="example-contents"><pre class="programlisting">
	log4j.logger.org.apache.qpid=WARN, console
	log4j.additivity.org.apache.qpid=false

	log4j.appender.console=org.apache.log4j.ConsoleAppender
	log4j.appender.console.Threshold=all
	log4j.appender.console.layout=org.apache.log4j.PatternLayout
	log4j.appender.console.layout.ConversionPattern=%t %d %p [%c{4}] %m%n
	</pre></div></div><br class="example-break" /></div><div class="section" title="3.6.&#160;Configuring the JMS Client"><div class="titlepage"><div><div><h2 class="title"><a id="idp32999424" />3.6.&#160;Configuring the JMS Client</h2></div></div></div><p>The Qpid JMS Client allows several configuration options to customize it's behaviour at different levels of granualarity.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>
            JVM level using JVM arguments : Configuration that affects all connections, sessions, consumers and producers created within that JVM.
	  </p><p>Ex. <code class="varname">-Dmax_prefetch=1000</code> property specifies the message credits to use.</p></li><li class="listitem"><p>
            Connection level using Connection/Broker properties : Affects the respective connection and sessions, consumers and produces created by that connection.
	  </p><p>Ex. <code class="varname">amqp://guest:guest@test/test?max_prefetch='1000'
	  &amp;brokerlist='tcp://localhost:5672'
	  </code> property specifies the message credits to use. This overrides any value specified via the JVM argument <code class="varname">max_prefetch</code>.</p><p>Please refer to the <a class="xref" href="#section-jms-connection-url" title="3.2.2.&#160;Connection URLs">Section&#160;3.2.2, &#8220;Connection URLs&#8221;</a> section for a complete list of all properties and how to use them.</p></li><li class="listitem"><p>
            Destination level using Addressing options : Affects the producer(s) and consumer(s) created using the respective destination.
	  </p><p>Ex. <code class="varname">my-queue; {create: always, link:{capacity: 10}}</code>, where <code class="varname">capacity</code> option specifies the message credits to use. This overrides any connection level configuration.</p><p>Please refer to the <a class="xref" href="#section-addresses" title="2.4.&#160;Addresses">Section&#160;2.4, &#8220;Addresses&#8221;</a> section for a complete understanding of addressing and it's various options.</p></li></ul></div><p>Some of these config options are available at all three levels (Ex. <code class="varname">max_prefetch</code>), while others are available only at JVM or connection level.</p><div class="section" title="3.6.1.&#160;Qpid JVM Arguments"><div class="titlepage"><div><div><h3 class="title"><a id="client-jvm-properties" />3.6.1.&#160;Qpid JVM Arguments</h3></div></div></div><div class="table"><a id="idp33010976" /><p class="title"><strong>Table&#160;3.6.&#160;Config Options For Connection Behaviour</strong></p><div class="table-contents"><table border="1" summary="Config Options For Connection Behaviour"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>Property Name</th><th>Type</th><th>Default Value</th><th>Description</th></tr></thead><tbody><tr><td>qpid.amqp.version</td><td>string</td><td>0-10</td><td><p>Sets the AMQP version to be used - currently supports one of {0-8,0-9,0-91,0-10}.</p><p>The client will begin negotiation at the specified version and only negotiate downwards if the Broker does not support the specified version.</p></td></tr><tr><td>qpid.heartbeat</td><td>int</td><td>120 (secs)</td><td>The heartbeat interval in seconds. Two consective misssed heartbeats will result in the connection timing out.<p>This can also be set per connection using the <a class="link" href="#section-jms-connection-url" title="3.2.2.&#160;Connection URLs">Connection URL</a> options.</p></td></tr><tr><td>ignore_setclientID</td><td>boolean</td><td>false</td><td>If a client ID is specified in the connection URL it's used or else an ID is generated. If an ID is specified after it's been set Qpid will throw an exception. <p>Setting this property to 'true' will disable that check and allow you to set a client ID of your choice later on.</p></td></tr></tbody></table></div></div><br class="table-break" /><div class="table"><a id="idp33023024" /><p class="title"><strong>Table&#160;3.7.&#160;Config Options For Session Behaviour</strong></p><div class="table-contents"><table border="1" summary="Config Options For Session Behaviour"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>Property Name</th><th>Type</th><th>Default Value</th><th>Description</th></tr></thead><tbody><tr><td>qpid.session.command_limit</td><td>int</td><td>65536</td><td>Limits the # of unacked commands</td></tr><tr><td>qpid.session.byte_limit</td><td>int</td><td>1048576</td><td>Limits the # of unacked commands in terms of bytes</td></tr><tr><td>qpid.use_legacy_map_message</td><td>boolean</td><td>false</td><td><p>If set will use the old map message encoding. By default the Map messages are encoded using the 0-10 map encoding.</p><p>This can also be set per connection using the <a class="link" href="#section-jms-connection-url" title="3.2.2.&#160;Connection URLs">Connection URL</a> options.</p></td></tr><tr><td>qpid.jms.daemon.dispatcher</td><td>boolean</td><td>false</td><td><p>Controls whether the Session dispatcher thread is a daemon thread or not. If this system property is set to true then the Session dispatcher threads will be created as daemon threads. This setting is introduced in version 0.16.</p></td></tr></tbody></table></div></div><br class="table-break" /><div class="table"><a id="idp33036288" /><p class="title"><strong>Table&#160;3.8.&#160;Config Options For Consumer Behaviour</strong></p><div class="table-contents"><table border="1" summary="Config Options For Consumer Behaviour"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>Property Name</th><th>Type</th><th>Default Value</th><th>Description</th></tr></thead><tbody><tr><td>max_prefetch</td><td>int</td><td>500</td><td>Maximum number of pre-fetched messages per consumer. <p>This can also be defaulted for consumers created on a particular connection using the <a class="link" href="#section-jms-connection-url" title="3.2.2.&#160;Connection URLs">Connection URL</a> options, or per destination (see the <code class="varname">capacity</code> option under link properties in addressing)</p></td></tr><tr><td>qpid.session.max_ack_delay</td><td>long</td><td>1000 (ms)</td><td><p>Timer interval to flush message acks in buffer when using AUTO_ACK and DUPS_OK.</p> <p>When using the above ack modes, message acks are batched and sent if one of the following conditions are met (which ever happens first).
		</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>When the ack timer fires.</p></li><li class="listitem"><p>if un_acked_msg_count &gt; max_prefetch/2.</p></li></ul></div><p>
	      </p>
	      <p>The ack timer can be disabled by setting it to 0.</p>
		</td></tr><tr><td>sync_ack</td><td>boolean</td><td>false</td><td><p>If set, each message will be acknowledged synchronously. When using AUTO_ACK mode, you need to set this to "true", in order to get the correct behaviour as described by the JMS spec.</p><p>This is set to false by default for performance reasons, therefore by default AUTO_ACK behaves similar to DUPS_OK.</p><p>This can also be set per connection using the <a class="link" href="#section-jms-connection-url" title="3.2.2.&#160;Connection URLs">Connection URL</a> options.</p></td></tr></tbody></table></div></div><br class="table-break" /><div class="table"><a id="idp33051760" /><p class="title"><strong>Table&#160;3.9.&#160;Config Options For Producer Behaviour</strong></p><div class="table-contents"><table border="1" summary="Config Options For Producer Behaviour"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>Property Name</th><th>Type</th><th>Default Value</th><th>Description</th></tr></thead><tbody><tr><td>sync_publish</td><td>string</td><td>"" (disabled)</td><td><p>If one of {persistent|all} is set then persistent messages or all messages will be sent synchronously.</p><p>This can also be set per connection using the <a class="link" href="#section-jms-connection-url" title="3.2.2.&#160;Connection URLs">Connection URL</a> options.</p></td></tr></tbody></table></div></div><br class="table-break" /><div class="table"><a id="idp33058880" /><p class="title"><strong>Table&#160;3.10.&#160;Config Options For Threading</strong></p><div class="table-contents"><table border="1" summary="Config Options For Threading"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>Property Name</th><th>Type</th><th>Default Value</th><th>Description</th></tr></thead><tbody><tr><td>qpid.thread_factory</td><td>string</td><td>org.apache.qpid.thread.DefaultThreadFactory</td><td><p>Specifies the thread factory to use.</p><p>If using a real time JVM, you need to set the above property to <code class="varname">org.apache.qpid.thread.RealtimeThreadFactory</code>.</p></td></tr><tr><td>qpid.rt_thread_priority</td><td>int</td><td>20</td><td><p>Specifies the priority (1-99) for Real time threads created by the real time thread factory.</p></td></tr></tbody></table></div></div><br class="table-break" /><div class="table"><a id="idp33067888" /><p class="title"><strong>Table&#160;3.11.&#160;Config Options For I/O</strong></p><div class="table-contents"><table border="1" summary="Config Options For I/O"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>Property Name</th><th>Type</th><th>Default Value</th><th>Description</th></tr></thead><tbody><tr><td>qpid.transport</td><td>string</td><td>org.apache.qpid.transport.network.io.IoNetworkTransport</td><td><p>The transport implementation to be used.</p><p>A user could specify an alternative transport mechanism that implements the interface <code class="varname">org.apache.qpid.transport.network.OutgoingNetworkTransport</code>.</p></td></tr><tr><td>qpid.sync_op_timeout</td><td>long</td><td>60000</td><td><p>The length of time (in milliseconds) to wait for a synchronous operation to complete.</p><p>For compatibility with older clients, the synonym <code class="varname">amqj.default_syncwrite_timeout</code> is supported.</p></td></tr><tr><td>qpid.tcp_nodelay</td><td>boolean</td><td>true</td><td>
		  <p>Sets the TCP_NODELAY property of the underlying socket. The default was changed to true as of Qpid 0.14.</p>
		  <p>This can also be set per connection using the <a class="link" href="#section-jms-connection-url" title="3.2.2.&#160;Connection URLs">Connection URL</a> options.</p>
		  <p>For compatibility with older clients, the synonym <code class="varname">amqj.tcp_nodelay</code> is supported.</p>
		</td></tr><tr><td>qpid.send_buffer_size</td><td>integer</td><td>65535</td><td>
		  <p>Sets the SO_SNDBUF property of the underlying socket. Added in Qpid 0.16.</p>
		  <p>For compatibility with older clients, the synonym <code class="varname">amqj.sendBufferSize</code> is supported.</p>
		</td></tr><tr><td>qpid.receive_buffer_size</td><td>integer</td><td>65535</td><td>
		  <p>Sets the SO_RCVBUF property of the underlying socket. Added in Qpid 0.16.</p>
		  <p>For compatibility with older clients, the synonym <code class="varname">amqj.receiveBufferSize</code> is supported.</p>
		</td></tr><tr><td>qpid.failover_method_timeout</td><td>long</td><td>60000</td><td>
              <p>During failover, this is the timeout for each attempt to try to re-establish the connection.
                    If a reconnection attempt exceeds the timeout, the entire failover process is aborted.</p>
              <p>It is only applicable for AMQP 0-8/0-9/0-9-1 clients.</p>
            </td></tr></tbody></table></div></div><br class="table-break" /><div class="table"><a id="idp33091056" /><p class="title"><strong>Table&#160;3.12.&#160;Config Options For Security</strong></p><div class="table-contents"><table border="1" summary="Config Options For Security"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>Property Name</th><th>Type</th><th>Default Value</th><th>Description</th></tr></thead><tbody><tr><td>qpid.sasl_mechs</td><td>string</td><td>PLAIN</td><td><p>The SASL mechanism to be used. More than one could be specified as a comma separated list.</p><p>We currently support the following mechanisms {PLAIN | GSSAPI | EXTERNAL}.</p><p>This can also be set per connection using the <a class="link" href="#section-jms-connection-url" title="3.2.2.&#160;Connection URLs">Connection URL</a> options.</p></td></tr><tr><td>qpid.sasl_protocol</td><td>string</td><td>AMQP</td><td><p>When using GSSAPI as the SASL mechanism, <code class="varname">sasl_protocol</code> must be set to the principal for the qpidd broker, e.g. <code class="varname">qpidd</code>.</p><p>This can also be set per connection using the <a class="link" href="#section-jms-connection-url" title="3.2.2.&#160;Connection URLs">Connection URL</a> options.</p></td></tr><tr><td>qpid.sasl_server_name</td><td>string</td><td>localhost</td><td><p>When using GSSAPI as the SASL mechanism, <code class="varname">sasl_server</code> must be set to the host for the SASL server, e.g. <code class="varname">example.com</code>.</p><p>This can also be set per connection using the <a class="link" href="#section-jms-connection-url" title="3.2.2.&#160;Connection URLs">Connection URL</a> options.</p></td></tr></tbody></table></div></div><br class="table-break" /><div class="table"><a id="idp33106000" /><p class="title"><strong>Table&#160;3.13.&#160;Config Options For Security - Standard JVM properties needed when using GSSAPI as the SASL mechanism.<sup>[<a class="footnote" href="#ftn.idp33106624" id="idp33106624">a</a>]</sup></strong></p><div class="table-contents"><table border="1" summary="Config Options For Security - Standard JVM properties needed when using GSSAPI as the SASL mechanism.Please refer to the Java security documentation for a complete understanding of the above properties."><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>Property Name</th><th>Type</th><th>Default Value</th><th>Description</th></tr></thead><tbody><tr><td>javax.security.auth.useSubjectCredsOnly</td><td>boolean</td><td>true</td><td><p>If set to 'false', forces the SASL GASSPI client to obtain the kerberos credentials explicitly instead of obtaining from the "subject" that owns the current thread.</p></td></tr><tr><td>java.security.auth.login.config</td><td>string</td><td>&#160;</td><td><p>Specifies the jass configuration file.</p><p><code class="varname">Ex-Djava.security.auth.login.config=myjas.conf</code>
		</p><p>Here is the sample myjas.conf JASS configuration file: </p><pre class="programlisting">

		com.sun.security.jgss.initiate {
		com.sun.security.auth.module.Krb5LoginModule required useTicketCache=true;
		};

		</pre></td></tr></tbody><tbody class="footnotes"><tr><td colspan="4"><div class="footnote"><p><sup>[<a class="para" href="#idp33106624" id="ftn.idp33106624">a</a>] </sup>Please refer to the Java security documentation for a complete understanding of the above properties.</p></div></td></tr></tbody></table></div></div><br class="table-break" /><div class="table"><a id="idp33116320" /><p class="title"><strong>Table&#160;3.14.&#160;Config Options For Security - Using SSL for securing connections or using EXTERNAL as the SASL mechanism.</strong></p><div class="table-contents"><table border="1" summary="Config Options For Security - Using SSL for securing connections or using EXTERNAL as the SASL mechanism."><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>Property Name</th><th>Type</th><th>Default Value</th><th>Description</th></tr></thead><tbody><tr><td>qpid.ssl_timeout</td><td>long</td><td>60000</td><td><p>Timeout value used by the Java SSL engine when waiting on operations.</p></td></tr><tr><td>qpid.ssl.KeyManagerFactory.algorithm</td><td>string</td><td>-</td><td>
		  <p>The key manager factory algorithm name. If not set, defaults to the value returned from the Java runtime call <code class="literal">KeyManagerFactory.getDefaultAlgorithm()</code></p>
		  <p>For compatibility with older clients, the synonym <code class="varname">qpid.ssl.keyStoreCertType</code> is supported.</p>
		</td></tr><tr><td>qpid.ssl.TrustManagerFactory.algorithm</td><td>string</td><td>-</td><td>
		  <p>The trust manager factory algorithm name. If not set, defaults to the value returned from the Java runtime call <code class="literal">TrustManagerFactory.getDefaultAlgorithm()</code></p>
		  <p>For compatibility with older clients, the synonym <code class="varname">qpid.ssl.trustStoreCertType</code> is supported.</p>
		</td></tr></tbody></table></div></div><br class="table-break" /><div class="table"><a id="idp33129968" /><p class="title"><strong>Table&#160;3.15.&#160;Config Options For Security - Standard JVM properties needed when Using SSL for securing connections or using EXTERNAL as the SASL mechanism.<sup>[<a class="footnote" href="#ftn.idp33130640" id="idp33130640">a</a>]</sup></strong></p><div class="table-contents"><table border="1" summary="Config Options For Security - Standard JVM properties needed when Using SSL for securing connections or using EXTERNAL as the SASL mechanism.Qpid allows you to have per connection key and trust stores if required. If specified per connection, the JVM arguments are ignored."><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>Property Name</th><th>Type</th><th>Default Value</th><th>Description</th></tr></thead><tbody><tr><td>javax.net.ssl.keyStore</td><td>string</td><td>jvm default</td><td><p>Specifies the key store path.</p><p>This can also be set per connection using the <a class="link" href="#section-jms-connection-url" title="3.2.2.&#160;Connection URLs">Connection URL</a> options.</p></td></tr><tr><td>javax.net.ssl.keyStorePassword</td><td>string</td><td>jvm default</td><td><p>Specifies the key store password.</p><p>This can also be set per connection using the <a class="link" href="#section-jms-connection-url" title="3.2.2.&#160;Connection URLs">Connection URL</a> options.</p></td></tr><tr><td>javax.net.ssl.trustStore</td><td>string</td><td>jvm default</td><td><p>Specifies the trust store path.</p><p>This can also be set per connection using the <a class="link" href="#section-jms-connection-url" title="3.2.2.&#160;Connection URLs">Connection URL</a> options.</p></td></tr><tr><td>javax.net.ssl.trustStorePassword</td><td>string</td><td>jvm default</td><td><p>Specifies the trust store password.</p><p>This can also be set per connection using the <a class="link" href="#section-jms-connection-url" title="3.2.2.&#160;Connection URLs">Connection URL</a> options.</p></td></tr></tbody><tbody class="footnotes"><tr><td colspan="4"><div class="footnote"><p><sup>[<a class="para" href="#idp33130640" id="ftn.idp33130640">a</a>] </sup>Qpid allows you to have per connection key and trust stores if required. If specified per connection, the JVM arguments are ignored.</p></div></td></tr></tbody></table></div></div><br class="table-break" /></div></div></div><div class="chapter" title="Chapter&#160;4.&#160;Using the Qpid WCF client"><div class="titlepage"><div><div><h2 class="title"><a id="QpidWCF" />Chapter&#160;4.&#160;Using the Qpid WCF client</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="section"><a href="#idp33147712">4.1. XML and Binary Bindings</a></span></dt><dt><span class="section"><a href="#idp33175216">4.2. Endpoints</a></span></dt><dt><span class="section"><a href="#idp33179504">4.3. Message Headers</a></span></dt><dt><span class="section"><a href="#idp33183024">4.4. Security</a></span></dt><dt><span class="section"><a href="#idp33187136">4.5. Transactions</a></span></dt></dl></div><div class="section" title="4.1.&#160;XML and Binary Bindings"><div class="titlepage"><div><div><h2 class="title"><a id="idp33147712" />4.1.&#160;XML and Binary Bindings</h2></div></div></div><p>The Qpid WCF client provides two bindings, each with support for
      Windows .NET transactions.</p><p>The AmqpBinding is suitable for communication between two WCF
      applications.  By default it uses the WCF binary .NET XML encoder
      (BinaryMessageEncodingBindingElement) for efficient message
      transmission, but it can also use the text and Message Transmission
      Optimization Mechanism (MTOM) encoders.  Here is a traditional service
      model sample program using the AmqpBinding.  It assumes that the queue
      "hello_service_node" has been created and configured on the AMQP
      broker.</p><div class="example"><a id="idp33149760" /><p class="title"><strong>Example&#160;4.1.&#160;Traditional service model "Hello world!" example</strong></p><div class="example-contents"><pre class="programlisting">
      namespace Apache.Qpid.Documentation.HelloService
      {
      using System;
      using System.ServiceModel;
      using System.ServiceModel.Channels;
      using System.Threading;
      using Apache.Qpid.Channel;

      [ServiceContract]
      public interface IHelloService
      {
      [OperationContract(IsOneWay = true, Action = "*")]
      void SayHello(string greeting);
      }

      public class HelloService : IHelloService
      {
      private static int greetingCount;

      public static int GreetingCount
      {
      get { return greetingCount; }
      }

      public void SayHello(string greeting)
      {
      Console.WriteLine("Service received: " + greeting);
      greetingCount++;
      }</pre><pre class="programlisting">
      static void Main(string[] args)
      {
      try
      {
      AmqpBinding amqpBinding = new AmqpBinding();
      amqpBinding.BrokerHost = "localhost";
      amqpBinding.BrokerPort = 5672;

      ServiceHost serviceHost = new ServiceHost(typeof(HelloService));
      serviceHost.AddServiceEndpoint(typeof(IHelloService),
      amqpBinding, "amqp:hello_service_node");
      serviceHost.Open();

      // Send the service a test greeting
      Uri amqpClientUri=new Uri("amqp:amq.direct?routingkey=hello_service_node");
      EndpointAddress clientEndpoint = new EndpointAddress(amqpClientUri);
      ChannelFactory&lt;IHelloService&gt; channelFactory =
      new ChannelFactory&lt;IHelloService&gt;(amqpBinding, clientEndpoint);
      IHelloService clientProxy = channelFactory.CreateChannel();

      clientProxy.SayHello("Greetings from WCF client");

      // wait for service to process the greeting
      while (HelloService.GreetingCount == 0)
      {
      Thread.Sleep(100);
      }
      channelFactory.Close();
      serviceHost.Close();
      }
      catch (Exception e)
      {
      Console.WriteLine("Exception: {0}", e);
      }
      }
      }
      }
      </pre></div></div><br class="example-break" /><p>The second binding, AmqpBinaryBinding, is suitable for WCF
      applications that need to inter-operate with non-WCF clients or that
      wish to have direct access to the raw wire representation of the
      message body.  It relies on a custom encoder to read and write raw
      (binary) content which operates similarly to the ByteStream encoder
      (introduced in .NET 4.0).  The encoder presents an abstract XML
      infoset view of the raw message content on input.  On output, the
      encoder does the reverse and peels away the XML infoset layer exposing
      the raw content to the wire representation of the message body.  The
      application must do the inverse of what the encoder does to allow the
      XML infoset wrapper to cancel properly.  This is demonstrated in the
      following sample code (using the channel programming model) which
      directly manipulates or provides callbacks to the WCF message readers
      and writers when the content is consumed.  In contrast to the
      AmqpBinding sample where the simple greeting is encapsulated in a
      compressed SOAP envelope, the wire representation of the message
      contains the raw content and is identical and fully interoperable with
      the Qpid C++ "Hello world!"  example.</p><div class="example"><a id="idp33153088" /><p class="title"><strong>Example&#160;4.2.&#160;Binary  "Hello world!" example using the channel model</strong></p><div class="example-contents"><pre class="programlisting">
      namespace Apache.Qpid.Samples.Channel.HelloWorld
      {
      using System;
      using System.ServiceModel;
      using System.ServiceModel.Channels;
      using System.ServiceModel.Description;
      using System.Text;
      using System.Xml;
      using Apache.Qpid.Channel;

      public class HelloWorld
      {
      static void Main(string[] args)
      {
      String broker = "localhost";
      int port = 5672;
      String target = "amq.topic";
      String source = "my_topic_node";

      if (args.Length &gt; 0)
      {
      broker = args[0];
      }

      if (args.Length &gt; 1)
      {
      port = int.Parse(args[1]);
      }

      if (args.Length &gt; 2)
      {
      target = args[2];
      }

      if (args.Length &gt; 3)
      {
      source = args[3];
      }

      AmqpBinaryBinding binding = new AmqpBinaryBinding();
      binding.BrokerHost = broker;
      binding.BrokerPort = port;

      IChannelFactory&lt;IInputChannel&gt; receiverFactory = binding.BuildChannelFactory&lt;IInputChannel&gt;();
      receiverFactory.Open();
      IInputChannel receiver = receiverFactory.CreateChannel(new EndpointAddress("amqp:" + source));
      receiver.Open();

      IChannelFactory&lt;IOutputChannel&gt; senderFactory = binding.BuildChannelFactory&lt;IOutputChannel&gt;();
      senderFactory.Open();
      IOutputChannel sender = senderFactory.CreateChannel(new EndpointAddress("amqp:" + target));
      sender.Open();

      sender.Send(Message.CreateMessage(MessageVersion.None, "", new HelloWorldBinaryBodyWriter()));

      Message message = receiver.Receive();
      XmlDictionaryReader reader = message.GetReaderAtBodyContents();
      while (!reader.HasValue)
      {
      reader.Read();
      }

      byte[] binaryContent = reader.ReadContentAsBase64();
      string text = Encoding.UTF8.GetString(binaryContent);

      Console.WriteLine(text);

      senderFactory.Close();
      receiverFactory.Close();
      }
      }

      public class HelloWorldBinaryBodyWriter : BodyWriter
      {
      public HelloWorldBinaryBodyWriter() : base (true) {}

      protected override void OnWriteBodyContents(XmlDictionaryWriter writer)
      {
      byte[] binaryContent = Encoding.UTF8.GetBytes("Hello world!");

      // wrap the content:
      writer.WriteStartElement("Binary");
      writer.WriteBase64(binaryContent, 0, binaryContent.Length);
      }
      }
      }
      </pre></div></div><br class="example-break" /><p>Bindings define ChannelFactories and ChannelListeners associated with
      an AMQP Broker.  WCF will frequently automatically create and manage
      the life cycle of a these and the resulting IChannel objects used in
      message transfer.  The binding parameters that can be set are:</p><div class="table"><a id="idp33157744" /><p class="title"><strong>Table&#160;4.1.&#160;WCF Binding Parameters</strong></p><div class="table-contents"><table border="1" summary="WCF Binding Parameters" width="100%"><colgroup><col /><col /><col /></colgroup><thead><tr><th>Parameter</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td>
		BrokerHost
	      </td><td>
		localhost
	      </td><td>
		The broker's server name.  Currently the WCF channel
		only supports connections with a single broker.
		Failover to multiple brokers will be provided in the
		future.
	      </td></tr><tr><td>
		BrokerPort
	      </td><td>
		5672
	      </td><td>
		The port the broker is listening on.
	      </td></tr><tr><td>
		PrefetchLimit
	      </td><td>
		0
	      </td><td>
		The number of messages to prefetch from the amqp
		broker before the application actually consumes them.
		Increasing this number can dramatically increase the
		read performance in some circumstances.
	      </td></tr><tr><td>
		Shared
	      </td><td>
		false
	      </td><td>
		Indicates if separate channels to the same broker can
		share an underlying AMQP tcp connection (provided they
		also share the same authentication credentials).
	      </td></tr><tr><td>
		TransferMode
	      </td><td>
		buffered
	      </td><td>
		Indicates whether the channel's encoder uses the WCF
		BufferManager cache to temporarily store message
		content during the encoding/decoding phase.  For small
		to medium sized SOAP based messages, buffered is
		usually the preferred choice.  For binary messages,
		streamed TransferMode is the more efficient mode.
	      </td></tr></tbody></table></div></div><br class="table-break" /></div><div class="section" title="4.2.&#160;Endpoints"><div class="titlepage"><div><div><h2 class="title"><a id="idp33175216" />4.2.&#160;Endpoints</h2></div></div></div><p>In Qpid 0.6 the WCF Endpoints map to simple AMQP 0-10
      exchanges (IOutputChannel) or AMQP 0-10 queues (IInputChannel).
      The format for an IOutputChannel is</p><pre class="programlisting">
  "amqp:amq.direct" or "amqp:my_exchange?routingkey=my_routing_key"
</pre><p>and for an IInputChannel is</p><pre class="programlisting">
  "amqp:my_queue"
</pre><p>The routing key is in fact a default value associated with
      the particular channel.  Outgoing messages can always have their
      routing key uniquely set.</p><p>If the respective queue or exchange doesn't exist, an exception
      is thrown when opening the channel.  Queues and exchanges can be
      created and configured using qpid-config.</p></div><div class="section" title="4.3.&#160;Message Headers"><div class="titlepage"><div><div><h2 class="title"><a id="idp33179504" />4.3.&#160;Message Headers</h2></div></div></div><p>AMQP specific message headers can be set on or retrieved
      from the ServiceModel.Channels.Message using the AmqpProperties
      type.</p><p>For example, on output:</p><pre class="programlisting">
AmqpProperties props = new AmqpProperties();
props.Durable = true;
props.PropertyMap.Add("my_custom_header", new AmqpString("a custom value"));
Message msg = Message.CreateMessage(args);
msg.Properties.Add("AmqpProperties", amqpProperties);
outputChannel.Send(msg);
</pre><p>On input the headers can be accessed from the Message or extracted
      from the operation context</p><pre class="programlisting">
public void SayHello(string greeting)
{
  AmqpProperties props = (AmqpProperties) OperationContext.
  Current.IncomingMessageProperties["AmqpProperties"];
  AmqpString extra = (AmqpString) props.PropertyMap["my_custom_header"];
  Console.WriteLine("Service received: {0} and {1}", greeting, extra);
}
</pre></div><div class="section" title="4.4.&#160;Security"><div class="titlepage"><div><div><h2 class="title"><a id="idp33183024" />4.4.&#160;Security</h2></div></div></div><p>To engage TLS/SSL:</p><pre class="programlisting">
binding.Security.Mode = AmqpSecurityMode.Transport;
binding.Security.Transport.UseSSL = true;
binding.BrokerPort = 5671;
</pre><p>Currently the WCF client only provides SASL PLAIN (i.e. username and
      password) authentication.  To provide a username and password, you can
      set the DefaultAmqpCredential value in the binding.  This value can be
      overridden or set for a binding's channel factories and listeners,
      either by setting the ClientCredentials as a binding parameter, or by
      using an AmqpCredential as a binding parameter.  The search order for
      credentials is the AmqpCredential binding parameter, followed by the
      ClientCredentials (unless IgnoreEndpointClientCredentials has been
      set), and finally defaulting to the DefaultAmqpCredential of the
      binding itself.  Here is a sample using ClientCredentials:</p><pre class="programlisting">
ClientCredentials credentials = new ClientCredentials();
credentials.UserName.UserName = "guest";
credentials.UserName.Password = "guest";
bindingParameters = new BindingParameterCollection();
bindingParameters.Add(credentials);
readerFactory = binding.BuildChannelFactory&lt;IInputChannel&gt;(bindingParameters);
</pre></div><div class="section" title="4.5.&#160;Transactions"><div class="titlepage"><div><div><h2 class="title"><a id="idp33187136" />4.5.&#160;Transactions</h2></div></div></div><p>The WCF channel provides a transaction resource manager
      module and a recovery module that together provide distributed
      transaction support with one-phase optimization.  Some
      configuration is required on Windows machines to enable
      transaction support (see your installation notes or top level
      ReadMe.txt file for instructions).  Once properly configured,
      the Qpid WCF channel acts as any other System.Transactions aware
      resource, capable of participating in explicit or implicit
      transactions.</p><p>Server code:</p><pre class="programlisting">
[OperationBehavior(TransactionScopeRequired = true,
                   TransactionAutoComplete = true)]

public void SayHello(string greeting)
{
  // increment ExactlyOnceReceived counter on DB

  // Success: transaction auto completes:
}
</pre><p>Because this operation involves two transaction resources, the
      database and the AMQP message broker, this operates as a full two
      phase commit transaction managed by the Distributed Transaction
      Coordinator service.  If the transaction proceeds without error,
      both ExactlyOnceReceived is incremented in the database and the AMQP
      message is consumed from the broker.  Otherwise, ExactlyOnceReceived is
      unchanged and AMQP message is returned to its queue on the broker.</p><p>For the client code a few changes are made to the non-transacted
      example.  For "exactly once" semantics, we set the AMQP "Durable"
      message property and enclose the transacted activities in a
      TransactionScope:</p><pre class="programlisting">
AmqpProperties myDefaults = new AmqpProperties();
myDefaults.Durable = true;
amqpBinding.DefaultMessageProperties = myDefaults;
ChannelFactory&lt;IHelloService&gt; channelFactory =
new ChannelFactory&lt;IHelloService&gt;(amqpBinding, clientEndpoint);
IHelloService clientProxy = channelFactory.CreateChannel();

using (TransactionScope ts = new TransactionScope())
{
   AmqpProperties amqpProperties = new AmqpProperties();
   clientProxy.SayHello("Greetings from WCF client");
   // increment ExactlyOnceSent counter on DB
   ts.Complete();
}
</pre></div></div><div class="chapter" title="Chapter&#160;5.&#160;The .NET Binding for the C++ Messaging Client"><div class="titlepage"><div><div><h2 class="title"><a id="idp33192768" />Chapter&#160;5.&#160;The .NET Binding for the C++ Messaging Client</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="section"><a href="#idp33194688">5.1. .NET Binding for the C++ Messaging Client Component Architecture</a></span></dt><dt><span class="section"><a href="#idp33208256">5.2. .NET Binding for the C++ Messaging Client Examples</a></span></dt><dt><span class="section"><a href="#idp33257520">5.3. .NET Binding Class Mapping to Underlying C++ Messaging API</a></span></dt><dd><dl><dt><span class="section"><a href="#idp33258768">5.3.1. .NET Binding for the C++ Messaging API Class: Address</a></span></dt><dt><span class="section"><a href="#idp33329600">5.3.2. .NET Binding for the C++ Messaging API Class: Connection</a></span></dt><dt><span class="section"><a href="#idp33404720">5.3.3. .NET Binding for the C++ Messaging API Class: Duration</a></span></dt><dt><span class="section"><a href="#idp33454048">5.3.4. .NET Binding for the C++ Messaging API Class: FailoverUpdates</a></span></dt><dt><span class="section"><a href="#idp33475168">5.3.5. .NET Binding for the C++ Messaging API Class: Message</a></span></dt><dt><span class="section"><a href="#idp33613408">5.3.6. .NET Binding for the C++ Messaging API Class: Receiver</a></span></dt><dt><span class="section"><a href="#idp33688832">5.3.7. .NET Binding for the C++ Messaging API Class: Sender</a></span></dt><dt><span class="section"><a href="#idp33745344">5.3.8. .NET Binding for the C++ Messaging API Class: Session</a></span></dt><dt><span class="section"><a href="#idp33857728">5.3.9. .NET Binding Class: SessionReceiver</a></span></dt></dl></dd></dl></div><p>
      The .NET Binding for the C++ Qpid Messaging Client is a library that gives
      any .NET program access to Qpid C++ Messaging objects and methods.
    </p><div class="section" title="5.1.&#160;.NET Binding for the C++ Messaging Client Component Architecture"><div class="titlepage"><div><div><h2 class="title"><a id="idp33194688" />5.1.&#160;.NET Binding for the C++ Messaging Client Component Architecture</h2></div></div></div><pre class="programlisting">
                      +----------------------------+
                      | Dotnet examples            |
                      | Managed C#                 |
                      +------+---------------+-----+
                             |               |
                             V               |
        +---------------------------+        |
        | .NET Managed Callback     |        |
        | org.apache.qpid.messaging.|        |
        | sessionreceiver.dll       |        |
        +----------------------+----+        |
                               |             |
managed                        V             V
(.NET)                 +--------------------------------+
:::::::::::::::::::::::| .NET Binding Library           |::::::::::::
unmanaged              | org.apache.qpid.messaging.dll  |
(Native Win32/64)      +---------------+----------------+
                                       |
                                       |
      +----------------+               |
      | Native examples|               |
      | Unmanaged C++  |               |
      +--------+-------+               |
               |                       |
               V                       V
          +----------------------------------+
          | QPID Messaging C++ Libraries     |
          | qpid*.dll qmf*.dll               |
          +--------+--------------+----------+
</pre><p>This diagram illustrates the code and library components of the binding
and the hierarchical relationships between them.</p><div class="table"><a id="table-Dotnet-Binding-Component-Architecture" /><p class="title"><strong>Table&#160;5.1.&#160;.NET Binding for the C++ Messaging Client Component Architecture</strong></p><div class="table-contents"><table border="1" summary=".NET Binding for the C++ Messaging Client Component Architecture"><colgroup><col /><col /></colgroup><thead><tr><th>Component Name</th><th>Component Function</th></tr></thead><tbody><tr><td>QPID Messaging C++ Libraries</td><td>The QPID Messaging C++ core run time system</td></tr><tr><td>Unmanaged C++ Example Source Programs</td><td>Ordinary C++ programs that illustrate using qpid/cpp Messaging directly
		in a native Windows environment.</td></tr><tr><td>.NET Messaging Binding Library</td><td>The .NET Messaging Binding library provides interoprability between
		managed .NET programs and the unmanaged, native Qpid Messaging C++ core
		run time system. .NET programs create a Reference to this library thereby
		exposing all of the native C++ Messaging functionality to programs
		written in any .NET language.</td></tr><tr><td>.NET Messaging Managed Callback Library</td><td>An extension of the .NET Messaging Binding Library that provides message
		callbacks in a managed .NET environment.</td></tr><tr><td>Managed C# .NET Example Source Programs</td><td>Various C# example programs that illustrate using .NET Binding for C++ Messaging in the .NET environment.</td></tr></tbody></table></div></div><br class="table-break" /></div><div class="section" title="5.2.&#160;.NET Binding for the C++ Messaging Client Examples"><div class="titlepage"><div><div><h2 class="title"><a id="idp33208256" />5.2.&#160;.NET Binding for the C++ Messaging Client Examples</h2></div></div></div><p>This chapter describes the various sample programs that
      are available to illustrate common Qpid Messaging usage.</p><div class="table"><a id="table-Dotnet-Binding-Example-Client-Server" /><p class="title"><strong>Table&#160;5.2.&#160;Example : Client - Server</strong></p><div class="table-contents"><table border="1" summary="Example : Client - Server"><colgroup><col class="c1" /><col class="c2" /></colgroup><thead><tr><th>Example Name</th><th>Example Description</th></tr></thead><tbody><tr><td>csharp.example.server</td><td>Creates a Receiver and listens for messages.
		Upon message reception the message content is converted to upper case
		and forwarded to the received message's ReplyTo address.</td></tr><tr><td>csharp.example.client</td><td>Sends a series of messages to the Server and prints the original message
		content and the received message content.</td></tr></tbody></table></div></div><br class="table-break" /><div class="table"><a id="table-Dotnet-Binding-Example-MapSender-MapReceiver" /><p class="title"><strong>Table&#160;5.3.&#160;Example : Map Sender &#8211; Map Receiver</strong></p><div class="table-contents"><table border="1" summary="Example : Map Sender &#8211; Map Receiver"><colgroup><col class="c1" /><col class="c2" /></colgroup><thead><tr><th>Example Name</th><th>Example Description</th></tr></thead><tbody><tr><td>csharp.map.receiver</td><td>Creates a Receiver and listens for a map message.
		Upon message reception the message is decoded and displayed on the console.</td></tr><tr><td>csharp.map.sender</td><td>Creates a map message and sends it to map.receiver.
		The map message contains values for every supported .NET Messaging
		Binding data type.</td></tr></tbody></table></div></div><br class="table-break" /><div class="table"><a id="table-Dotnet-Binding-Example-Spout-Drain" /><p class="title"><strong>Table&#160;5.4.&#160;Example : Spout - Drain</strong></p><div class="table-contents"><table border="1" summary="Example : Spout - Drain"><colgroup><col class="c1" /><col class="c2" /></colgroup><thead><tr><th>Example Name</th><th>Example Description</th></tr></thead><tbody><tr><td>csharp.example.spout</td><td>Spout is a more complex example of code that generates a series of messages
		and sends them to peer program Drain. Flexible command line arguments allow
		the user to specify a variety of message and program options.</td></tr><tr><td>csharp.example.drain</td><td>Drain is a more complex example of code that receives a series of messages
		and displays their contents on the console.</td></tr></tbody></table></div></div><br class="table-break" /><div class="table"><a id="table-Dotnet-Binding-Example-CallbackSender-CallbackReceiver" /><p class="title"><strong>Table&#160;5.5.&#160;Example : Map Callback Sender &#8211; Map Callback Receiver</strong></p><div class="table-contents"><table border="1" summary="Example : Map Callback Sender &#8211; Map Callback Receiver"><colgroup><col class="c1" /><col class="c2" /></colgroup><thead><tr><th>Example Name</th><th>Example Description</th></tr></thead><tbody><tr><td>csharp.map.callback.receiver</td><td>Creates a Receiver and listens for a map message.
		Upon message reception the message is decoded and displayed on the console.
		This example illustrates the use of the C# managed code callback mechanism
		provided by .NET Messaging Binding Managed Callback Library.</td></tr><tr><td>csharp.map.callback.sender</td><td>Creates a map message and sends it to map_receiver.
		The map message contains values for every supported .NET Messaging
		Binding data type.</td></tr></tbody></table></div></div><br class="table-break" /><div class="table"><a id="table-Dotnet-Binding-Example-DeclareQueues" /><p class="title"><strong>Table&#160;5.6.&#160;Example - Declare Queues</strong></p><div class="table-contents"><table border="1" summary="Example - Declare Queues"><colgroup><col class="c1" /><col class="c2" /></colgroup><thead><tr><th>Example Name</th><th>Example Description</th></tr></thead><tbody><tr><td>csharp.example.declare_queues</td><td>A program to illustrate creating objects on a broker.
		This program creates a queue used by spout and drain.</td></tr></tbody></table></div></div><br class="table-break" /><div class="table"><a id="table-Dotnet-Binding-Example-DirectSender-DirectReceiver" /><p class="title"><strong>Table&#160;5.7.&#160;Example: Direct Sender - Direct Receiver</strong></p><div class="table-contents"><table border="1" summary="Example: Direct Sender - Direct Receiver"><colgroup><col class="c1" /><col class="c2" /></colgroup><thead><tr><th>Example Name</th><th>Example Description</th></tr></thead><tbody><tr><td>csharp.direct.receiver</td><td>Creates a Receiver and listens for a messages.
		Upon message reception the message is decoded and displayed on the console.</td></tr><tr><td>csharp.direct.sender</td><td> Creates a series of messages and sends them to csharp.direct.receiver.</td></tr></tbody></table></div></div><br class="table-break" /><div class="table"><a id="table-Dotnet-Binding-Example-Helloworld" /><p class="title"><strong>Table&#160;5.8.&#160;Example: Hello World</strong></p><div class="table-contents"><table border="1" summary="Example: Hello World"><colgroup><col class="c1" /><col class="c2" /></colgroup><thead><tr><th>Example Name</th><th>Example Description</th></tr></thead><tbody><tr><td>csharp.example.helloworld</td><td>A program to send a message and to receive the same message.</td></tr></tbody></table></div></div><br class="table-break" /></div><div class="section" title="5.3.&#160;.NET Binding Class Mapping to Underlying C++ Messaging API"><div class="titlepage"><div><div><h2 class="title"><a id="idp33257520" />5.3.&#160;.NET Binding Class Mapping to Underlying C++ Messaging API</h2></div></div></div><p>This chapter describes the specific mappings between
      classes in the .NET Binding and the underlying C++ Messaging
      API.</p><div class="section" title="5.3.1.&#160;.NET Binding for the C++ Messaging API Class: Address"><div class="titlepage"><div><div><h3 class="title"><a id="idp33258768" />5.3.1.&#160;.NET Binding for the C++ Messaging API Class: Address</h3></div></div></div><div class="table"><a id="table-Dotnet-Binding-Address" /><p class="title"><strong>Table&#160;5.9.&#160;.NET Binding for the C++ Messaging API Class: Address</strong></p><div class="table-contents"><table border="1" summary=".NET Binding for the C++ Messaging API Class: Address"><colgroup><col class="c1" /><col class="c2" /></colgroup><thead><tr><th align="center" colspan="2">.NET Binding Class: Address</th></tr><tr><th>Language</th><th>Syntax</th></tr></thead><tbody><tr><td>C++</td><td>class Address</td></tr><tr><td>.NET</td><td>public ref class Address</td></tr><tr><td align="center" colspan="2">Constructor</td></tr><tr><td>C++</td><td>Address();</td></tr><tr><td>.NET</td><td>public Address();</td></tr><tr><td align="center" colspan="2">Constructor</td></tr><tr><td>C++</td><td>Address(const std::string&amp; address);</td></tr><tr><td>.NET</td><td>public Address(string address);</td></tr><tr><td align="center" colspan="2">Constructor</td></tr><tr><td>C++</td><td>Address(const std::string&amp; name, const std::string&amp; subject, const qpid::types::Variant::Map&amp; options, const std::string&amp; type = "");</td></tr><tr><td>.NET</td><td>public Address(string name, string subject, Dictionary&lt;string, object&gt; options);</td></tr><tr><td>.NET</td><td>public Address(string name, string subject, Dictionary&lt;string, object&gt; options, string type);</td></tr><tr><td align="center" colspan="2">Copy constructor</td></tr><tr><td>C++</td><td>Address(const Address&amp; address);</td></tr><tr><td>.NET</td><td>public Address(Address address);</td></tr><tr><td align="center" colspan="2">Destructor</td></tr><tr><td>C++</td><td>~Address();</td></tr><tr><td>.NET</td><td>~Address();</td></tr><tr><td align="center" colspan="2">Finalizer</td></tr><tr><td>C++</td><td>n/a</td></tr><tr><td>.NET</td><td>!Address();</td></tr><tr><td align="center" colspan="2">Copy assignment operator</td></tr><tr><td>C++</td><td>Address&amp; operator=(const Address&amp;);</td></tr><tr><td>.NET</td><td>public Address op_Assign(Address rhs);</td></tr><tr><td align="center" colspan="2">Property: Name</td></tr><tr><td>C++</td><td>const std::string&amp; getName() const;</td></tr><tr><td>C++</td><td>void setName(const std::string&amp;);</td></tr><tr><td>.NET</td><td>public string Name { get; set; }</td></tr><tr><td align="center" colspan="2">Property: Subject</td></tr><tr><td>C++</td><td>const std::string&amp; getSubject() const;</td></tr><tr><td>C++</td><td>void setSubject(const std::string&amp;);</td></tr><tr><td>.NET</td><td>public string Subject { get; set; }</td></tr><tr><td align="center" colspan="2">Property: Options</td></tr><tr><td>C++</td><td>const qpid::types::Variant::Map&amp; getOptions() const;</td></tr><tr><td>C++</td><td>qpid::types::Variant::Map&amp; getOptions();</td></tr><tr><td>C++</td><td>void setOptions(const qpid::types::Variant::Map&amp;);</td></tr><tr><td>.NET</td><td>public Dictionary&lt;string, object&gt; Options { get; set; }</td></tr><tr><td align="center" colspan="2">Property: Type</td></tr><tr><td>C++</td><td>std::string getType() const;</td></tr><tr><td>C++</td><td>void setType(const std::string&amp;);</td></tr><tr><td>.NET</td><td>public string Type { get; set; }</td></tr><tr><td align="center" colspan="2">Miscellaneous</td></tr><tr><td>C++</td><td>std::string str() const;</td></tr><tr><td>.NET</td><td>public string ToStr();</td></tr><tr><td align="center" colspan="2">Miscellaneous</td></tr><tr><td>C++</td><td>operator bool() const;</td></tr><tr><td>.NET</td><td>n/a</td></tr><tr><td align="center" colspan="2">Miscellaneous</td></tr><tr><td>C++</td><td>bool operator !() const;</td></tr><tr><td>.NET</td><td>n/a</td></tr></tbody></table></div></div><br class="table-break" /></div><div class="section" title="5.3.2.&#160;.NET Binding for the C++ Messaging API Class: Connection"><div class="titlepage"><div><div><h3 class="title"><a id="idp33329600" />5.3.2.&#160;.NET Binding for the C++ Messaging API Class: Connection</h3></div></div></div><div class="table"><a id="table-Dotnet-Binding-Connection" /><p class="title"><strong>Table&#160;5.10.&#160;.NET Binding for the C++ Messaging API Class: Connection</strong></p><div class="table-contents"><table border="1" summary=".NET Binding for the C++ Messaging API Class: Connection"><colgroup><col class="c1" /><col class="c2" /></colgroup><thead><tr><th align="center" colspan="2">.NET Binding Class: Connection</th></tr><tr><th>Language</th><th>Syntax</th></tr></thead><tbody><tr><td>C++</td><td>class Connection : public qpid::messaging::Handle&lt;ConnectionImpl&gt;</td></tr><tr><td>.NET</td><td>public ref class Connection</td></tr><tr><td align="center" colspan="2">Constructor</td></tr><tr><td>C++</td><td>Connection(ConnectionImpl* impl);</td></tr><tr><td>.NET</td><td>n/a</td></tr><tr><td align="center" colspan="2">Constructor</td></tr><tr><td>C++</td><td>Connection();</td></tr><tr><td>.NET</td><td>n/a</td></tr><tr><td align="center" colspan="2">Constructor</td></tr><tr><td>C++</td><td>Connection(const std::string&amp; url, const qpid::types::Variant::Map&amp; options = qpid::types::Variant::Map());</td></tr><tr><td>.NET</td><td>public Connection(string url);</td></tr><tr><td>.NET</td><td>public Connection(string url, Dictionary&lt;string, object&gt; options);</td></tr><tr><td align="center" colspan="2">Constructor</td></tr><tr><td>C++</td><td>Connection(const std::string&amp; url, const std::string&amp; options);</td></tr><tr><td>.NET</td><td>public Connection(string url, string options);  </td></tr><tr><td align="center" colspan="2">Copy Constructor</td></tr><tr><td>C++</td><td>Connection(const Connection&amp;);</td></tr><tr><td>.NET</td><td>public Connection(Connection connection);</td></tr><tr><td align="center" colspan="2">Destructor</td></tr><tr><td>C++</td><td>~Connection();</td></tr><tr><td>.NET</td><td>~Connection();</td></tr><tr><td align="center" colspan="2">Finalizer</td></tr><tr><td>C++</td><td>n/a</td></tr><tr><td>.NET</td><td>!Connection();</td></tr><tr><td align="center" colspan="2">Copy assignment operator</td></tr><tr><td>C++</td><td>Connection&amp; operator=(const Connection&amp;);</td></tr><tr><td>.NET</td><td>public Connection op_Assign(Connection rhs);</td></tr><tr><td align="center" colspan="2">Method: SetOption</td></tr><tr><td>C++</td><td>void setOption(const std::string&amp; name, const qpid::types::Variant&amp; value);</td></tr><tr><td>.NET</td><td>public void SetOption(string name, object value);</td></tr><tr><td align="center" colspan="2">Method: open</td></tr><tr><td>C++</td><td>void open();</td></tr><tr><td>.NET</td><td>public void Open();</td></tr><tr><td align="center" colspan="2">Property: isOpen</td></tr><tr><td>C++</td><td>bool isOpen();</td></tr><tr><td>.NET</td><td>public bool IsOpen { get; }</td></tr><tr><td align="center" colspan="2">Method: close</td></tr><tr><td>C++</td><td>void close();</td></tr><tr><td>.NET</td><td>public void Close();</td></tr><tr><td align="center" colspan="2">Method: createTransactionalSession</td></tr><tr><td>C++</td><td>Session createTransactionalSession(const std::string&amp; name = std::string());</td></tr><tr><td>.NET</td><td>public Session CreateTransactionalSession();</td></tr><tr><td>.NET</td><td>public Session CreateTransactionalSession(string name);</td></tr><tr><td align="center" colspan="2">Method: createSession</td></tr><tr><td>C++</td><td>Session createSession(const std::string&amp; name = std::string());</td></tr><tr><td>.NET</td><td>public Session CreateSession();</td></tr><tr><td>.NET</td><td>public Session CreateSession(string name);</td></tr><tr><td align="center" colspan="2">Method: getSession</td></tr><tr><td>C++</td><td>Session getSession(const std::string&amp; name) const;</td></tr><tr><td>.NET</td><td>public Session GetSession(string name);</td></tr><tr><td align="center" colspan="2">Property: AuthenticatedUsername</td></tr><tr><td>C++</td><td>std::string getAuthenticatedUsername();</td></tr><tr><td>.NET</td><td>public string GetAuthenticatedUsername();</td></tr></tbody></table></div></div><br class="table-break" /></div><div class="section" title="5.3.3.&#160;.NET Binding for the C++ Messaging API Class: Duration"><div class="titlepage"><div><div><h3 class="title"><a id="idp33404720" />5.3.3.&#160;.NET Binding for the C++ Messaging API Class: Duration</h3></div></div></div><div class="table"><a id="table-Dotnet-Binding-Duration" /><p class="title"><strong>Table&#160;5.11.&#160;.NET Binding for the C++ Messaging API Class: Duration</strong></p><div class="table-contents"><table border="1" summary=".NET Binding for the C++ Messaging API Class: Duration"><colgroup><col class="c1" /><col class="c2" /></colgroup><thead><tr><th align="center" colspan="2">.NET Binding Class: Duration</th></tr><tr><th>Language</th><th>Syntax</th></tr></thead><tbody><tr><td>C++</td><td>class Duration</td></tr><tr><td>.NET</td><td>public ref class Duration</td></tr><tr><td align="center" colspan="2">Constructor</td></tr><tr><td>C++</td><td>explicit Duration(uint64_t milliseconds);</td></tr><tr><td>.NET</td><td>public Duration(ulong mS);</td></tr><tr><td align="center" colspan="2">Copy constructor</td></tr><tr><td>C++</td><td>n/a</td></tr><tr><td>.NET</td><td>public Duration(Duration rhs);</td></tr><tr><td align="center" colspan="2">Destructor</td></tr><tr><td>C++</td><td>default</td></tr><tr><td>.NET</td><td>default</td></tr><tr><td align="center" colspan="2">Finalizer</td></tr><tr><td>C++</td><td>n/a</td></tr><tr><td>.NET</td><td>default</td></tr><tr><td align="center" colspan="2">Property: Milliseconds</td></tr><tr><td>C++</td><td>uint64_t getMilliseconds() const;</td></tr><tr><td>.NET</td><td>public ulong Milliseconds { get; }</td></tr><tr><td align="center" colspan="2">Operator: *</td></tr><tr><td>C++</td><td>Duration operator*(const Duration&amp; duration, uint64_t multiplier);</td></tr><tr><td>.NET</td><td>public static Duration operator *(Duration dur, ulong multiplier);</td></tr><tr><td>.NET</td><td>public static Duration Multiply(Duration dur, ulong multiplier);</td></tr><tr><td>C++</td><td>Duration operator*(uint64_t multiplier, const Duration&amp; duration);</td></tr><tr><td>.NET</td><td>public static Duration operator *(ulong multiplier, Duration dur);</td></tr><tr><td>.NET</td><td>public static Duration Multiply(ulong multiplier, Duration dur);</td></tr><tr><td align="center" colspan="2">Constants</td></tr><tr><td>C++</td><td>static const Duration FOREVER;</td></tr><tr><td>C++</td><td>static const Duration IMMEDIATE;</td></tr><tr><td>C++</td><td>static const Duration SECOND;</td></tr><tr><td>C++</td><td>static const Duration MINUTE;</td></tr><tr><td>.NET</td><td>public sealed class DurationConstants</td></tr><tr><td>.NET</td><td>public static Duration FORVER;</td></tr><tr><td>.NET</td><td>public static Duration IMMEDIATE;</td></tr><tr><td>.NET</td><td>public static Duration MINUTE;</td></tr><tr><td>.NET</td><td>public static Duration SECOND;</td></tr></tbody></table></div></div><br class="table-break" /></div><div class="section" title="5.3.4.&#160;.NET Binding for the C++ Messaging API Class: FailoverUpdates"><div class="titlepage"><div><div><h3 class="title"><a id="idp33454048" />5.3.4.&#160;.NET Binding for the C++ Messaging API Class: FailoverUpdates</h3></div></div></div><div class="table"><a id="table-Dotnet-Binding-FailoverUpdates" /><p class="title"><strong>Table&#160;5.12.&#160;.NET Binding for the C++ Messaging API Class: FailoverUpdates</strong></p><div class="table-contents"><table border="1" summary=".NET Binding for the C++ Messaging API Class: FailoverUpdates"><colgroup><col class="c1" /><col class="c2" /></colgroup><thead><tr><th align="center" colspan="2">.NET Binding Class: FailoverUpdates</th></tr><tr><th>Language</th><th>Syntax</th></tr></thead><tbody><tr><td>C++</td><td>class FailoverUpdates</td></tr><tr><td>.NET</td><td>public ref class FailoverUpdates</td></tr><tr><td align="center" colspan="2">Constructor</td></tr><tr><td>C++</td><td>FailoverUpdates(Connection&amp; connection);</td></tr><tr><td>.NET</td><td>public FailoverUpdates(Connection connection);</td></tr><tr><td align="center" colspan="2">Destructor</td></tr><tr><td>C++</td><td>~FailoverUpdates();</td></tr><tr><td>.NET</td><td>~FailoverUpdates();</td></tr><tr><td align="center" colspan="2">Finalizer</td></tr><tr><td>C++</td><td>n/a</td></tr><tr><td>.NET</td><td>!FailoverUpdates();</td></tr></tbody></table></div></div><br class="table-break" /></div><div class="section" title="5.3.5.&#160;.NET Binding for the C++ Messaging API Class: Message"><div class="titlepage"><div><div><h3 class="title"><a id="idp33475168" />5.3.5.&#160;.NET Binding for the C++ Messaging API Class: Message</h3></div></div></div><div class="table"><a id="table-Dotnet-Binding-Message" /><p class="title"><strong>Table&#160;5.13.&#160;.NET Binding for the C++ Messaging API Class: Message</strong></p><div class="table-contents"><table border="1" summary=".NET Binding for the C++ Messaging API Class: Message"><colgroup><col class="c1" /><col class="c2" /></colgroup><thead><tr><th align="center" colspan="2">.NET Binding Class: Message</th></tr><tr><th>Language</th><th>Syntax</th></tr></thead><tbody><tr><td>C++</td><td>class Message</td></tr><tr><td>.NET</td><td>public ref class Message</td></tr><tr><td align="center" colspan="2">Constructor</td></tr><tr><td>C++</td><td>Message(const std::string&amp; bytes = std::string());</td></tr><tr><td>.NET</td><td>Message();</td></tr><tr><td>.NET</td><td>Message(System::String ^ theStr);</td></tr><tr><td>.NET</td><td>Message(System::Object ^ theValue);</td></tr><tr><td>.NET</td><td>Message(array&lt;System::Byte&gt; ^ bytes);</td></tr><tr><td align="center" colspan="2">Constructor</td></tr><tr><td>C++</td><td>Message(const char*, size_t);</td></tr><tr><td>.NET</td><td>public Message(byte[] bytes, int offset, int size);</td></tr><tr><td>	</td><td>Copy constructor</td></tr><tr><td>C++</td><td>Message(const Message&amp;);</td></tr><tr><td>.NET</td><td>public Message(Message message);</td></tr><tr><td>	</td><td>Copy assignment operator</td></tr><tr><td>C++</td><td>Message&amp; operator=(const Message&amp;);</td></tr><tr><td>.NET</td><td>public Message op_Assign(Message rhs);</td></tr><tr><td align="center" colspan="2">Destructor</td></tr><tr><td>C++</td><td>~Message();</td></tr><tr><td>.NET</td><td>~Message();</td></tr><tr><td align="center" colspan="2">Finalizer</td></tr><tr><td>C++</td><td>n/a</td></tr><tr><td>.NET</td><td>!Message()</td></tr><tr><td align="center" colspan="2">Property: ReplyTo</td></tr><tr><td>C++</td><td>void setReplyTo(const Address&amp;);</td></tr><tr><td>C++</td><td>const Address&amp; getReplyTo() const;</td></tr><tr><td>.NET</td><td>public Address ReplyTo { get; set; }</td></tr><tr><td align="center" colspan="2">Property: Subject</td></tr><tr><td>C++</td><td>void setSubject(const std::string&amp;);</td></tr><tr><td>C++</td><td>const std::string&amp; getSubject() const;</td></tr><tr><td>.NET</td><td>public string Subject { get; set; }</td></tr><tr><td align="center" colspan="2">Property: ContentType</td></tr><tr><td>C++</td><td>void setContentType(const std::string&amp;);</td></tr><tr><td>C++</td><td>const std::string&amp; getContentType() const;</td></tr><tr><td>.NET</td><td>public string ContentType { get; set; }</td></tr><tr><td align="center" colspan="2">Property: MessageId</td></tr><tr><td>C++</td><td>void setMessageId(const std::string&amp;);</td></tr><tr><td>C++</td><td>const std::string&amp; getMessageId() const;</td></tr><tr><td>.NET</td><td>public string MessageId { get; set; }</td></tr><tr><td align="center" colspan="2">Property: UserId</td></tr><tr><td>C++</td><td>void setUserId(const std::string&amp;);</td></tr><tr><td>C++</td><td>const std::string&amp; getUserId() const;</td></tr><tr><td>.NET</td><td>public string UserId { get; set; }</td></tr><tr><td align="center" colspan="2">Property: CorrelationId</td></tr><tr><td>C++</td><td>void setCorrelationId(const std::string&amp;);</td></tr><tr><td>C++</td><td>const std::string&amp; getCorrelationId() const;</td></tr><tr><td>.NET</td><td>public string CorrelationId { get; set; }</td></tr><tr><td align="center" colspan="2">Property: Priority</td></tr><tr><td>C++</td><td>void setPriority(uint8_t);</td></tr><tr><td>C++</td><td>uint8_t getPriority() const;</td></tr><tr><td>.NET</td><td>public byte Priority { get; set; }</td></tr><tr><td align="center" colspan="2">Property: Ttl</td></tr><tr><td>C++</td><td>void setTtl(Duration ttl);</td></tr><tr><td>C++</td><td>Duration getTtl() const;</td></tr><tr><td>.NET</td><td>public Duration Ttl { get; set; }</td></tr><tr><td align="center" colspan="2">Property: Durable</td></tr><tr><td>C++</td><td>void setDurable(bool durable);</td></tr><tr><td>C++</td><td>bool getDurable() const;</td></tr><tr><td>.NET</td><td>public bool Durable { get; set; }</td></tr><tr><td align="center" colspan="2">Property: Redelivered</td></tr><tr><td>C++</td><td>bool getRedelivered() const;</td></tr><tr><td>C++</td><td>void setRedelivered(bool);</td></tr><tr><td>.NET</td><td>public bool Redelivered { get; set; }</td></tr><tr><td align="center" colspan="2">Method: SetProperty</td></tr><tr><td>C++</td><td>void setProperty(const std::string&amp;, const qpid::types::Variant&amp;);</td></tr><tr><td>.NET</td><td>public void SetProperty(string name, object value);</td></tr><tr><td align="center" colspan="2">Property: Properties</td></tr><tr><td>C++</td><td>const qpid::types::Variant::Map&amp; getProperties() const;</td></tr><tr><td>C++</td><td>qpid::types::Variant::Map&amp; getProperties();</td></tr><tr><td>.NET</td><td>public Dictionary&lt;string, object&gt; Properties { get; set; }</td></tr><tr><td align="center" colspan="2">Method: SetContent</td></tr><tr><td>C++</td><td>void setContent(const std::string&amp;);</td></tr><tr><td>C++</td><td>void setContent(const char* chars, size_t count);</td></tr><tr><td>.NET</td><td>public void SetContent(byte[] bytes);</td></tr><tr><td>.NET</td><td>public void SetContent(string content);</td></tr><tr><td>.NET</td><td>public void SetContent(byte[] bytes, int offset, int size);</td></tr><tr><td align="center" colspan="2">Method: GetContent</td></tr><tr><td>C++</td><td>std::string getContent() const;</td></tr><tr><td>.NET</td><td>public string GetContent();</td></tr><tr><td>.NET</td><td>public void GetContent(byte[] arr);</td></tr><tr><td>.NET</td><td>public void GetContent(Collection&lt;object&gt; __p1);</td></tr><tr><td>.NET</td><td>public void GetContent(Dictionary&lt;string, object&gt; dict);</td></tr><tr><td align="center" colspan="2">Method: GetContentPtr</td></tr><tr><td>C++</td><td>const char* getContentPtr() const;</td></tr><tr><td>.NET</td><td>n/a</td></tr><tr><td align="center" colspan="2">Property: ContentSize</td></tr><tr><td>C++</td><td>size_t getContentSize() const;</td></tr><tr><td>.NET</td><td>public ulong ContentSize { get; }</td></tr><tr><td align="center" colspan="2">Struct: EncodingException</td></tr><tr><td>C++</td><td>struct EncodingException : qpid::types::Exception</td></tr><tr><td>.NET</td><td>n/a</td></tr><tr><td align="center" colspan="2">Method: decode</td></tr><tr><td>C++</td><td>void decode(const Message&amp; message, qpid::types::Variant::Map&amp; map,	const std::string&amp; encoding = std::string());</td></tr><tr><td>C++</td><td>void decode(const Message&amp; message, qpid::types::Variant::List&amp; list, const std::string&amp; encoding = std::string());</td></tr><tr><td>.NET</td><td>n/a</td></tr><tr><td align="center" colspan="2">Method: encode</td></tr><tr><td>C++</td><td>void encode(const qpid::types::Variant::Map&amp; map, Message&amp; message, const std::string&amp; encoding = std::string());</td></tr><tr><td>C++</td><td>void encode(const qpid::types::Variant::List&amp; list, Message&amp; message, const std::string&amp; encoding = std::string());</td></tr><tr><td>.NET</td><td>n/a</td></tr><tr><td align="center" colspan="2">Method: AsString</td></tr><tr><td>C++</td><td>n/a</td></tr><tr><td>.NET</td><td>public string AsString(object obj);</td></tr><tr><td>.NET</td><td>public string ListAsString(Collection&lt;object&gt; list);</td></tr><tr><td>.NET</td><td>public string MapAsString(Dictionary&lt;string, object&gt; dict);</td></tr></tbody></table></div></div><br class="table-break" /></div><div class="section" title="5.3.6.&#160;.NET Binding for the C++ Messaging API Class: Receiver"><div class="titlepage"><div><div><h3 class="title"><a id="idp33613408" />5.3.6.&#160;.NET Binding for the C++ Messaging API Class: Receiver</h3></div></div></div><div class="table"><a id="table-Dotnet-Binding-Receiver" /><p class="title"><strong>Table&#160;5.14.&#160;.NET Binding for the C++ Messaging API Class: Receiver</strong></p><div class="table-contents"><table border="1" summary=".NET Binding for the C++ Messaging API Class: Receiver"><colgroup><col class="c1" /><col class="c2" /></colgroup><thead><tr><th align="center" colspan="2">.NET Binding Class: Receiver</th></tr><tr><th>Language</th><th>Syntax</th></tr></thead><tbody><tr><td>C++</td><td>class Receiver</td></tr><tr><td>.NET</td><td>public ref class Receiver</td></tr><tr><td align="center" colspan="2">Constructor</td></tr><tr><td>.NET</td><td>Constructed object is returned by Session.CreateReceiver</td></tr><tr><td align="center" colspan="2">Copy constructor</td></tr><tr><td>C++</td><td>Receiver(const Receiver&amp;);</td></tr><tr><td>.NET</td><td>public Receiver(Receiver receiver);</td></tr><tr><td align="center" colspan="2">Destructor</td></tr><tr><td>C++</td><td>~Receiver();</td></tr><tr><td>.NET</td><td>~Receiver();</td></tr><tr><td align="center" colspan="2">Finalizer</td></tr><tr><td>C++</td><td>n/a</td></tr><tr><td>.NET</td><td>!Receiver()</td></tr><tr><td align="center" colspan="2">Copy assignment operator</td></tr><tr><td>C++</td><td>Receiver&amp; operator=(const Receiver&amp;);</td></tr><tr><td>.NET</td><td>public Receiver op_Assign(Receiver rhs);</td></tr><tr><td align="center" colspan="2">Method: Get</td></tr><tr><td>C++</td><td>bool get(Message&amp; message, Duration timeout=Duration::FOREVER);</td></tr><tr><td>.NET</td><td>public bool Get(Message mmsgp);</td></tr><tr><td>.NET</td><td>public bool Get(Message mmsgp, Duration durationp);</td></tr><tr><td align="center" colspan="2">Method: Get</td></tr><tr><td>C++</td><td>Message get(Duration timeout=Duration::FOREVER);</td></tr><tr><td>.NET</td><td>public Message Get();</td></tr><tr><td>.NET</td><td>public Message Get(Duration durationp);</td></tr><tr><td align="center" colspan="2">Method: Fetch</td></tr><tr><td>C++</td><td>bool fetch(Message&amp; message, Duration timeout=Duration::FOREVER);</td></tr><tr><td>.NET</td><td>public bool Fetch(Message mmsgp);</td></tr><tr><td>.NET</td><td>public bool Fetch(Message mmsgp, Duration duration);</td></tr><tr><td align="center" colspan="2">Method: Fetch</td></tr><tr><td>C++</td><td>Message fetch(Duration timeout=Duration::FOREVER);</td></tr><tr><td>.NET</td><td>public Message Fetch();</td></tr><tr><td>.NET</td><td>public Message Fetch(Duration durationp);</td></tr><tr><td align="center" colspan="2">Property: Capacity</td></tr><tr><td>C++</td><td>void setCapacity(uint32_t);</td></tr><tr><td>C++</td><td>uint32_t getCapacity();</td></tr><tr><td>.NET</td><td>public uint Capacity { get; set; }</td></tr><tr><td align="center" colspan="2">Property: Available</td></tr><tr><td>C++</td><td>uint32_t getAvailable();</td></tr><tr><td>.NET</td><td>public uint Available { get; }</td></tr><tr><td align="center" colspan="2">Property: Unsettled</td></tr><tr><td>C++</td><td>uint32_t getUnsettled();</td></tr><tr><td>.NET</td><td>public uint Unsettled { get; }</td></tr><tr><td align="center" colspan="2">Method: Close</td></tr><tr><td>C++</td><td>void close();</td></tr><tr><td>.NET</td><td>public void Close();</td></tr><tr><td align="center" colspan="2">Property: IsClosed</td></tr><tr><td>C++</td><td>bool isClosed() const;</td></tr><tr><td>.NET</td><td>public bool IsClosed { get; }</td></tr><tr><td align="center" colspan="2">Property: Name</td></tr><tr><td>C++</td><td>const std::string&amp; getName() const;</td></tr><tr><td>.NET</td><td>public string Name { get; }</td></tr><tr><td align="center" colspan="2">Property: Session</td></tr><tr><td>C++</td><td>Session getSession() const;</td></tr><tr><td>.NET</td><td>public Session Session { get; }</td></tr></tbody></table></div></div><br class="table-break" /></div><div class="section" title="5.3.7.&#160;.NET Binding for the C++ Messaging API Class: Sender"><div class="titlepage"><div><div><h3 class="title"><a id="idp33688832" />5.3.7.&#160;.NET Binding for the C++ Messaging API Class: Sender</h3></div></div></div><div class="table"><a id="table-Dotnet-Binding-Sender" /><p class="title"><strong>Table&#160;5.15.&#160;.NET Binding for the C++ Messaging API Class: Sender</strong></p><div class="table-contents"><table border="1" summary=".NET Binding for the C++ Messaging API Class: Sender"><colgroup><col class="c1" /><col class="c2" /></colgroup><thead><tr><th align="center" colspan="2">.NET Binding Class: Sender</th></tr><tr><th>Language</th><th>Syntax</th></tr></thead><tbody><tr><td>C++</td><td>class Sender</td></tr><tr><td>.NET</td><td>public ref class Sender</td></tr><tr><td align="center" colspan="2">Constructor</td></tr><tr><td>.NET</td><td>Constructed object is returned by Session.CreateSender</td></tr><tr><td align="center" colspan="2">Copy constructor</td></tr><tr><td>C++</td><td>Sender(const Sender&amp;);</td></tr><tr><td>.NET</td><td>public Sender(Sender sender);</td></tr><tr><td align="center" colspan="2">Destructor</td></tr><tr><td>C++</td><td>~Sender();</td></tr><tr><td>.NET</td><td>~Sender();</td></tr><tr><td align="center" colspan="2">Finalizer</td></tr><tr><td>C++</td><td>n/a</td></tr><tr><td>.NET</td><td>!Sender()</td></tr><tr><td align="center" colspan="2">Copy assignment operator</td></tr><tr><td>C++</td><td>Sender&amp; operator=(const Sender&amp;);</td></tr><tr><td>.NET</td><td>public Sender op_Assign(Sender rhs);</td></tr><tr><td align="center" colspan="2">Method: Send</td></tr><tr><td>C++</td><td>void send(const Message&amp; message, bool sync=false);</td></tr><tr><td>.NET</td><td>public void Send(Message mmsgp);</td></tr><tr><td>.NET</td><td>public void Send(Message mmsgp, bool sync);</td></tr><tr><td align="center" colspan="2">Method: Close</td></tr><tr><td>C++</td><td>void close();</td></tr><tr><td>.NET</td><td>public void Close();</td></tr><tr><td align="center" colspan="2">Property: Capacity</td></tr><tr><td>C++</td><td>void setCapacity(uint32_t);</td></tr><tr><td>C++</td><td>uint32_t getCapacity();</td></tr><tr><td>.NET</td><td>public uint Capacity { get; set; }</td></tr><tr><td align="center" colspan="2">Property: Available</td></tr><tr><td>C++</td><td>uint32_t getAvailable();</td></tr><tr><td>.NET</td><td>public uint Available { get; }</td></tr><tr><td align="center" colspan="2">Property: Unsettled</td></tr><tr><td>C++</td><td>uint32_t getUnsettled();</td></tr><tr><td>.NET</td><td>public uint Unsettled { get; }</td></tr><tr><td align="center" colspan="2">Property: Name</td></tr><tr><td>C++</td><td>const std::string&amp; getName() const;</td></tr><tr><td>.NET</td><td>public string Name { get; }</td></tr><tr><td align="center" colspan="2">Property: Session</td></tr><tr><td>C++</td><td>Session getSession() const;</td></tr><tr><td>.NET</td><td>public Session Session { get; }</td></tr></tbody></table></div></div><br class="table-break" /></div><div class="section" title="5.3.8.&#160;.NET Binding for the C++ Messaging API Class: Session"><div class="titlepage"><div><div><h3 class="title"><a id="idp33745344" />5.3.8.&#160;.NET Binding for the C++ Messaging API Class: Session</h3></div></div></div><div class="table"><a id="table-Dotnet-Binding-Session" /><p class="title"><strong>Table&#160;5.16.&#160;.NET Binding for the C++ Messaging API Class: Session</strong></p><div class="table-contents"><table border="1" summary=".NET Binding for the C++ Messaging API Class: Session"><colgroup><col class="c1" /><col class="c2" /></colgroup><thead><tr><th align="center" colspan="2">.NET Binding Class: Session</th></tr><tr><th>Language</th><th>Syntax</th></tr></thead><tbody><tr><td>C++</td><td>class Session</td></tr><tr><td>.NET</td><td>public ref class Session</td></tr><tr><td align="center" colspan="2">Constructor</td></tr><tr><td>.NET</td><td>Constructed object is returned by Connection.CreateSession</td></tr><tr><td align="center" colspan="2">Copy constructor</td></tr><tr><td>C++</td><td>Session(const Session&amp;);</td></tr><tr><td>.NET</td><td>public Session(Session session);</td></tr><tr><td align="center" colspan="2">Destructor</td></tr><tr><td>C++</td><td>~Session();</td></tr><tr><td>.NET</td><td>~Session();</td></tr><tr><td align="center" colspan="2">Finalizer</td></tr><tr><td>C++</td><td>n/a</td></tr><tr><td>.NET</td><td>!Session()</td></tr><tr><td align="center" colspan="2">Copy assignment operator</td></tr><tr><td>C++</td><td>Session&amp; operator=(const Session&amp;);</td></tr><tr><td>.NET</td><td>public Session op_Assign(Session rhs);</td></tr><tr><td align="center" colspan="2">Method: Close</td></tr><tr><td>C++</td><td>void close();</td></tr><tr><td>.NET</td><td>public void Close();</td></tr><tr><td align="center" colspan="2">Method: Commit</td></tr><tr><td>C++</td><td>void commit();</td></tr><tr><td>.NET</td><td>public void Commit();</td></tr><tr><td align="center" colspan="2">Method: Rollback</td></tr><tr><td>C++</td><td>void rollback();</td></tr><tr><td>.NET</td><td>public void Rollback();</td></tr><tr><td align="center" colspan="2">Method: Acknowledge</td></tr><tr><td>C++</td><td>void acknowledge(bool sync=false);</td></tr><tr><td>C++</td><td>void acknowledge(Message&amp;, bool sync=false);</td></tr><tr><td>.NET</td><td>public void Acknowledge();</td></tr><tr><td>.NET</td><td>public void Acknowledge(bool sync);</td></tr><tr><td>.NET</td><td>public void Acknowledge(Message __p1);</td></tr><tr><td>.NET</td><td>public void Acknowledge(Message __p1, bool __p2);</td></tr><tr><td align="center" colspan="2">Method: Reject</td></tr><tr><td>C++</td><td>void reject(Message&amp;);</td></tr><tr><td>.NET</td><td>public void Reject(Message __p1);</td></tr><tr><td align="center" colspan="2">Method: Release</td></tr><tr><td>C++</td><td>void release(Message&amp;);</td></tr><tr><td>.NET</td><td>public void Release(Message __p1);</td></tr><tr><td align="center" colspan="2">Method: Sync</td></tr><tr><td>C++</td><td>void sync(bool block=true);</td></tr><tr><td>.NET</td><td>public void Sync();</td></tr><tr><td>.NET</td><td>public void Sync(bool block);</td></tr><tr><td align="center" colspan="2">Property: Receivable</td></tr><tr><td>C++</td><td>uint32_t getReceivable();</td></tr><tr><td>.NET</td><td>public uint Receivable { get; }</td></tr><tr><td align="center" colspan="2">Property: UnsettledAcks</td></tr><tr><td>C++</td><td>uint32_t getUnsettledAcks();</td></tr><tr><td>.NET</td><td>public uint UnsetledAcks { get; }</td></tr><tr><td align="center" colspan="2">Method: NextReceiver</td></tr><tr><td>C++</td><td>bool nextReceiver(Receiver&amp;, Duration timeout=Duration::FOREVER);</td></tr><tr><td>.NET</td><td>public bool NextReceiver(Receiver rcvr);</td></tr><tr><td>.NET</td><td>public bool NextReceiver(Receiver rcvr, Duration timeout);</td></tr><tr><td align="center" colspan="2">Method: NextReceiver</td></tr><tr><td>C++</td><td>Receiver nextReceiver(Duration timeout=Duration::FOREVER);</td></tr><tr><td>.NET</td><td>public Receiver NextReceiver();</td></tr><tr><td>.NET</td><td>public Receiver NextReceiver(Duration timeout);</td></tr><tr><td align="center" colspan="2">Method: CreateSender</td></tr><tr><td>C++</td><td>Sender createSender(const Address&amp; address);</td></tr><tr><td>.NET</td><td>public Sender CreateSender(Address address);</td></tr><tr><td align="center" colspan="2">Method: CreateSender</td></tr><tr><td>C++</td><td>Sender createSender(const std::string&amp; address);</td></tr><tr><td>.NET</td><td>public Sender CreateSender(string address);</td></tr><tr><td align="center" colspan="2">Method: CreateReceiver</td></tr><tr><td>C++</td><td>Receiver createReceiver(const Address&amp; address);</td></tr><tr><td>.NET</td><td>public Receiver CreateReceiver(Address address);</td></tr><tr><td align="center" colspan="2">Method: CreateReceiver</td></tr><tr><td>C++</td><td>Receiver createReceiver(const std::string&amp; address);</td></tr><tr><td>.NET</td><td>public Receiver CreateReceiver(string address);</td></tr><tr><td align="center" colspan="2">Method: GetSender</td></tr><tr><td>C++</td><td>Sender getSender(const std::string&amp; name) const;</td></tr><tr><td>.NET</td><td>public Sender GetSender(string name);</td></tr><tr><td align="center" colspan="2">Method: GetReceiver</td></tr><tr><td>C++</td><td>Receiver getReceiver(const std::string&amp; name) const;</td></tr><tr><td>.NET</td><td>public Receiver GetReceiver(string name);</td></tr><tr><td align="center" colspan="2">Property: Connection</td></tr><tr><td>C++</td><td>Connection getConnection() const;</td></tr><tr><td>.NET</td><td>public Connection Connection { get; }</td></tr><tr><td align="center" colspan="2">Property: HasError</td></tr><tr><td>C++</td><td>bool hasError();</td></tr><tr><td>.NET</td><td>public bool HasError { get; }</td></tr><tr><td align="center" colspan="2">Method: CheckError</td></tr><tr><td>C++</td><td>void checkError();</td></tr><tr><td>.NET</td><td>public void CheckError();</td></tr></tbody></table></div></div><br class="table-break" /></div><div class="section" title="5.3.9.&#160;.NET Binding Class: SessionReceiver"><div class="titlepage"><div><div><h3 class="title"><a id="idp33857728" />5.3.9.&#160;.NET Binding Class: SessionReceiver</h3></div></div></div><p>
	The SessionReceiver class provides a convenient callback
	mechanism for Messages received by all Receivers on a given
	Session.
      </p><p>
	</p><pre class="programlisting">
using Org.Apache.Qpid.Messaging;
using System;

namespace Org.Apache.Qpid.Messaging.SessionReceiver
{
    public interface ISessionReceiver
    {
        void SessionReceiver(Receiver receiver, Message message);
    }

    public class CallbackServer
    {
        public CallbackServer(Session session, ISessionReceiver callback);

        public void Close();
    }
}

	</pre><p>
      </p><p>
	To use this class a client program includes references to both
	Org.Apache.Qpid.Messaging and Org.Apache.Qpid.Messaging.SessionReceiver.
	The calling program creates a function that implements the
	ISessionReceiver interface. This function will be called whenever
	message is received by the session. The callback process is started
	by creating a CallbackServer and will continue to run until the
	client program calls the CallbackServer.Close function.
      </p><p>
	A complete operating example of using the SessionReceiver callback
	is contained in cpp/bindings/qpid/dotnet/examples/csharp.map.callback.receiver.
      </p></div></div></div></div></div>