#!/usr/bin/python
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#

from transom.script import *

import re

from pygments import highlight as _highlight
from pygments.lexers import get_lexer_by_name
from pygments.formatters import HtmlFormatter
from xml.etree import ElementTree

call("dot -V")
call("doxygen --version")
call("epydoc --version")
call("rdoc --version")
call("xsltproc --version")
call("xmllint --version")

## API docs ##

doxygen_conf_template = u"""
DISABLE_INDEX = yes
EXTRACT_ALL = yes
GENERATE_LATEX = no
GENERATE_TREEVIEW = yes
HAVE_DOT = yes
PROJECT_NUMBER = {release}
QUIET = yes
RECURSIVE = yes
INPUT = {input_paths}
PROJECT_NAME = "{title}"
STRIP_FROM_PATH = {strip_paths}
HTML_OUTPUT = {output_dir}
"""

def gen_doxygen(release, title, input_paths, strip_paths, output_dir):
    input_paths = " ".join(input_paths)
    strip_paths = " ".join(strip_paths)

    conf = doxygen_conf_template.format(**locals())
    path = write_entry("conf", conf)

    call("doxygen {}", path)

    touch(join(output_dir, ".transom-skip"))

def gen_epydoc(release, title, input_paths, input_namespaces, output_dir):
    # XXX programmatic instead?

    input_paths = ":".join(input_paths)
    input_namespaces = " ".join(input_namespaces)

    options = list()
    options.append("--graph all")
    options.append("--html")
    options.append("--name \"{}\"".format(title))
    options.append("--no-private")
    options.append("--output {}".format(output_dir))
    options.append("--quiet")
    options.append("--url \"@site-url@/index.html\"")
    options = " ".join(options)

    call("PYTHONPATH={} epydoc {} {}", input_paths, options, input_namespaces)

    touch(join(output_dir, ".transom-skip"))

def gen_rdoc(release, title, base_input_path, input_paths, output_dir):
    output_dir = os.path.abspath(output_dir)

    # rdoc wants to make this dir
    remove(output_dir)

    options = list()
    options.append("--fmt html")
    options.append("--op {}".format(output_dir))
    options.append("--quiet")
    options.append("--title \"{}\"".format(title))
    options = " ".join(options)

    input_paths = " ".join(input_paths)

    call("cd {} && rdoc {} {}", base_input_path, options, input_paths)
    
    touch(join(output_dir, ".transom-skip"))

## Examples ##

def gen_examples(release, title, lang, input_dir, input_names, output_dir,
                 readme_url=None, source_url=None):
    for name in input_names:
        gen_example_page(release=release,
                         index_title=title,
                         title=name,
                         lang=lang,
                         input_dir=input_dir,
                         input_name=name,
                         output_dir=output_dir)

    gen_examples_index(release=release,
                       title=title,
                       lang=lang,
                       input_names=input_names,
                       output_dir=output_dir,
                       readme_url=readme_url,
                       source_url=source_url)

example_page_template = u"""
<h1>{title}</h1>
{content}
<p><a href="{input_name}">Download this file</a></p>
"""

def gen_example_page(release, index_title, title, lang, input_dir, input_name,
                     output_dir):
    input_path = join(input_dir, input_name)
    output_path = join(output_dir, input_name)
    html_output_path = join(output_dir, "{}.html.in".format(input_name))

    content = read(input_path)
    content = strip_license_header(content, lang)
    content = content.strip()
    content = highlight(content, lang)

    html = example_page_template.format(**locals())

    copy(input_path, output_path)
    write(html_output_path, html)

formatter = HtmlFormatter(linenos=False) # XXX

def highlight(string, lang):
    lexer = get_lexer_by_name(lang)
    return _highlight(string, lexer, formatter)

license_header_regexes = {
    "cpp": re.compile(r"/\*.*?\*/", re.DOTALL),
    "csharp": re.compile(r"/\*.*?\*/", re.DOTALL),
    }

def strip_license_header(string, lang):
    if lang in license_header_regexes:
        regex = license_header_regexes[lang]
        return re.sub(regex, "", string)
    elif lang in ("perl", "python", "ruby"):
        input_lines = string.split(os.linesep)
        output_lines = list()

        for i, line in enumerate(input_lines):
            if not line.startswith("#"):
                output_lines.extend(input_lines[i:])
                break

        return os.linesep.join(output_lines)
    else:
        return string

examples_index_template = """
# {title}

## Example files

{example_links}

## More information

{info_links}
"""

def gen_examples_index(release, title, lang, input_names, output_dir,
                       readme_url=None, source_url=None):
    output_path = join(output_dir, "index.md")
    example_links = list()
    info_links = list()

    for name in input_names:
        example_links.append(" - [{}]({}.html)".format(name, name))

    if readme_url:
        info_links.append(" - [README]({})".format(readme_url))

    if source_url:
        info_links.append(" - [Source location]({})".format(source_url))

    example_links = os.linesep.join(example_links)
    info_links = os.linesep.join(info_links)
    
    index = examples_index_template.format(**locals())

    write(output_path, index)

## Messaging API ##

def gen_messaging_api(release, source_dir, output_dir):
    remove(output_dir)

    cpp_dir = join(output_dir, "cpp")
    dotnet_dir = join(output_dir, "dotnet")
    perl_dir = join(output_dir, "perl")
    python_dir = join(output_dir, "python")
    ruby_dir = join(output_dir, "ruby")

    gen_cpp_messaging_api(release, source_dir, cpp_dir)
    gen_dotnet_messaging_api(release, source_dir, dotnet_dir)
    gen_perl_messaging_api(release, source_dir, perl_dir)
    gen_python_messaging_api(release, source_dir, python_dir)
    gen_ruby_messaging_api(release, source_dir, ruby_dir)

def gen_cpp_messaging_api(release, source_dir, output_dir):
    api_dir = make_dirs(join(output_dir, "api"))
    examples_dir = make_dirs(join(output_dir, "examples"))

    # API
    
    include_dir = join(source_dir, "cpp", "include")
    input_paths = (
        join(source_dir, "cpp", "docs", "api", "doxygen_mainpage.h"),
        join(include_dir, "qpid", "messaging"),
        join(include_dir, "qpid", "types"),
        )

    gen_doxygen(release=release,
                title="Qpid C++ Messaging API",
                input_paths=input_paths,
                strip_paths=(include_dir,),
                output_dir=api_dir)

    # Examples

    input_dir = join(source_dir, "cpp", "examples", "messaging")
    input_names = list_dir(input_dir, "*.cpp", "*.h")

    release_url = "http://svn.apache.org/repos/asf/qpid/tags/{}".format(release)
    readme_url = "{}/qpid/cpp/examples/README.txt".format(release_url)
    source_url = "{}/qpid/cpp/examples/messaging".format(release_url)

    gen_examples(release=release,
                 lang="cpp",
                 title="C++ Messaging API Examples",
                 input_dir=input_dir,
                 input_names=input_names,
                 output_dir=examples_dir,
                 readme_url=readme_url,
                 source_url=source_url)

def gen_dotnet_messaging_api(release, source_dir, output_dir):
    api_dir = make_dirs(join(output_dir, "api"))
    examples_dir = make_dirs(join(output_dir, "examples"))

    # API

    include_dir = join(source_dir, "cpp", "bindings", "qpid", "dotnet", "src")
    input_paths = (include_dir,)

    gen_doxygen(release=release,
                title="Qpid .NET Messaging API",
                input_paths=input_paths,
                strip_paths=(include_dir,),
                output_dir=api_dir)

    # Examples

    input_dir = join(source_dir, "cpp", "bindings", "qpid", "dotnet",
                     "examples")

    # The layout of dotnet examples is funky, so some schlepping to
    # normalize it

    temp_dir = make_temp_dir()
    input_names = set()

    for path in find(input_dir, "*.cs"):
        name = split(path)[1]

        if name == "AssemblyInfo.cs":
            continue

        copy(path, join(temp_dir, name))
        input_names.add(name)

    input_names = sorted(input_names)

    release_url = "http://svn.apache.org/repos/asf/qpid/tags/{}".format(release)
    source_url = "{}/qpid/cpp/bindings/qpid/dotnet/examples".format(release_url)

    gen_examples(release=release,
                 title=".NET Messaging API Examples",
                 lang="csharp",
                 input_dir=temp_dir,
                 input_names=input_names,
                 output_dir=examples_dir,
                 source_url=source_url)

def gen_perl_messaging_api(release, source_dir, output_dir):
    api_dir = make_dirs(join(output_dir, "api"))
    examples_dir = make_dirs(join(output_dir, "examples"))

    # Examples

    input_dir = join(source_dir, "cpp", "bindings", "qpid", "examples", "perl")
    input_names = list_dir(input_dir, "*.pl")

    release_url = "http://svn.apache.org/repos/asf/qpid/tags/{}".format(release)
    source_url = "{}/qpid/cpp/bindings/qpid/examples/perl".format(release_url)

    gen_examples(release=release,
                 title="Perl Messaging API Examples",
                 lang="perl",
                 input_dir=input_dir,
                 input_names=input_names,
                 output_dir=examples_dir,
                 source_url=source_url)

def gen_python_messaging_api(release, source_dir, output_dir):
    api_dir = make_dirs(join(output_dir, "api"))
    examples_dir = make_dirs(join(output_dir, "examples"))

    # API

    input_path = join(source_dir, "python")
    input_namespace = "qpid.messaging"

    gen_epydoc(release=release,
               title="Qpid Python Messaging API",
               input_paths=(input_path,),
               input_namespaces=(input_namespace,),
               output_dir=api_dir)

    # Examples

    input_dir = join(source_dir, "python", "examples", "api")
    input_names = list_dir(input_dir)

    release_url = "http://svn.apache.org/repos/asf/qpid/tags/{}".format(release)
    readme_url = "{}/qpid/python/examples/README.txt".format(release_url)
    source_url = "{}/qpid/python/examples".format(release_url)

    gen_examples(release=release,
                 title="Python Messaging API Examples",
                 lang="python",
                 input_dir=input_dir,
                 input_names=input_names,
                 output_dir=examples_dir,
                 readme_url=readme_url,
                 source_url=source_url)

def gen_ruby_messaging_api(release, source_dir, output_dir):
    api_dir = make_dirs(join(output_dir, "api"))
    examples_dir = make_dirs(join(output_dir, "examples"))

    # API

    base_input_path = join(source_dir, "cpp", "bindings")
    input_path = join("qpid", "ruby", "lib")

    gen_rdoc(release=release,
             title="Qpid Ruby Messaging API",
             base_input_path=base_input_path,
             input_paths=(input_path,),
             output_dir=api_dir)

    #name = "qpid-{}-ruby-messaging-api-apiref".format(release)
    #make_archive(api_dir, output_dir, name)

    # Examples

    input_dir = join(source_dir, "cpp", "bindings", "qpid", "ruby", "examples")
    input_names = list_dir(input_dir, "*.rb")

    release_url = "http://svn.apache.org/repos/asf/qpid/tags/{}".format(release)
    source_url = "{}/qpid/cpp/bindings/qpid/ruby/examples".format(release_url)

    gen_examples(release=release,
                 title="Ruby Messaging API Examples",
                 lang="ruby",
                 input_dir=input_dir,
                 input_names=input_names,
                 output_dir=examples_dir,
                 source_url=source_url)

## Docbook ##

def gen_books(release, source_dir, output_dir):
    input_dir = join(source_dir, "doc", "book")

    stylesheet = """<?xml version='1.0'?>
    <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
    <xsl:import href="http://docbook.sourceforge.net/release/xsl/current/xhtml/onechunk.xsl"/>
    </xsl:stylesheet>"""

    write(join(input_dir, "xsl", "html-custom.xsl"), stylesheet)

    call("make -C {} clean html", input_dir)

    cpp_broker_input_dir = join(input_dir, "build", "AMQP-Messaging-Broker-CPP-Book", "html")
    java_broker_input_dir = join(input_dir, "build", "AMQP-Messaging-Broker-Java-Book", "html")
    prog_guide_input_dir = join(input_dir, "build", "Programming-In-Apache-Qpid", "html")
    cpp_broker_output_dir = join(output_dir, "cpp-broker", "book", "html")
    java_broker_output_dir = join(output_dir, "java-broker", "book", "html")
    prog_guide_output_dir = join(output_dir, "prog-guide", "book", "html")

    remove(cpp_broker_output_dir)
    remove(java_broker_output_dir)
    remove(prog_guide_output_dir)

    copy(cpp_broker_input_dir, cpp_broker_output_dir)
    copy(java_broker_input_dir, java_broker_output_dir)
    copy(prog_guide_input_dir, prog_guide_output_dir)

    for dir in (cpp_broker_output_dir, java_broker_output_dir, prog_guide_output_dir):
        for path in find(dir, "*.html"):
            tree = ElementTree.parse(path)
            elem = tree.find(".//{http://www.w3.org/1999/xhtml}body")

            elem.tag = "div"
            elem.set("class", "docbook")

            remove_namespace(elem, "http://www.w3.org/1999/xhtml")

            content = ElementTree.tostring(elem)
            
            write("{}.in".format(path), content)
            remove(path)

# From http://homework.nwsnet.de/releases/45be/
def remove_namespace(doc, namespace):
    """Remove namespace in the passed document in place."""
    ns = u'{%s}' % namespace
    nsl = len(ns)
    for elem in doc.getiterator():
        if elem.tag.startswith(ns):
            elem.tag = elem.tag[nsl:]

## Now do stuff ##

if len(sys.argv) != 3:
    sys.exit("Usage: script RELEASE OUTPUT-DIR")

release = sys.argv[1]
output_dir = sys.argv[2]

temp_dir = make_user_temp_dir()
source_dir = join(temp_dir, "qpid-{}".format(release))

messaging_api_output_dir = join(output_dir, "messaging-api")

export_release(release, source_dir)

gen_messaging_api(release, source_dir, messaging_api_output_dir)
gen_books(release, source_dir, output_dir)
